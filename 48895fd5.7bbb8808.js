(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{100:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return m}));var r=t(0),a=t.n(r);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=a.a.createContext({}),p=function(e){var n=a.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},d=function(e){var n=p(e.components);return a.a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},b=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=p(t),b=r,m=d["".concat(o,".").concat(b)]||d[b]||u[b]||i;return t?a.a.createElement(m,c(c({ref:n},s),{},{components:t})):a.a.createElement(m,c({ref:n},s))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=b;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=t[s];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},65:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return p}));var r=t(2),a=t(6),i=(t(0),t(100)),o={title:"Pred",description:"Pred Crock",layout:"guide",weight:100},c={unversionedId:"crocks/Pred",id:"crocks/Pred",isDocsHomePage:!1,title:"Pred",description:"Pred Crock",source:"@site/docs/crocks/Pred.md",slug:"/crocks/Pred",permalink:"/crocks/docs/docs/crocks/Pred",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Pred.md",version:"current",sidebar:"sidebar",previous:{title:"Pair",permalink:"/crocks/docs/docs/crocks/Pair"},next:{title:"Reader",permalink:"/crocks/docs/docs/crocks/Reader"}},l=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"empty",id:"empty",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"concat",id:"concat",children:[]},{value:"contramap",id:"contramap",children:[]},{value:"valueOf",id:"valueof",children:[]},{value:"runWith",id:"runwith",children:[]}]}],s={rightToc:l};function p(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Pred a Boolean\n")),Object(i.b)("p",null,"Defined as a Monoidal Contravariant datatype, ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," wraps a predicate function\nof the form ",Object(i.b)("inlineCode",{parentName:"p"},"(a -> Boolean)"),"."),Object(i.b)("p",null,"The far right parameter of ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," is always fixed to the type of ",Object(i.b)("inlineCode",{parentName:"p"},"Boolean"),", so\nthe result of the wrapped predicate function can never be mapped. While the\nright parameter is fixed, the input to the predicate can vary."),Object(i.b)("p",null,"Another property of ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," instances is that they can be combined using their\nMonodial interface. Combining instances will result in a new instance that\nreturns the result of each ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," under logical conjunction."),Object(i.b)("p",null,"As ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," wraps a function, it is lazy and will not execute until its argument\nis satisfied. A given instance is run but calling the ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"#runwith"}),Object(i.b)("inlineCode",{parentName:"a"},"runWith")),"\nmethod, supplying it the argument to test."),Object(i.b)("p",null,"One of the features of ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," is the ability to use both normal predicate\nfunctions and ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," instances interchangeably. For any ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," function that\ntakes a predicate, either a predicate function or a ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," instance can be used."),Object(i.b)("p",null,"This implementation of ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," was heavily inspired by ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://medium.com/@drboolean/monoidal-contravariant-functors-are-actually-useful-1032211045c4#.polugsx2a"}),"this article"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pred from 'crocks/Pred'\n\nimport isNumber from 'crocks/predicates/isNumber'\nimport getPropOr from 'crocks/helpers/getPropOr'\nimport filter from 'crocks/pointfree/filter'\n\n// largeNumber :: Pred Number\nconst largeNumber =\n  Pred(isNumber)\n    .concat(Pred(x => x > 100))\n\n// largeItem :: Pred Object\nconst largeItem =\n  largeNumber\n    .contramap(getPropOr(null, 'item'))\n\nlargeNumber\n  .runWith(45)\n//=> false\n\nlargeNumber\n  .runWith(175)\n//=> true\n\nlargeItem\n  .runWith({ item: 190 })\n//=> true\n\nlargeItem\n  .runWith({ item: 9 })\n//=> false\n\nlargeItem\n  .runWith(9)\n//=> false\n\nfilter(largeNumber, [ 200, 375, 15 ])\n//=> [ 200, 375 ]\n")),Object(i.b)("h2",{id:"implements"},"Implements"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Contravariant")),Object(i.b)("h2",{id:"construction"},"Construction"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Pred :: (a -> Boolean) -> Pred a\n")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," constructor is a unary function that requires a unary predicate\nfunction as its sole argument. Once provided with its predicate function,\nthe constructor will return a new ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," instance wrapping the predicate."),Object(i.b)("p",null,"If the function provided is not a predicate, then the resulting value will be\ncoerced to a ",Object(i.b)("inlineCode",{parentName:"p"},"Boolean"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pred from 'crocks/Pred'\n\nimport and from 'crocks/logic/and'\nimport isArray from 'crocks/predicates/isArray'\n\n// isEmpty :: a -> Boolean\nconst isEmpty =\n  x => !x.length\n\n// isEmptyArray :: a -> Boolean\nconst isEmptyArray =\n  and(isArray, isEmpty)\n\nPred(isEmptyArray)\n//=> Pred a\n")),Object(i.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(i.b)("h3",{id:"empty"},"empty"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Pred.empty :: () -> Pred a\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"empty")," provides the identity for the ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid")," in that when the value it\nprovides is ",Object(i.b)("inlineCode",{parentName:"p"},"concat"),"ed to any other value, it will return the other value. In\nthe case of ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," the result of ",Object(i.b)("inlineCode",{parentName:"p"},"empty")," is a ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," that will always\nreturn ",Object(i.b)("inlineCode",{parentName:"p"},"true"),". ",Object(i.b)("inlineCode",{parentName:"p"},"empty")," is available on both the Constructor and the Instance\nfor convenience."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pred from 'crocks/Pred'\n\nimport isEmpty from 'crocks/predicates/isEmpty'\nimport not from 'crocks/logic/not'\n\n// empty :: Pred a\nconst empty =\n  Pred.empty()\n\n// notEmpty :: Pred a\nconst notEmpty =\n  Pred(not(isEmpty))\n\nempty\n  .runWith('')\n//=> true\n\nnotEmpty\n  .concat(empty)\n  .runWith([])\n//=> false\n\nnotEmpty\n  .concat(empty)\n  .runWith([ 1, 2, 3 ])\n//=> true\n\nempty\n  .concat(notEmpty)\n  .runWith('')\n//=> false\n\nempty\n  .concat(notEmpty)\n  .runWith('123')\n//=> true\n")),Object(i.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(i.b)("h3",{id:"concat"},"concat"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Pred a ~> Pred a -> Pred a\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"concat")," is used to combine two ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),"s of the same type under an operation\nspecified by the ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),". In the case of ",Object(i.b)("inlineCode",{parentName:"p"},"Pred"),", the results of\nboth ",Object(i.b)("inlineCode",{parentName:"p"},"Preds"),"s are combined under logical conjunction."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pred from 'crocks/Pred'\n\nimport or from 'crocks/logic/or'\nimport not from 'crocks/logic/not'\nimport filter from 'crocks/pointfree/filter'\n\nconst isEven =\n  x => !(x % 2)\n\n// isOdd :: Pred Number\nconst isOdd =\n  Pred(not(isEven))\n\n// lt20 :: Pred Number\nconst lt20 =\n  Pred(x => x < 20)\n\n// gt5 :: Pred Number\nconst gt5 =\n  Pred(x => x > 5)\n\n// inRange :: Pred Number\nconst inRange =\n  lt20.concat(gt5)\n\n// isOddInRange :: Pred Number\nconst isOddInRange =\n  isOdd.concat(inRange)\n\n// isValid :: Pred Number\nconst isValid =\n  Pred(or(isEven, isOddInRange))\n\n// data :: [ Number ]\nconst data =\n[ 1, 4, 12, 19, 32, 99, 76, 7 ]\n\nisOdd\n  .runWith(5)\n//=> true\n\nisOdd\n  .runWith(8)\n//=> false\n\nfilter(isOdd, data)\n//=> [ 1, 19, 99, 7 ]\n\nfilter(lt20, data)\n//=> [ 1, 4, 12, 19, 7 ]\n\nfilter(gt5, data)\n//=> [ 12, 19, 32, 99, 76, 7 ]\n\nfilter(inRange, data)\n//=> [ 12, 19, 7 ]\n\nfilter(isOddInRange, data)\n//=> [ 19, 7 ]\n\nfilter(isEven, data)\n// [ 4, 12, 32, 76 ]\n\nfilter(isValid, data)\n//=> [ 4, 12, 19, 32, 76, 7 ]\n")),Object(i.b)("h3",{id:"contramap"},"contramap"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Pred a ~> (b -> a) -> Pred b\n")),Object(i.b)("p",null,"While the output of a ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," is fixed to ",Object(i.b)("inlineCode",{parentName:"p"},"Boolean"),", the input can vary type and\nvalue. This allows a given ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," to be adapted by mapping on the input, before\nit hits the wrapped predicate function. Using ",Object(i.b)("inlineCode",{parentName:"p"},"contramap"),", functions are lifted,\nmapping the input to now accept the type of the input of the given function."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pred from 'crocks/Pred'\nimport contramap from 'crocks/pointfree/contramap'\nimport getPropOr from 'crocks/helpers/getPropOr'\n\n// Length :: String | Function | Array\n// length :: Length -> Number\nconst length =\n  getPropOr(0, 'length')\n\n// gt5 :: Pred Number\nconst gt5 =\n  Pred(x => x > 5)\n\n// lengthGt5 :: Pred Length\nconst validLength =\n  contramap(length, gt5)\n\n// validItemLength :: Pred Object\nconst validItemLength =\n  contramap(getPropOr(null, 'item'), validLength)\n\ngt5\n  .runWith(5)\n//=> false\n\ngt5\n  .runWith(10)\n//=> true\n\nvalidLength\n  .runWith([ 1, 2, 3, 4, 5, 6 ])\n//=> true\n\nvalidLength\n  .runWith(null)\n//=> false\n\nvalidLength\n  .runWith('1234')\n//=> false\n\nvalidItemLength\n  .runWith({ item: 'this is an item' })\n//=> true\n")),Object(i.b)("h3",{id:"valueof"},"valueOf"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Pred a ~> () -> a -> Boolean\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"valueOf")," is used on all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid"),"s as a means of extraction. While the\nextraction is available, types that implement ",Object(i.b)("inlineCode",{parentName:"p"},"valueOf")," are not necessarily\na ",Object(i.b)("inlineCode",{parentName:"p"},"Comonad"),". This function is used primarily for convenience for some of the\nhelper functions that ship with ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),"."),Object(i.b)("p",null,"Calling ",Object(i.b)("inlineCode",{parentName:"p"},"valueOf")," on a ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," instance will result in the underlying predicate\nfunction. Most of the time this will not be required when working\nwith ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," because all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," functions that take a predicate function can\nalso take a ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," instance."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pred from 'crocks/Pred'\n\nimport equals from 'crocks/pointfree/equals'\nimport isArray from 'crocks/predicates/isArray'\nimport isString from 'crocks/predicates/isString'\nimport or from 'crocks/logic/or'\n\n// lengthIsThree :: Pred a\nconst lengthIsThree =\n  Pred(equals(3))\n    .contramap(x => x.length)\n\n// pred :: Pred a\nconst pred =\n  Pred(or(isArray, isString))\n    .concat(lengthIsThree)\n\n// fn :: a -> Boolean\nconst fn =\n  pred.valueOf()\n\npred\n  .runWith(null)\n//=> false\n\npred\n  .runWith([ 1, 2, 3 ])\n//=> true\n\npred\n  .runWith('This is fun')\n//=> true\n\nfn(null)          // false\nfn([ 1, 2, 3 ])   // true\nfn('This is fun') // true\nfn([])            // false\nfn('')            // false\n")),Object(i.b)("h3",{id:"runwith"},"runWith"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Pred a ~> a -> Boolean\n")),Object(i.b)("p",null,"As ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," wraps a predicate function, it needs a mean to run it with some value\nto test against the predicate. ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," instances provide a method\ncalled ",Object(i.b)("inlineCode",{parentName:"p"},"runWith")," that will accept the value to be tested and then runs it\nthrough the predicate returning the result."),Object(i.b)("p",null,"Most of the time this function is not used while working with other predicate\nfunctions in ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),", as all functions that take a predicate function also\ntake a ",Object(i.b)("inlineCode",{parentName:"p"},"Pred")," instance. It does come in handy though when supplying predicates\nto other libraries."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pred from 'crocks/Pred'\n\nimport hasProp from 'crocks/predicates/hasProp'\nimport equals from 'crocks/pointfree/equals'\nimport flip from 'crocks/combinators/flip'\nimport runWith from 'crocks/pointfree/runWith'\n\n// trueBlue :: Pred Object\nconst trueBlue =\n  Pred(equals(true))\n    .contramap(({ blue }) => blue)\n\n// isValid :: Pred a\nconst isValid =\n  Pred(hasProp('blue'))\n    .concat(trueBlue)\n\n// checkValid :: a -> Boolean\nconst checkValid =\n  flip(runWith, isValid)\n\ncheckValid(null)            //=> false\ncheckValid([ 1, 2, 3 ])     //=> false\ncheckValid({ blue: 32 })    //=> false\ncheckValid({ blue: true })  //=> true\n")))}p.isMDXComponent=!0}}]);