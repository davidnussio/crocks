(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{100:function(e,n,t){"use strict";t.d(n,"a",(function(){return l})),t.d(n,"b",(function(){return d}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var b=r.a.createContext({}),p=function(e){var n=r.a.useContext(b),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},l=function(e){var n=p(e.components);return r.a.createElement(b.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},h=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,b=s(e,["components","mdxType","originalType","parentName"]),l=p(t),h=a,d=l["".concat(o,".").concat(h)]||l[h]||m[h]||i;return t?r.a.createElement(d,c(c({ref:n},b),{},{components:t})):r.a.createElement(d,c({ref:n},b))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=h;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var b=2;b<i;b++)o[b]=t[b];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},78:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var a=t(2),r=t(6),i=(t(0),t(100)),o={title:"Either",description:"Either Crock",layout:"guide",functions:["firsttoeither","lasttoeither","maybetoeither","resulttoeither"],weight:40},c={unversionedId:"crocks/Either",id:"crocks/Either",isDocsHomePage:!1,title:"Either",description:"Either Crock",source:"@site/docs/crocks/Either.md",slug:"/crocks/Either",permalink:"/crocks/docs/crocks/Either",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Either.md",version:"current",sidebar:"sidebar",previous:{title:"Const",permalink:"/crocks/docs/crocks/Const"},next:{title:"Equiv",permalink:"/crocks/docs/crocks/Equiv"}},s=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"Left",id:"left",children:[]},{value:"Right",id:"right",children:[]},{value:"of",id:"of",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"equals",id:"equals",children:[]},{value:"concat",id:"concat",children:[]},{value:"map",id:"map",children:[]},{value:"alt",id:"alt",children:[]},{value:"bimap",id:"bimap",children:[]},{value:"ap",id:"ap",children:[]},{value:"sequence",id:"sequence",children:[]},{value:"traverse",id:"traverse",children:[]},{value:"chain",id:"chain",children:[]},{value:"coalesce",id:"coalesce",children:[]},{value:"bichain",id:"bichain",children:[]},{value:"swap",id:"swap",children:[]},{value:"either",id:"either",children:[]}]},{value:"Transformation Functions",id:"transformation-functions",children:[{value:"firstToEither",id:"firsttoeither",children:[]},{value:"lastToEither",id:"lasttoeither",children:[]},{value:"maybeToEither",id:"maybetoeither",children:[]},{value:"resultToEither",id:"resulttoeither",children:[]}]}],b={rightToc:s};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},b,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a = Left c | Right a\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Either")," is the canonical ",Object(i.b)("inlineCode",{parentName:"p"},"Sum")," type and is the base of all other ",Object(i.b)("inlineCode",{parentName:"p"},"Sum")," types\nincluded in ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),", such as ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Async"}),Object(i.b)("inlineCode",{parentName:"a"},"Async"))," to name a\nfew. Defined as a tagged union type, it captures the essence of disjunction as\nit provides either a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," value or a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," value and not both."),Object(i.b)("p",null,"Unlike ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe")),', which fixes its "left side", or ',Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#nothing"}),Object(i.b)("inlineCode",{parentName:"a"},"Nothing"))," to\na ",Object(i.b)("inlineCode",{parentName:"p"},"()")," (unit), ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," is a functor in both it's ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," sides. This\nallows for the ability to vary the type on either side and is akin to the\nimperative ",Object(i.b)("inlineCode",{parentName:"p"},"if...else")," trees that are common in programming."),Object(i.b)("p",null,"Like most other types in ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," has a right bias in regard to\ninstance methods like ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#map"}),Object(i.b)("inlineCode",{parentName:"a"},"map")),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#ap"}),Object(i.b)("inlineCode",{parentName:"a"},"ap"))," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#chain"}),Object(i.b)("inlineCode",{parentName:"a"},"chain")),". This behavior can be used to\nformally capture Error handling as the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," value will be maintained\nthroughout subsequent flows."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport compose from 'crocks/helpers/compose'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\n\nconst { Left, Right } = Either\n\n// err :: a -> String\nconst err = val =>\n  `${typeof val} is not an accepted type`\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// validate :: a -> Either String Number\nconst validate = ifElse(\n  isNumber,\n  Right,\n  compose(Left, err)\n)\n\n// flow :: a -> Either String Number\nconst flow = compose(\n  map(add(10)),\n  validate\n)\n\nflow(32)\n//=> Right 42\n\nflow('32')\n//=> Left \"string is not an accepted type\"\n\nflow(true)\n//=> Left \"boolean is not an accepted type\"\n")),Object(i.b)("h2",{id:"implements"},"Implements"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Setoid"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Functor"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Alt"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Traversable"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Chain"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Applicative"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Monad")),Object(i.b)("h2",{id:"construction"},"Construction"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either :: a -> Either c a\n")),Object(i.b)("p",null,"An ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," is typically constructed by using one of the instance constructors\nprovided on the ",Object(i.b)("inlineCode",{parentName:"p"},"TypeRep"),": ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right")),". For consistency,\nan ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," can be constructed using its ",Object(i.b)("inlineCode",{parentName:"p"},"TypeRep")," as a constructor. The\nconstructor is a unary function that accepts any type ",Object(i.b)("inlineCode",{parentName:"p"},"a")," and will return a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance, wrapping the value it was passed."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\nimport equals from 'crocks/pointfree/equals'\n\nEither(90)\n//=> Right 90\n\nEither.of(90)\n//=> Right 90\n\nEither.Right(90)\n//=> Right 90\n\nequals(\n  Either.Right([ 1, 2, 3 ]),\n  Either.of([ 1, 2, 3 ])\n)\n//=> true\n\nequals(\n  Either.of({ a: 100 }),\n  Either({ a: 100 })\n)\n//=> true\n")),Object(i.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(i.b)("h3",{id:"left"},"Left"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either.Left :: c -> Either c a\n")),Object(i.b)("p",null,"Used to construct a ",Object(i.b)("inlineCode",{parentName:"p"},"Left")," instance of an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," that represents\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"false")," portion of a disjunction. The ",Object(i.b)("inlineCode",{parentName:"p"},"Left")," constructor takes a value of any\ntype and returns a ",Object(i.b)("inlineCode",{parentName:"p"},"Left")," instance wrapping the value passed to the constructor."),Object(i.b)("p",null,"When an instance is a ",Object(i.b)("inlineCode",{parentName:"p"},"Left"),", most ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," returning methods on\nthe instance will do nothing to the wrapped value and return another ",Object(i.b)("inlineCode",{parentName:"p"},"Left")," with\nthe same initial value the ",Object(i.b)("inlineCode",{parentName:"p"},"Left")," instance was constructed with."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport chain from 'crocks/pointfree/chain'\nimport compose from 'crocks/helpers/compose'\nimport isString from 'crocks/predicates/isString'\nimport ifElse from 'crocks/logic/ifElse'\n\nconst { Left, Right } = Either\n\n// yell :: String -> String\nconst yell =\n  x => `${x.toUpperCase()}!`\n\n// safeYell :: a -> Either a String\nconst safeYell =  ifElse(\n  isString,\n  compose(Right, yell),\n  Left\n)\n\nRight('excite')\n  .map(yell)\n//=> Right \"EXCITE!\"\n\nLeft('whisper')\n  .map(yell)\n//=> Left \"whisper\"\n\nchain(safeYell, Right('outside voice'))\n//=> Right \"OUTSIDE VOICE!\"\n\nchain(safeYell, Left({ level: 'inside voice' }))\n//=> Left { level: 'inside voice' }\n")),Object(i.b)("h3",{id:"right"},"Right"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either.Right :: a -> Either c a\n")),Object(i.b)("p",null,"Used to construct a ",Object(i.b)("inlineCode",{parentName:"p"},"Right")," instance of the an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," that represents\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"true")," portion of a disjunction. The ",Object(i.b)("inlineCode",{parentName:"p"},"Right")," constructor takes any value and\nwill return a new ",Object(i.b)("inlineCode",{parentName:"p"},"Right")," instance wrapping the value provided."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport compose from 'crocks/helpers/compose'\nimport composeK from 'crocks/helpers/composeK'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\n\nconst { Left, Right } = Either\n\n// validate :: (b -> Boolean) -> Either c a\nconst validate = pred =>\n  ifElse(pred, Right, Left)\n\n// add10 :: Number -> Number\nconst add10 =\n  x => x + 10\n\nRight(10)\n  .map(add10)\n//=> Right 20\n\nLeft('Not A Number')\n  .map(add10)\n//=> Left \"Not A Number\"\n\n// validNumber :: b -> Either c Number\nconst validNumber =\n  validate(isNumber)\n\nvalidNumber('60')\n//=> Left \"60\"\n\nvalidNumber(null)\n//=> Left null\n\nvalidNumber(60)\n//=> Right 60\n\n// safeAdd10 :: b -> Either c Number\nconst safeAdd10 = composeK(\n  compose(Right, add10),\n  validNumber\n)\n\nsafeAdd10([ 7 ])\n//=> Left [ 7 ]\n\nsafeAdd10(null)\n//=> Left null\n\nsafeAdd10(5)\n//=> Right 15\n\n// isLarge :: Number -> Either Number Number\nconst isLarge =\n  validate(x => x >= 10)\n\n// isLargeNumber :: b -> Either c Number\nconst isLargeNumber =\n  composeK(isLarge, validNumber)\n\n// add10ToLarge :: b -> Either c Number\nconst add10ToLarge =\n  composeK(safeAdd10, isLargeNumber)\n\nadd10ToLarge()\n//=> Left undefined\n\nadd10ToLarge('40')\n//=> Left \"40\"\n\nadd10ToLarge(5)\n//=> Left 5\n\nadd10ToLarge(10)\n//=> Right 20\n")),Object(i.b)("h3",{id:"of"},"of"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either.of :: a -> Either c a\n")),Object(i.b)("p",null,"Used to lift any value into an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," as a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right")),", ",Object(i.b)("inlineCode",{parentName:"p"},"of"),' is used mostly by\nhelper functions that work "generically" with instances of\neither ',Object(i.b)("inlineCode",{parentName:"p"},"Applicative")," or ",Object(i.b)("inlineCode",{parentName:"p"},"Monad"),". When working specifically with\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," type, the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," constructor should be used. Reach\nfor ",Object(i.b)("inlineCode",{parentName:"p"},"of")," when working with functions that will work with\nANY ",Object(i.b)("inlineCode",{parentName:"p"},"Applicative"),"/",Object(i.b)("inlineCode",{parentName:"p"},"Monad"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nconst { Right } = Either\n\nEither.of('some string')\n//=> Right \"some string\"\n\nEither.of(undefined)\n//=> Right undefined\n\nEither('some string')\n//=> Right \"some string\"\n\nEither(undefined)\n//=> Right undefined\n\nRight('some string')\n//=> Right \"some string\"\n\nRight(undefined)\n//=> Right undefined\n")),Object(i.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(i.b)("h3",{id:"equals"},"equals"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> b -> Boolean\n")),Object(i.b)("p",null,"Used to compare the underlying values of two ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instances for equality by\nvalue, ",Object(i.b)("inlineCode",{parentName:"p"},"equals")," takes any given argument and returns ",Object(i.b)("inlineCode",{parentName:"p"},"true")," if the passed\narguments is a ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," of the same instance with an underlying value equal to\nthe underlying value of the ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," the method is being called on. If the\npassed argument is not an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," of the same instance or the underlying values\nare not equal, ",Object(i.b)("inlineCode",{parentName:"p"},"equals")," will return ",Object(i.b)("inlineCode",{parentName:"p"},"false"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\nimport equals from 'crocks/pointfree/equals'\n\nconst { Left, Right } = Either\n\nRight(null)\n  .equals(Right(null))\n//=> true\n\nLeft('happy')\n  .equals(Left('happy'))\n//=> true\n\nLeft('sad')\n  .equals(Right('sad'))\n//=> false\n\n// by value, not reference for most types\nRight([ 1, { a: 2 }, 'string' ])\n  .equals(Right([ 1, { a: 2 }, 'string' ]))\n//=> true\n\nequals(Right('sad'), 'sad')\n//=> false\n")),Object(i.b)("h3",{id:"concat"},"concat"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Semigroup s => Either c s ~> Either c s -> Either c s\n")),Object(i.b)("p",null,"When an underlying ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," value of a given ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," is fixed to\na ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," can be used to concatenate  another ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance\nwith an underlying ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup")," of the same type. Expecting an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," wrapping\na ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup")," of the same type, ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," will give back a new ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance\nwrapping the result of combining the two underlying ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),"s. When called on\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instance, ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," will return a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," containing the initial value."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"\nimport Either from 'crocks/Either'\n\nimport Assign from 'crocks/Assign'\nimport compose from 'crocks/helpers/compose'\nimport concat from 'crocks/pointfree/concat'\nimport flip from 'crocks/combinators/flip'\nimport ifElse from 'crocks/logic/ifElse'\nimport isObject from 'crocks/predicates/isObject'\nimport mapReduce from 'crocks/helpers/mapReduce'\n\nconst { Left, Right } = Either\n\nRight([ 1, 2 ])\n  .concat(Right([ 4, 5 ]))\n//=> Right [ 1, 2, 3, 4 ]\n\nRight([ 1, 2 ])\n  .concat(Left('Error'))\n//=> Left \"Error\"\n\n// lift :: Object -> Either c Assign\nconst lift =\n  compose(Right, Assign)\n\n// liftObject :: b -> Either c Assign\nconst liftObject =\n  ifElse(isObject, lift, Left)\n\n// Foldable f => fold :: f * -> Either * Assign\nconst fold = mapReduce(\n  liftObject,\n  flip(concat),\n  Either(Assign.empty())\n)\n\nfold([ { a: 'a' }, { b: 'b' } ])\n//=> Right Assign { a: \"a\", b: \"b\" }\n\nfold([\n  { a: 'a' }, null, { c: 'c' }\n])\n//=> Left null\n")),Object(i.b)("h3",{id:"map"},"map"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> (a -> b) -> Either c b\n")),Object(i.b)("p",null,"Used to apply transformations to values ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instances of ",Object(i.b)("inlineCode",{parentName:"p"},"Either"),", ",Object(i.b)("inlineCode",{parentName:"p"},"map")," takes\na function that it will lift into the context of the ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," and apply to\nit the wrapped value. When ran on a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance, ",Object(i.b)("inlineCode",{parentName:"p"},"map")," will apply the\nwrapped value to the provided function and return the result in a\nnew ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport compose from 'crocks/helpers/compose'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\nimport objOf from 'crocks/helpers/objOf'\n\nconst { Left, Right } = Either\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\nRight(25)\n  .map(add(10))\n//=> Right 35\n\nLeft('Some String')\n  .map(add(10))\n//=> Left \"Some String\"\n\n// numberOr :: a -> Either b Number\nconst numberOr = ifElse(\n  isNumber, Right, Left\n)\n\n// add10 -> a -> Either b Number\nconst add10 = compose(\n  map(add(10)),\n  numberOr\n)\n\nadd10(45)\n//=> Right 55\n\nadd10('some string')\n//=> Left \"some string\"\n\nconst processResult = compose(\n  map(compose(objOf('result'), add(20))),\n  numberOr\n)\n\nprocessResult({ a: 57 })\n//=> Left { a: 57 }\n\nprocessResult(57)\n//=> Right{ result: 77 }\n")),Object(i.b)("h3",{id:"alt"},"alt"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> Either c a -> Either c a\n")),Object(i.b)("p",null,"Providing a means for a fallback or alternative value, ",Object(i.b)("inlineCode",{parentName:"p"},"alt")," combines\ntwo ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instances and will return the first ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," it\nencounters or the last ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," if it does not encounter\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right")),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nconst { Left, Right } = Either\n\nRight(45)\n  .alt(Right(97))\n  .alt(Left(false))\n//=> Right 45\n\nLeft('String')\n  .alt(Left('Another String'))\n  .alt(Left('Final String'))\n//=> Left \"Final String\"\n\nLeft('error')\n  .alt(Right({ passed: true }))\n//=> Right { passed: true }\n")),Object(i.b)("h3",{id:"bimap"},"bimap"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> ((c -> d), (a -> b)) -> Either d b\n")),Object(i.b)("p",null,"The types and values that make up an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," can vary independently in both\nthe ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instances of the ",Object(i.b)("inlineCode",{parentName:"p"},"Either"),". While ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#map"}),Object(i.b)("inlineCode",{parentName:"a"},"map"))," can be\nused to apply a transformation to a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance, ",Object(i.b)("inlineCode",{parentName:"p"},"bimap")," allows\ntransformations for either."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"bimap")," takes two mapping functions as its arguments. The first function is used\nto map a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instance, while the second maps a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right")),". ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," only\nprovides a means to map a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance exclusively using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#map"}),Object(i.b)("inlineCode",{parentName:"a"},"map")),". If\nthe need arises to map a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instance exclusively, then ",Object(i.b)("inlineCode",{parentName:"p"},"bimap")," can be used,\npassing the mapping function to the first argument and\nan ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(i.b)("inlineCode",{parentName:"a"},"identity"))," to the second."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport bimap from 'crocks/pointfree/bimap'\nimport compose from 'crocks/helpers/compose'\nimport ifElse from 'crocks/logic/ifElse'\nimport objOf from 'crocks/helpers/objOf'\n\nconst { Left, Right } = Either\n\n// lte :: Number -> Number -> Boolean\nconst lte =\n  x => y => y <= x\n\n// gt10 :: Number -> Either Number Number\nconst gt10 =\n  ifElse(lte(10), Left, Right)\n\n// offsetBy :: Number -> Number -> Number\nconst offsetBy =\n  x => y => x + y\n\n// scaleBy :: Number -> Number -> Number\nconst scaleBy =\n  x => y => x * y\n\n// compute :: Number -> Either Number Number\nconst compute = compose(\n  bimap(scaleBy(10), offsetBy(10)),\n  gt10\n)\n\ncompute(10)\n//=> Left 100\n\ncompute(20)\n//=> Right 30\n\n// arrayOf :: a -> [ a ]\nconst arrayOf =\n  x => [ x ]\n\n// resultOf :: a -> { result: a }\nconst resultOf =\n  objOf('result')\n\n// format :: Either c a -> Either [ c ] { result: a }\nconst format =\n  bimap(arrayOf, resultOf)\n\nformat(Left(100))\n//=> Left [ 100 ]\n\nformat(Right(30))\n//=> Right { result: 30 }\n\n// processAndFormat :: Either Number Number -> Either [ Number ] { result: Number }\nconst processAndFormat = bimap(\n  compose(arrayOf, scaleBy(10)),\n  compose(resultOf, offsetBy(10))\n)\n\n// flow :: Number -> Either [ Number ]\nconst flow = compose(\n  processAndFormat,\n  gt10\n)\n\nflow(10)\n//=> Left [ 100 ]\n\nflow(20)\n//=> Right { result: 30 }\n")),Object(i.b)("h3",{id:"ap"},"ap"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c (a -> b) ~> Either c a -> Either c b\n")),Object(i.b)("p",null,"Short for apply, ",Object(i.b)("inlineCode",{parentName:"p"},"ap")," is used to apply an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance containing a value\nto another ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance that contains a function, resulting in\nnew ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance containing the result of the application. ",Object(i.b)("inlineCode",{parentName:"p"},"ap")," requires\nthat it is called on either a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," containing anything or a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," that\nwraps a curried polyadic function."),Object(i.b)("p",null,"When either instance is a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left")),", ",Object(i.b)("inlineCode",{parentName:"p"},"ap")," will return a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," containing the\noriginal value. This can be used to safely combine multiple values under a\ngiven combination function. If any of the inputs results in a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," than they\nwill never be applied to the function and not provide exceptions or undesired\nresults."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport assign from 'crocks/helpers/assign'\nimport setProp from 'crocks/helpers/setProp'\nimport compose from 'crocks/helpers/compose'\nimport identity from 'crocks/combinators/identity'\nimport ifElse from 'crocks/logic/ifElse'\nimport isObject from 'crocks/predicates/isObject'\nimport objOf from 'crocks/helpers/objOf'\n\nconst { Left, Right } = Either\n\n// objectOr :: a -> Either c Object\nconst objectOr =\n  ifElse(isObject, Right, Left)\n\n// Error :: { error: a, passed: Boolean }\n// error :: a -> Error\nconst error = compose(\n  setProp('passed', false),\n  objOf('error')\n)\n\n// setPassed :: Either c Object -> Either Error Object\nconst setPassed = m =>\n  Either.of(setProp('passed', true))\n    .ap(m)\n    .bimap(error, identity)\n\nsetPassed(Right({ a: 'awesome' }))\n//=> Right { a: \"awesome\", passed: true }\n\nsetPassed(Left({ a: 'not so much' }))\n//=> Left { error: { a: \"not so much\" }, passed: false }\n\n// process :: a -> Either Object Object\nconst process =\n  compose(setPassed, objectOr)\n\nprocess({ a: 'awesome' })\n//=> Right { a: \"awesome\", passed: true }\n\nprocess('I am string')\n//=> Left { error: \"I am string\", passed: false }\n\n// assignOr :: (Either c Object, Either c Object) -> Either c Object\nconst assignOr = (x, y) =>\n  x.map(assign).ap(y)\n\nassignOr(Right({ b: 'also awesome' }), Right({ a: 'awesome' }))\n//=> Right { a: \"awesome\", b: \"also awesome\" }\n\nassignOr(Right({ b: 'also awesome' }), Left('not so awesome'))\n//=> Left \"not so awesome\"\n\nassignOr(Left({ b: 'first' }), Left({ b: 'second' }))\n//=> Left { b: \"first\" }\n")),Object(i.b)("h3",{id:"sequence"},"sequence"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Apply f => Either c (f a) ~> (b -> f b) -> f (Either c a)\nApplicative f => Either c (f a) ~> TypeRep f -> f (Either c a)\n")),Object(i.b)("p",null,"When an instance of ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," wraps an ",Object(i.b)("inlineCode",{parentName:"p"},"Apply")," instance, ",Object(i.b)("inlineCode",{parentName:"p"},"sequence")," can be used\nto swap the type sequence. ",Object(i.b)("inlineCode",{parentName:"p"},"sequence")," requires either\nan ",Object(i.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or an ",Object(i.b)("inlineCode",{parentName:"p"},"Apply")," returning function is provided for its\nargument. This will be used in the case that the ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance is a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left")),"."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"sequence")," can be derived from ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#traverse"}),Object(i.b)("inlineCode",{parentName:"a"},"traverse"))," by passing it\nan ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(i.b)("inlineCode",{parentName:"a"},"identity"))," function."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport Identity from 'crocks/Identity'\n\nconst { Left, Right } = Either\n\n// arrayOf :: a -> [ a ]\nconst arrayOf =\n  x => [ x ]\n\nRight([ 1, 2, 3 ])\n  .sequence(arrayOf)\n//=> [ Right 1, Right 2, Right 3 ]\n\nLeft('no array here')\n  .sequence(arrayOf)\n//=> [ Left \"no array here\" ]\n\nRight(Identity.of(42))\n  .sequence(Identity)\n//=> Identity (Right 42)\n\nLeft(0)\n  .sequence(Identity)\n//=> Identity (Left 0)\n")),Object(i.b)("h3",{id:"traverse"},"traverse"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Apply f => Either c a ~> (d -> f d), (a -> f b)) -> f Either c b\nApplicative f => Either c a ~> (TypeRep f, (a -> f b)) -> f Either c b\n")),Object(i.b)("p",null,'Used to apply the "effect" of an ',Object(i.b)("inlineCode",{parentName:"p"},"Apply")," to a value inside of an ",Object(i.b)("inlineCode",{parentName:"p"},"Either"),",\n",Object(i.b)("inlineCode",{parentName:"p"},"traverse"),' combines both the "effects" of the ',Object(i.b)("inlineCode",{parentName:"p"},"Apply")," and the ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," by\nreturning a new instance of the ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),", wrapping the result of\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),'s "effect" on the value in the supplied ',Object(i.b)("inlineCode",{parentName:"p"},"Either"),"."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"traverse")," requires either an ",Object(i.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or an ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),' returning\nfunction as its first argument and a function that is used to apply the "effect"\nof the target ',Object(i.b)("inlineCode",{parentName:"p"},"Apply")," to the value inside of the ",Object(i.b)("inlineCode",{parentName:"p"},"Either"),". This will be used in\nthe case that the ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance is a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left")),". Both arguments must provide\nan instance of the target ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport Pair from 'crocks/Pair'\nimport State from 'crocks/State'\nimport Sum from 'crocks/Sum'\nimport constant from 'crocks/combinators/constant'\nimport ifElse from 'crocks/logic/ifElse'\nimport traverse from 'crocks/pointfree/traverse'\n\nconst { Left, Right } = Either\nconst { get } = State\n\n// tallyOf :: Number -> Pair Sum Number\nconst tallyOf =\n  x => Pair(Sum.empty(), x)\n\n// incBy :: Number -> Pair Sum Number\nconst incBy =\n  x => Pair(Sum(x), x)\n\nRight(12)\n  .traverse(tallyOf, incBy)\n//=> Pair( Sum 12, Right 12 )\n\nLeft(true)\n  .traverse(tallyOf, incBy)\n//=> Pair( Sum 0, Left true )\n\n// lte10 :: Number -> Either Number Number\nconst lte10 =\n  ifElse(x => x <= 10, Right, Left)\n\n// update :: Number -> State Number Number\nconst update = x =>\n  State.modify(state => x + state)\n    .chain(constant(get()))\n\n// updateSmall :: () => State Number Number\nconst updateSmall = () =>\n  get(lte10)\n    .chain(traverse(State, update))\n\nupdateSmall()\n  .runWith(3)\n//=> Pair( Right 6, 6 )\n\nupdateSmall()\n  .chain(updateSmall)\n  .runWith(3)\n//=> Pair( Left 12, 12 )\n\nupdateSmall()\n  .chain(updateSmall)\n  .chain(updateSmall)\n  .runWith(3)\n//=> Pair( Left 12, 12 )\n\nupdateSmall()\n  .chain(updateSmall)\n  .chain(updateSmall)\n  .runWith(30)\n//=> Pair( Left 30, 30 )\n")),Object(i.b)("h3",{id:"chain"},"chain"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> (a -> Either c b) -> Either c b\n")),Object(i.b)("p",null,"Combining a sequential series of transformations that capture disjunction can be\naccomplished with ",Object(i.b)("inlineCode",{parentName:"p"},"chain"),". ",Object(i.b)("inlineCode",{parentName:"p"},"chain")," expects a unary, ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," returning function\nas its argument. When invoked on a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left")),", ",Object(i.b)("inlineCode",{parentName:"p"},"chain")," will not run the function,\nbut will instead return another ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," wrapping the original value. When called\non a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," however, the inner value will be passed to the provided function,\nreturning the result as the new instance."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport getProp from 'crocks/Maybe/getProp'\nimport ifElse from 'crocks/logic/ifElse'\nimport isString from 'crocks/predicates/isString'\nimport maybeToEither from 'crocks/Either/maybeToEither'\nimport propEq from 'crocks/predicates/propEq'\n\nconst { Left, Right } = Either\n\n// lift :: (b -> Boolean) -> b -> Either c a\nconst lift = pred =>\n  ifElse(pred, Right, Left)\n\n// isPassed :: b -> Either c Object\nconst isPassed =\n  lift(propEq('passed', true))\n\nisPassed({ value: 'Nope' })\n// Left { value: \"Nope\" }\n\nisPassed({ value: 'yes', passed: true })\n// Right { value: \"yes\", passed: true }\n\n// stringOr :: b -> Either c String\nconst stringOr =\n  lift(isString)\n\n// valueOr :: b -> Either c a\nconst valueOr = x =>\n  maybeToEither(x, getProp('value'), x)\n\n// getStringValue :: b -> Either c String\nconst getStringValue = x =>\n  isPassed(x)\n    .chain(valueOr)\n    .chain(stringOr)\n\ngetStringValue({\n  value: 'So good',\n  passed: true\n})\n//=> Right \"So Good\"\n\ngetStringValue({\n  value: 'Not passed'\n})\n//=> Left { value: \"Not passed\" }\n\ngetStringValue({\n  value: 33,\n  passed: true\n})\n//=> Right \"So Good\"\n\ngetStringValue({\n  value: 33,\n  passed: true\n})\n//=> Left 33\n")),Object(i.b)("h3",{id:"coalesce"},"coalesce"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> ((c -> b), (a -> b)) -> Either c b\n")),Object(i.b)("p",null,"Used to take a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left")),' instance and not only map its internal value,\nbut also to "promote" it to a ',Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance. ",Object(i.b)("inlineCode",{parentName:"p"},"coalesce")," takes two\nunary functions as its arguments and will return a new ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance."),Object(i.b)("p",null,"The first function is used when invoked on a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," and will return\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance, wrapping the result of the function. The second\nfunction is used when ",Object(i.b)("inlineCode",{parentName:"p"},"coalesce")," is invoked on a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," and is used\nto map the original value, returning a new ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance wrapping\nthe result of the second function."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport setProp from 'crocks/helpers/setProp'\nimport coalesce from 'crocks/pointfree/coalesce'\nimport compose from 'crocks/helpers/compose'\nimport identity from 'crocks/combinators/identity'\nimport hasProp from 'crocks/predicates/hasProp'\nimport ifElse from 'crocks/logic/ifElse'\nimport map from 'crocks/pointfree/map'\nimport mapProps from 'crocks/helpers/mapProps'\n\nconst { Left, Right } = Either\n\n// inc :: Number -> Number -> Number\nconst inc =\n  x => x + 1\n\nRight(45)\n  .coalesce(identity, inc)\n//=> Right 46\n\nLeft(45)\n  .coalesce(identity, inc)\n//=> Right 45\n\n// Record :: { value: Number }\n// hasValue :: Object -> Either Object Record\nconst hasValue =\n  ifElse(hasProp('value'), Right, Left)\n\nhasValue({ a: 45 })\n// Left { a: 45 }\n\nhasValue({ value: 45 })\n// Right { value: 45 }\n\n// defaultValue :: Either Object Record -> Either Object Record\nconst defaultValue =\n  coalesce(setProp('value', 0), identity)\n\n// incValue :: Either Object Record -> Either c Record\nconst incValue = compose(\n  map(mapProps({ value: inc })),\n  defaultValue,\n  hasValue\n)\n\nincValue({ value: 45 })\n\n//=> Right { value: 46 }\n\nincValue({ a: 44 })\n//=> Right { a: 44, value: 1 }\n")),Object(i.b)("h3",{id:"bichain"},"bichain"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> ((c -> Either d b), (a -> Either d b)) -> Either d b\n")),Object(i.b)("p",null,"Combining a sequential series of transformations that capture disjunction can be\naccomplished with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#chain"}),Object(i.b)("inlineCode",{parentName:"a"},"chain")),". Along the same lines, ",Object(i.b)("inlineCode",{parentName:"p"},"bichain")," allows you\nto do this from both ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right")),". ",Object(i.b)("inlineCode",{parentName:"p"},"bichain")," expects\ntwo unary, ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," returning functions as its arguments. When invoked on\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instance, ",Object(i.b)("inlineCode",{parentName:"p"},"bichain")," will use\nthe left, or first, function that can return either a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," or\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance. When called on a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance, it\nwill behave exactly as ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#chain"}),Object(i.b)("inlineCode",{parentName:"a"},"chain"))," would with the right, or\nsecond, function."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport bichain from 'crocks/pointfree/bichain'\nimport compose from 'crocks/helpers/compose'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport isString from 'crocks/predicates/isString'\nimport map from 'crocks/pointfree/map'\n\nconst { Left, Right } = Either\n\n// swapEither :: Either a b -> Either b a\nconst swapEither =\n  bichain(Right, Left)\n\nswapEither(Left('left'))\n//=> Right \"left\"\n\nswapEither(Right('right'))\n//=> Left \"right\"\n\n// length :: String -> Number\nconst length = x =>\n  x.length\n\n// add10 :: Number -> Number\nconst add10 = x =>\n  x + 10\n\n// safe :: (a -> Boolean) -> a -> Either c b\nconst safe = pred =>\n  ifElse(pred, Right, Left)\n\n// stringLength :: a -> Either e Number\nconst stringLength = compose(\n  map(length),\n  safe(isString)\n)\n\n// nested :: a -> Either c Number\nconst nested = compose(\n  map(add10),\n  bichain(stringLength, Right),\n  safe(isNumber)\n)\n\nnested('cool')\n//=> Right 14\n\nnested(true)\n//=> Left true\n\nnested(13)\n//=> Right 23\n")),Object(i.b)("h3",{id:"swap"},"swap"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> ((c -> d), (a -> b)) -> Either b d\n")),Object(i.b)("p",null,"Used to map the value of an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance and transform a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," into a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," or a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," into a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left")),", ",Object(i.b)("inlineCode",{parentName:"p"},"swap")," takes two functions as its arguments.\nThe first function is used to map and transform a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," into a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right")),",\nwhile the second maps and transforms a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," into a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left")),". If no mapping of\nthe contained values is required for either instance,\nthen ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(i.b)("inlineCode",{parentName:"a"},"identity"))," functions can be used in one or both arguments."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport identity from 'crocks/combinators/identity'\nimport swap from 'crocks/pointfree/swap'\n\nconst { Left, Right } = Either\n\n// swapTypes :: Either c a -> Either a c\nconst swapTypes =\n  swap(identity, identity)\n\nswapTypes(Left(45))\n//=> Right 45\n\nswapTypes(Right(23))\n//=> Left 23\n\n// toString :: Number -> String\nconst toString =\n  x => x.toString()\n\n// toNumber :: String -> Number\nconst toNumber =\n  x => parseInt(x)\n\n// swapValues :: Either Number String -> Either Number String\nconst swapValues =\n  swap(toString, toNumber)\n\nswapValues(Left(23))\n//=> Right \"23\"\n\nswapValues(Right('23'))\n//=> Left 23\n")),Object(i.b)("h3",{id:"either"},"either"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Either c a ~> ((c -> b), (a -> b)) -> b\n")),Object(i.b)("p",null,"Used as a means to map and extract a value from an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," based on the\ncontext, ",Object(i.b)("inlineCode",{parentName:"p"},"either")," takes two functions as its arguments. The first will map any\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," value in a left instance. While the second is used to map any ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right")),"\ninstance value. The function will return the result of whichever function is\nused to map."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport curry from 'crocks/helpers/curry'\nimport either from 'crocks/pointfree/either'\nimport identity from 'crocks/combinators/identity'\nimport objOf from 'crocks/helpers/objOf'\n\nconst { Left, Right } = Either\n\n// toObject :: String -> Either a Object -> Object\nconst toObject = curry(\n  key => either(objOf(key), identity)\n)\n\ntoObject('num', Left(44))\n//=> { num: 44 }\n\ntoObject('num', Right({ string: 'a string' }))\n//=> { string: 'a string' }\n")),Object(i.b)("h2",{id:"transformation-functions"},"Transformation Functions"),Object(i.b)("h3",{id:"firsttoeither"},"firstToEither"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Either/firstToEither")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"firstToEither :: c -> First a -> Either c a\nfirstToEither :: c -> (a -> First b) -> a -> Either c a\n")),Object(i.b)("p",null,"Used to transform a given ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(i.b)("inlineCode",{parentName:"a"},"First"))," instance to an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance or\nflatten an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(i.b)("inlineCode",{parentName:"a"},"First"))," into an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," when chained, ",Object(i.b)("inlineCode",{parentName:"p"},"firstToEither")," will\nturn a non-empty instance into a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," wrapping the original\nvalue contained within the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(i.b)("inlineCode",{parentName:"a"},"First")),"."),Object(i.b)("p",null,"The ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(i.b)("inlineCode",{parentName:"a"},"First"))," datatype is based on a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," and as such its\nis fixed to a ",Object(i.b)("inlineCode",{parentName:"p"},"()")," (unit) type. As a means to allow for convenient\ntransformation, ",Object(i.b)("inlineCode",{parentName:"p"},"firstToEither")," takes a default ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," value as the\nfirst argument. This value will be wrapped in a\nresulting ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instance in the case of empty."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"firstToEither")," has two possible\nsignatures and will behave differently when passed either\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(i.b)("inlineCode",{parentName:"a"},"First"))," instance or a function that returns an instance\nof ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(i.b)("inlineCode",{parentName:"a"},"First")),". When passed the instance, a transformed ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," is\nreturned. When passed a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(i.b)("inlineCode",{parentName:"a"},"First"))," returning function, a function will be\nreturned that takes a given value and returns a ",Object(i.b)("inlineCode",{parentName:"p"},"Either"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport First from 'crocks/First'\nimport and from 'crocks/logic/and'\nimport firstToEither from 'crocks/Either/firstToEither'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\nimport mconcatMap from 'crocks/helpers/mconcatMap'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Right } = Either\n\n// sorry :: First a -> Either String a\nconst sorry =\n  firstToEither('Sorry Charlie')\n\nsorry(First.empty())\n//=> Left \"Sorry Charlie\"\n\nsorry(First('So Good'))\n//=> Right \"So Good\"\n\n// gte :: Number -> Number -> Boolean\nconst gte =\n  y => x => x >= y\n\n// isValid :: a -> Boolean\nconst isValid =\n  and(isNumber, gte(30))\n\n// firstValid :: a -> First Number\nconst firstValid =\n  mconcatMap(First, safe(isValid))\n\n// data :: [ * ]\nconst data =\n  [ 1, '200', 60, 300 ]\n\nRight(data)\n  .chain(sorry(firstValid))\n//=> Right 60\n\nRight(data)\n  .map(map(x => x.toString()))\n  .chain(sorry(firstValid))\n//=> Left \"Sorry Charlie\"\n\nRight(First.empty())\n  .chain(firstToEither('Port'))\n//=> Left \"Port\"\n\nRight(First('Ship'))\n  .chain(firstToEither('Port'))\n//=> Right \"Ship\"\n")),Object(i.b)("h3",{id:"lasttoeither"},"lastToEither"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Either/lastToEither")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"lastToEither :: c -> Last a -> Either c a\nlastToEither :: c -> (a -> Last b) -> a -> Either c a\n")),Object(i.b)("p",null,"Used to transform a given ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(i.b)("inlineCode",{parentName:"a"},"Last"))," instance to an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," or flatten\nan ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(i.b)("inlineCode",{parentName:"a"},"Last"))," into an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," when chained, ",Object(i.b)("inlineCode",{parentName:"p"},"lastToEither")," will\nturn a non-empty ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(i.b)("inlineCode",{parentName:"a"},"Last"))," instance into a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance\nwrapping the original value contained in the original non-empty."),Object(i.b)("p",null,"The ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(i.b)("inlineCode",{parentName:"a"},"Last"))," datatype is based on a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," and as such its left\nor empty value is fixed to a ",Object(i.b)("inlineCode",{parentName:"p"},"()")," (unit) type. As a means to allow for\nconvenient transformation, ",Object(i.b)("inlineCode",{parentName:"p"},"lastToEither")," takes a default ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," value\nas the first argument. This value will be wrapped in a\nresulting ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instance, in the case of empty."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"lastToEither")," has two possible\nsignatures and will behave differently when passed either\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(i.b)("inlineCode",{parentName:"a"},"Last"))," instance or a function that returns an instance\nof ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(i.b)("inlineCode",{parentName:"a"},"Last")),". When passed the instance, a transformed ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," is returned.\nWhen passed a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(i.b)("inlineCode",{parentName:"a"},"Last"))," returning function, a function will be returned\nthat takes a given value and returns an ",Object(i.b)("inlineCode",{parentName:"p"},"Either"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport Last from 'crocks/Last'\nimport and from 'crocks/logic/and'\nimport compose from 'crocks/helpers/compose'\nimport concat from 'crocks/pointfree/concat'\nimport lastToEither from 'crocks/Either/lastToEither'\nimport isString from 'crocks/predicates/isString'\nimport map from 'crocks/pointfree/map'\nimport mconcatMap from 'crocks/helpers/mconcatMap'\nimport safe from 'crocks/Maybe/safe'\nimport when from 'crocks/logic/when'\n\nconst { Right } = Either\n\n// sorry :: Last a -> Either String a\nconst sorry =\n  lastToEither('Sorry Charlie')\n\nsorry(Last.empty())\n//=> Left \"Sorry Charlie\"\n\nsorry(Last('So Good'))\n//=> Right \"So Good\"\n\n// lte :: Number -> Number -> Boolean\nconst lte =\n  y => x => x <= y\n\n// length :: String -> Number\nconst length =\n  x => x.length\n\n// isValid :: a -> Boolean\nconst isValid =\n  and(isString, compose(lte(3), length))\n\n// lastValid :: a -> Last Number\nconst lastValid =\n  mconcatMap(Last, safe(isValid))\n\n// data :: [ * ]\nconst data =\n  [ 1, '200', 60, 300 ]\n\nRight(data)\n  .chain(sorry(lastValid))\n//=> Right \"200\"\n\nRight(data)\n  .map(map(when(isString, concat('!'))))\n  .chain(sorry(lastValid))\n//=> Left \"Sorry Charlie\"\n\nRight(Last.empty())\n  .chain(lastToEither('Port'))\n//=> Left \"Port\"\n\nRight(Last('Ship'))\n  .chain(lastToEither('Port'))\n//=> Right \"Ship\"\n")),Object(i.b)("h3",{id:"maybetoeither"},"maybeToEither"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Either/maybeToEither")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"maybeToEither :: c -> Maybe a -> Either c a\nmaybeToEither :: c -> (a -> Maybe b) -> a -> Either c a\n")),Object(i.b)("p",null,"Used to transform a given ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," instance to an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance or\nflatten an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," into an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," when chained, ",Object(i.b)("inlineCode",{parentName:"p"},"maybeToEither")," will\nturn a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#just"}),Object(i.b)("inlineCode",{parentName:"a"},"Just"))," instance into a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance wrapping\nthe original value contained in the original ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#just"}),Object(i.b)("inlineCode",{parentName:"a"},"Just")),"."),Object(i.b)("p",null,"A ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#nothing"}),Object(i.b)("inlineCode",{parentName:"a"},"Nothing"))," instance is fixed to a ",Object(i.b)("inlineCode",{parentName:"p"},"()")," type and as such can only\never contain a value of ",Object(i.b)("inlineCode",{parentName:"p"},"undefined"),". As a means to allow for convenient\ntransformation, ",Object(i.b)("inlineCode",{parentName:"p"},"maybeToEither")," takes a default ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," value\nas the first argument. This value will be wrapped in a\nresulting ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instance, in the case of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#nothing"}),Object(i.b)("inlineCode",{parentName:"a"},"Nothing")),"."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"maybeToEither")," has two possible\nsignatures and will behave differently when passed either\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," instance or a function that returns an instance\nof ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe")),". When passed the instance, a transformed ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," is\nreturned. When passed a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," returning function, a function will be\nreturned that takes a given value and returns an ",Object(i.b)("inlineCode",{parentName:"p"},"Either"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport Maybe from 'crocks/Maybe'\nimport compose from 'crocks/helpers/compose'\nimport fanout from 'crocks/Pair/fanout'\nimport identity from 'crocks/combinators/identity'\nimport isObject from 'crocks/predicates/isObject'\nimport maybeToEither from 'crocks/Either/maybeToEither'\nimport merge from 'crocks/pointfree/merge'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Nothing, Just } = Maybe\nconst { Right } = Either\n\nmaybeToEither(false, Nothing())\n//=> Left false\n\nmaybeToEither(false, Just(true))\n//=> Right true\n\n// isValid :: a -> Either b Object\nconst isValid = compose(\n  merge(maybeToEither),\n  fanout(identity, safe(isObject))\n)\n\nRight('I am String')\n  .chain(isValid)\n//=> Left \"I am String\"\n\nRight({ key: 'value' })\n  .chain(isValid)\n//=> Right { key: \"value\" }\n\nRight(Nothing())\n  .chain(maybeToEither('Left'))\n//=> Left \"Left\"\n\nRight(Just('42'))\n  .chain(maybeToEither('Left'))\n//=> Right \"42\"\n")),Object(i.b)("h3",{id:"resulttoeither"},"resultToEither"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Either/resultToEither")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"resultToEither :: Result e a -> Either e a\nresultToEither :: (a -> Result e b) -> a -> Either e a\n")),Object(i.b)("p",null,"Used to transform a given ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result"))," instance to an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," instance or flatten\nan ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result"))," into an ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," when chained, ",Object(i.b)("inlineCode",{parentName:"p"},"resultToEither")," will\nturn an ",Object(i.b)("inlineCode",{parentName:"p"},"Ok")," instance into a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance wrapping the value\ncontained in the original ",Object(i.b)("inlineCode",{parentName:"p"},"Ok"),". If an ",Object(i.b)("inlineCode",{parentName:"p"},"Err")," is provided, then ",Object(i.b)("inlineCode",{parentName:"p"},"resultToEither")," will\nreturn a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instance, wrapping the original ",Object(i.b)("inlineCode",{parentName:"p"},"Err")," value."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"resultToEither")," has two possible\nsignatures and will behave differently when passed either a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result"))," instance\nor a function that returns an instance of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result")),". When passed the instance,\na transformed ",Object(i.b)("inlineCode",{parentName:"p"},"Either")," is returned. When passed a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result"))," returning function,\na function will be returned that takes a given value and returns an ",Object(i.b)("inlineCode",{parentName:"p"},"Either"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Either from 'crocks/Either'\n\nimport Result from 'crocks/Result'\nimport assign from 'crocks/helpers/assign'\nimport compose from 'crocks/helpers/compose'\nimport composeK from 'crocks/helpers/composeK'\nimport fanout from 'crocks/Pair/fanout'\nimport getProp from 'crocks/Maybe/getProp'\nimport isNumber from 'crocks/predicates/isNumber'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport map from 'crocks/pointfree/map'\nimport maybeToResult from 'crocks/Result/maybeToResult'\nimport merge from 'crocks/pointfree/merge'\nimport objOf from 'crocks/helpers/objOf'\nimport resultToEither from 'crocks/Either/resultToEither'\nimport safeLift from 'crocks/Maybe/safeLift'\n\nconst { Right } = Either\nconst { Err, Ok } = Result\n\nresultToEither(Err('no good'))\n//=> Left \"no good\"\n\nresultToEither(Ok('so good'))\n//=> Right \"so good\"\n\n// safeInc :: a -> Maybe Number\nconst safeInc =\n  safeLift(isNumber, x => x + 1)\n\n// incProp :: String -> a -> Maybe Number\nconst incProp = key =>\n  composeK(safeInc, getProp(key))\n\n// incResult :: String -> a -> Result [ String ] Object\nconst incResult = key => maybeToResult(\n  [ `${key} is not valid` ],\n  compose(map(objOf(key)), incProp(key))\n)\n\n// incThem :: a -> Result [ String ] Object\nconst incThem = compose(\n  merge(liftA2(assign)),\n  fanout(incResult('b'), incResult('a'))\n)\n\nEither.of({})\n  .chain(resultToEither(incThem))\n//=> Left [ \"b is not valid\", \"a is not valid\" ]\n\nEither.of({ a: 33 })\n  .chain(resultToEither(incThem))\n//=> Left [ \"b is not valid\" ]\n\nEither.of({ a: 99, b: '41' })\n  .chain(resultToEither(incThem))\n//=> Left [ \"b is not valid\" ]\n\nEither.of({ a: 99, b: 41 })\n  .chain(resultToEither(incThem))\n//=> Right { a: 100, b: 42 }\n\nRight(Err('Left'))\n  .chain(resultToEither)\n//=> Left \"Left\"\n\nRight(Ok('42'))\n  .chain(resultToEither)\n//=> Right \"42\"\n")))}p.isMDXComponent=!0}}]);