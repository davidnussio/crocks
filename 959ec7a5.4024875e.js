(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{101:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return u}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=r.a.createContext({}),p=function(e){var n=r.a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},b=function(e){var n=p(e.components);return r.a.createElement(d.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),b=p(t),m=a,u=b["".concat(i,".").concat(m)]||b[m]||l[m]||o;return t?r.a.createElement(u,c(c({ref:n},d),{},{components:t})):r.a.createElement(u,c({ref:n},d))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var d=2;d<o;d++)i[d]=t[d];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},83:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var a=t(2),r=t(6),o=(t(0),t(101)),i={title:"ReaderT",description:"Reader Monad Transformer Crock",layout:"guide",weight:120},c={unversionedId:"crocks/ReaderT",id:"crocks/ReaderT",isDocsHomePage:!1,title:"ReaderT",description:"Reader Monad Transformer Crock",source:"@site/docs/crocks/ReaderT.md",slug:"/crocks/ReaderT",permalink:"/crocks/docs/crocks/ReaderT",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/ReaderT.md",version:"current",sidebar:"sidebar",previous:{title:"Reader",permalink:"/crocks/docs/crocks/Reader"},next:{title:"Result",permalink:"/crocks/docs/crocks/Result"}},s=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"ask",id:"ask",children:[]},{value:"lift",id:"lift",children:[]},{value:"liftFn",id:"liftfn",children:[]},{value:"of",id:"of",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"map",id:"map",children:[]},{value:"ap",id:"ap",children:[]},{value:"chain",id:"chain",children:[]},{value:"runWith",id:"runwith",children:[]}]}],d={rightToc:s};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Monad m => ReaderT e (m a)\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," is a ",Object(o.b)("inlineCode",{parentName:"p"},"Monad Transformer")," that wraps a given ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," with a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),".\nThis allows the interface of a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," that enables the  composition of\ncomputations that depend on a shared environment ",Object(o.b)("inlineCode",{parentName:"p"},"(e -> a)"),", but provides a way\nto abstract a means the ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," portion, when combining ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT"),"s of the same\ntype. All ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT"),"s must provide the constructor of the target ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," that is\nbeing wrapped."),Object(o.b)("h2",{id:"implements"},"Implements"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Functor"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Apply"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Chain"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")),Object(o.b)("h2",{id:"construction"},"Construction"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"ReaderT :: MonadTypeRep M, Monad m => M -> Reader(M) e (m a)\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," is a type constructor that defines a unary function that takes a\nconstructor, or TypeRep, of any ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," and returns a new constructor that\ncan be used to construct ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," instances that fix the far right portion\nof the ",Object(o.b)("inlineCode",{parentName:"p"},"Reader(M)")," to the provided ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),"."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," constructor can be thought of as a constructor that constructs\na constructor."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import ReaderT from 'crocks/Reader/ReaderT'\n\nimport Maybe from 'crocks/Maybe'\nimport Async from 'crocks/Async'\n\n// MaybeReader :: Reader(Maybe)\nconst MaybeReader =\n  ReaderT(Maybe)\n\n// AsyncReader :: Reader(Async)\nconst AsyncReader =\n  ReaderT(Async)\n\nMaybeReader.of('nice')\n  .runWith()\n//=> Just \"nice\"\n\n// AsyncReader e Boolean\nAsyncReader.of(true)\n  .runWith()\n//=> Resolved Boolean\n")),Object(o.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(o.b)("h3",{id:"ask"},"ask"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"ReaderT.ask :: Monad m => () -> ReaderT e (m e)\nReaderT.ask :: Monad m => (e -> a) -> ReaderT e (m a)\n")),Object(o.b)("p",null,"A construction helper that returns a ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," with environment on the right\nportion of the ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),". ",Object(o.b)("inlineCode",{parentName:"p"},"ask")," can take a function, that can be used to map the\nenvironment to a different type or value. When using the function version, the\nfunction must return the type of the ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," the ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," wraps, which in turn\nwill be wrapped in another"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import ReaderT from 'crocks/Reader/ReaderT'\nimport Maybe from 'crocks/Maybe'\n\nimport safe from 'crocks/Maybe/safe'\nimport isNumber from 'crocks/predicates/isNumber'\n\nconst MaybeReader = ReaderT(Maybe)\nconst { ask } = MaybeReader\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// Typical Constructor\nMaybeReader(safe(isNumber))\n  .runWith(76)\n//=> Just 76\n\nMaybeReader(safe(isNumber))\n  .runWith('76')\n//=> Nothing\n\n// Using `ask` with no function\n// (identity on environment)\nask()\n  .runWith(76)\n//=> Just 76\n\nask()\n  .runWith('76')\n//=> Just '76'\n\n// Using `ask` with a function\n// (map environment before deposit)\nask(add(10))\n  .runWith(76)\n//=> Just 86\n")),Object(o.b)("h3",{id:"lift"},"lift"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"ReaderT.lift :: Monad m => m a -> ReaderT e (m a)\n")),Object(o.b)("p",null,"Used to promote an instance of a given ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," into a ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," of that ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),"s\ntype. This can be used to lift a pointed instance of the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),".\nWhen mixed with composition, ",Object(o.b)("inlineCode",{parentName:"p"},"lift")," can be used to promote functions that take\nthe form of ",Object(o.b)("inlineCode",{parentName:"p"},"a -> m b")," into a function that can be ",Object(o.b)("inlineCode",{parentName:"p"},"chain"),"ed with the ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT"),".\nAlthough, ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#liftfn"}),Object(o.b)("inlineCode",{parentName:"a"},"liftFn"))," can be used to remove the composition boilerplate\nand promote and ",Object(o.b)("inlineCode",{parentName:"p"},"a -> m b")," function."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import ReaderT from 'crocks/Reader/ReaderT'\nimport Async from 'crocks/Async'\n\nimport compose from 'crocks/helpers/compose'\nimport curry from 'crocks/helpers/curry'\nimport flip from 'crocks/combinators/flip'\nimport runWith from 'crocks/pointfree/runWith'\nimport tap from 'crocks/helpers/tap'\n\nconst AsyncReader = ReaderT(Async)\n\nconst { ask, lift } = AsyncReader\nconst { Rejected } = Async\n\n// log :: String -> a -> ()\nconst log = label =>\n  console.log.bind(console, label + ':')\n\n// forkLog :: Async a b -> Async a b\nconst forkLog = tap(\n  m => m.fork(log('rej'), log('res'))\n)\n\n// runAndLog :: e -> ReaderT e (Async a b) -> Async a b\nconst runAndLog = curry(\n  x => compose(forkLog, flip(runWith, x))\n)\n\n// instance :: ReaderT e (Async String a)\nconst instance =\n  lift(Rejected('Always Rejected'))\n\nrunAndLog(instance, 'Thomas')\n//=> rej: Always Rejected\n\n// Using in a composition\n// rejectWith :: a -> ReaderT e (Async a b)\nconst rejectWith =\n  compose(lift, Rejected)\n\n// envReject :: ReadetT e (Async e b)\nconst envReject =\n  ask()\n    .chain(rejectWith)\n\nrunAndLog(envReject, 'Sammy')\n//=> rej: Sammy\n")),Object(o.b)("h3",{id:"liftfn"},"liftFn"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"ReaderT.liftFn :: Monad m => (a -> m b) -> a -> ReaderT e (m b)\n")),Object(o.b)("p",null,"Used to transform a given function in the form of ",Object(o.b)("inlineCode",{parentName:"p"},"a -> m b")," into a lifted\nfunction, where ",Object(o.b)("inlineCode",{parentName:"p"},"m")," is the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," of a ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT"),". This allows for\nthe removal of composition boilerplate that results from using the\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#lift"}),Object(o.b)("inlineCode",{parentName:"a"},"lift"))," helper."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import ReaderT from 'crocks/Reader/ReaderT'\nimport Either from 'crocks/Either'\n\nimport ifElse from 'crocks/logic/ifElse'\n\nconst EitherReader = ReaderT(Either)\n\nconst { ask, liftFn } = EitherReader\nconst { Left, Right } = Either\n\n// gte :: Number -> Number -> Either String Number\nconst gte = x => ifElse(\n  n => n >= x,\n  Right,\n  n => Left(`${n} is not gte to ${x}`)\n)\n\n// gte10 :: Number -> Either String Number\nconst gte10 =\n  gte(10)\n\n// add20 :: ReaderT Number (Either String Number)\nconst add20 =\n  ask()\n    .chain(liftFn(gte10))\n    .map(n => n + 20)\n\nadd20\n  .runWith(30)\n//=> Right 50\n\nadd20\n  .runWith(9)\n//=> Left \"9 is not gte to 10\"\n")),Object(o.b)("h3",{id:"of"},"of"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"ReaderT.of :: Monad m => a -> ReaderT e (m a)\n")),Object(o.b)("p",null,"Lifts a value into a ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," using the ",Object(o.b)("inlineCode",{parentName:"p"},"of")," method of the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),".\n",Object(o.b)("inlineCode",{parentName:"p"},"of")," will disregard the environment and points the right portion to the provided\nvalue."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import ReaderT from 'crocks/Reader/ReaderT'\n\nimport Maybe from 'crocks/Maybe'\nimport Either from 'crocks/Either'\nimport State from 'crocks/State'\n\nconst MaybeReader = ReaderT(Maybe)\nconst EitherReader = ReaderT(Either)\nconst StateReader = ReaderT(State)\n\nMaybeReader.of('yep')\n  .map(x => x.toUpperCase())\n  .runWith(23)\n//=> Just \"YEP\"\n\nEitherReader.of(43)\n  .runWith(23)\n//=> Right 43\n\nStateReader.of(0)\n  .runWith(23)\n  .runWith(42)\n//=> Pair(0, 42)\n")),Object(o.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(o.b)("h3",{id:"map"},"map"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Monad m => ReaderT e (m a) ~> (a -> b) -> ReaderT e (m b)\n")),Object(o.b)("p",null,"Provides a means for lifting a normal javascript function into the\nunderlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),", allowing the innermost value of the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," to\nbe mapped. This method will ignore the outer ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT"),", and be applied directly\nto the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import ReaderT from 'crocks/Reader/ReaderT'\nimport Maybe from 'crocks/Maybe'\n\nimport isString from 'crocks/predicates/isString'\nimport safe from 'crocks/Maybe/safe'\n\nconst MaybeReader =\n  ReaderT(Maybe)\n\nconst { ask, liftFn } = MaybeReader\n\n// maybeString :: a -> Maybe String\nconst maybeString =\n  safe(isString)\n\n// toUpper :: String -> String\nconst toUpper =\n  x => x.toUpperCase()\n\n// envToUpper :: ReaderT e (Maybe String)\nconst envToUpper =\n  ask()\n    .chain(liftFn(maybeString))\n    .map(toUpper)\n\nenvToUpper\n  .runWith(4)\n//=> Nothing\n\nenvToUpper\n  .runWith('hola')\n//=> Just \"HOLA\"\n\n")),Object(o.b)("h3",{id:"ap"},"ap"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Monad m => ReaderT e (m (a -> b)) ~> ReaderT e (m a) -> ReaderT e (m b)\n")),Object(o.b)("p",null,"Applies wrapped functions to the provided value, using the ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," of the\nunderlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),". A ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," of the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," must be provided,\nwhich allows access to the environment."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport ReaderT from 'crocks/Reader/ReaderT'\nimport Result from 'crocks/Result'\n\nimport fst from 'crocks/Pair/fst'\nimport snd from 'crocks/Pair/snd'\n\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport liftA2 from 'crocks/helpers/liftA2'\n\nconst { Err, Ok } = Result\n\nconst ResultReader =\n  ReaderT(Result)\n\nconst { ask, liftFn } = ResultReader\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// makeError :: a -> Result [ String ] b\nconst makeErr =\n  x => Err([ `${x} is not a Number` ])\n\n// isValid :: a -> ReaderT e (Result [ String ] Number)\nconst isValid = liftFn(\n  ifElse(isNumber, Ok, makeErr)\n)\n\n// first :: ReaderT (Pair a b) (Result [ String ] Number)\nconst first =\n  ask(fst)\n    .chain(isValid)\n\n// second :: ReaderT (Pair a b) (Result [ String ] Number)\nconst second =\n  ask(snd)\n    .chain(isValid)\n\n// Using a fluent style with of\nResultReader.of(add)\n  .ap(first)\n  .ap(second)\n  .runWith(Pair(34, 21))\n//=> Ok 55\n\n// Using a fluent style with map\nfirst\n  .map(add)\n  .ap(second)\n  .runWith(Pair(true, 21))\n//=> Err [ \"true is not a Number\" ]\n\n// Using liftA2\nliftA2(add, first, second)\n  .runWith(Pair('Bob', 'Jones'))\n//=> Err [ 'Bob is not a Number', 'Jones is not a Number' ]\n")),Object(o.b)("h3",{id:"chain"},"chain"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Monad m => ReaderT e (m a) ~> Reader e (a -> ReaderT e (m b)) -> ReaderT e (m b)\n")),Object(o.b)("p",null,"Can be used to apply the effects of the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," with the benefit of\nbeing able to read from the environment. This method only accepts functions\nof the form ",Object(o.b)("inlineCode",{parentName:"p"},"Monad m => a -> ReaderT e (m b)"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import ReaderT from 'crocks/Reader/ReaderT'\nimport Maybe from 'crocks/Maybe'\nimport getProp from 'crocks/Maybe/getProp'\n\nconst MaybeReader =\n  ReaderT(Maybe)\n\nconst { ask, liftFn } = MaybeReader\n\n// readProp :: String -> b -> ReaderT e (Maybe a)\nconst readProp = key =>\n  liftFn(getProp(key))\n\n// getName :: ReaderT e (Maybe a)\nconst getName =\n  ask()\n    .chain(readProp('name'))\n\n// getFirstName :: ReaderT e (Maybe a)\nconst getFirstName =\n  getName\n    .chain(readProp('first'))\n\n// getLastName :: ReaderT e (Maybe a)\nconst getLastName =\n  getName\n    .chain(readProp('last'))\n\n// person :: Object\nconst person = {\n  name: {\n    first: 'Hazel',\n    middle: 'Anne'\n  }\n}\n\ngetFirstName\n  .runWith(person)\n//=> Just \"Hazel\"\n\ngetLastName\n  .runWith(person)\n//=> Nothing\n\ngetLastName\n  .runWith(10)\n//=> Nothing\n")),Object(o.b)("h3",{id:"runwith"},"runWith"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Monad m => ReaderT e (m a) ~> e -> m a\n")),Object(o.b)("p",null,"In order to unwrap the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),", ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," needs to be ran with a\ngiven environment. A ",Object(o.b)("inlineCode",{parentName:"p"},"ReaderT")," instance comes equipped with a ",Object(o.b)("inlineCode",{parentName:"p"},"runWith")," method\nthat accepts an environment and returns the resulting ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import ReaderT from 'crocks/Reader/ReaderT'\nimport Maybe from 'crocks/Maybe'\n\nimport getProp from 'crocks/Maybe/getProp'\n\nconst MaybeReader = ReaderT(Maybe)\nconst { ask, liftFn } = MaybeReader\n\n// data :: Object\nconst data = {\n  animals: [\n    'tiger', 'muskrat', 'mouse'\n  ]\n}\n\n// length :: Array -> Number\nconst length =\n  x => x.length\n\n// prop :: String -> ReaderT Object (Maybe [])\nconst prop = key =>\n  ask()\n    .chain(liftFn(getProp(key)))\n\nprop('animals')\n  .map(length)\n  .runWith(data)\n//=> Just 3\n")))}p.isMDXComponent=!0}}]);