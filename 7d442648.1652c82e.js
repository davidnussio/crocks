(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{114:function(n,e,t){"use strict";t.d(e,"a",(function(){return s})),t.d(e,"b",(function(){return b}));var o=t(0),r=t.n(o);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function l(n,e){if(null==n)return{};var t,o,r=function(n,e){if(null==n)return{};var t,o,r={},a=Object.keys(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var p=r.a.createContext({}),d=function(n){var e=r.a.useContext(p),t=e;return n&&(t="function"==typeof n?n(e):c(c({},e),n)),t},s=function(n){var e=d(n.components);return r.a.createElement(p.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return r.a.createElement(r.a.Fragment,{},e)}},m=r.a.forwardRef((function(n,e){var t=n.components,o=n.mdxType,a=n.originalType,i=n.parentName,p=l(n,["components","mdxType","originalType","parentName"]),s=d(t),m=o,b=s["".concat(i,".").concat(m)]||s[m]||u[m]||a;return t?r.a.createElement(b,c(c({ref:e},p),{},{components:t})):r.a.createElement(b,c({ref:e},p))}));function b(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var a=t.length,i=new Array(a);i[0]=m;var c={};for(var l in e)hasOwnProperty.call(e,l)&&(c[l]=e[l]);c.originalType=n,c.mdxType="string"==typeof n?n:o,i[1]=c;for(var p=2;p<a;p++)i[p]=t[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},91:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return i})),t.d(e,"metadata",(function(){return c})),t.d(e,"toc",(function(){return l})),t.d(e,"default",(function(){return d}));var o=t(3),r=t(7),a=(t(0),t(114)),i={title:"Endo",description:"Endo Monoid",layout:"guide",weight:40},c={unversionedId:"monoids/Endo",id:"monoids/Endo",isDocsHomePage:!1,title:"Endo",description:"Endo Monoid",source:"@site/docs/monoids/Endo.md",slug:"/monoids/Endo",permalink:"/crocks/docs/monoids/Endo",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/monoids/Endo.md",version:"current",sidebar:"sidebar",previous:{title:"Assign",permalink:"/crocks/docs/monoids/Assign"},next:{title:"First",permalink:"/crocks/docs/monoids/First"}},l=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"empty",id:"empty",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"concat",id:"concat",children:[]},{value:"valueOf",id:"valueof",children:[]},{value:"runWith",id:"runwith",children:[]}]}],p={toc:l};function d(n){var e=n.components,t=Object(r.a)(n,["components"]);return Object(a.b)("wrapper",Object(o.a)({},p,t,{components:e,mdxType:"MDXLayout"}),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-haskell"},"Endo a\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Endo")," is a ",Object(a.b)("inlineCode",{parentName:"p"},"Monoid")," that will combine (2) functions that have matching domains\nand codomains (endofunctions) under function composition. Due to the nature\nof ",Object(a.b)("inlineCode",{parentName:"p"},"Endo")," wrapping a function, the underlying value can either be extracted\nusing ",Object(a.b)("a",{parentName:"p",href:"#valueof"},Object(a.b)("inlineCode",{parentName:"a"},"valueOf"))," like any other ",Object(a.b)("inlineCode",{parentName:"p"},"Monoid")," or can be executed directly\nusing ",Object(a.b)("a",{parentName:"p",href:"#runWith"},Object(a.b)("inlineCode",{parentName:"a"},"runWith")),", supplying the input."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Endo from 'crocks/Endo'\n\nimport curry from 'crocks/helpers/curry'\nimport mconcat from 'crocks/helpers/mconcat'\nimport valueOf from 'crocks/pointfree/valueOf'\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// multiply :: Number -> Number -> Number\nconst multiply =\n  x => y => x * y\n\n// runEndo :: Endo a -> a -> a\nconst runEndo =\n  curry(valueOf)\n\n// flow :: Endo Number\nconst addAndDouble =\n  Endo(add(10))\n    .concat(Endo(multiply(2)))\n\n// always10 :: Endo Number\nconst always10 =\n  mconcat(Endo, [ add(100), multiply(0), add(10) ])\n\nrunEndo(addAndDouble, 5)\n//=> 30\n\nalways10\n  .runWith(75)\n//=> 10\n")),Object(a.b)("h2",{id:"implements"},"Implements"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Monoid")),Object(a.b)("h2",{id:"construction"},"Construction"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-haskell"},"Endo :: (a -> a) -> Endo a\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Endo")," is constructed by passing the constructor an Endomorphism, which is a\nfunction in which the domain/codomain (src/target) are of the same\ntype. For example a function that is ",Object(a.b)("inlineCode",{parentName:"p"},"String -> String"),"."),Object(a.b)("p",null,"There is no type checking on the provided function, so some discipline on the\npart of the user is required to make sure the proper type is being used on in\nall cases. This can be partly mitigated by using an Endomorphism of the\ntype ",Object(a.b)("inlineCode",{parentName:"p"},"Maybe a"),". Then the supplied functions could do type checking and\nreturn ",Object(a.b)("inlineCode",{parentName:"p"},"Nothing")," if the types do not match up."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Endo from 'crocks/Endo'\n\nEndo(x => x + 5)\n//=> Endo (Number -> Number)\n")),Object(a.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(a.b)("h3",{id:"empty"},"empty"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-haskell"},"Endo.empty :: () -> Endo a\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"empty")," provides the identity for the ",Object(a.b)("inlineCode",{parentName:"p"},"Monoid")," in that when the value it\nprovides is ",Object(a.b)("inlineCode",{parentName:"p"},"concat"),"ed to any other value, it will return the other value. In\nthe case of ",Object(a.b)("inlineCode",{parentName:"p"},"Endo")," the result of ",Object(a.b)("inlineCode",{parentName:"p"},"empty")," is the identity function, which echoes\nits input. ",Object(a.b)("inlineCode",{parentName:"p"},"empty")," is available on both the Constructor and the Instance for\nconvenience."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Endo from 'crocks/Endo'\n\nimport runWith from 'crocks/pointfree/runWith'\n\n// empty :: Endo a\nconst empty = Endo.empty()\n\n// toUpper :: Endo String\nconst toUpper =\n  Endo(x => x.toUpperCase())\n\n// runNice :: Endo String -> String\nconst runNice =\n  runWith('nice')\n\nrunNice(empty.concat(toUpper))\n//=> \"NICE\"\n\nrunNice(toUpper.concat(empty))\n//=> \"NICE\"\n")),Object(a.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(a.b)("h3",{id:"concat"},"concat"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-haskell"},"Endo a ~> Endo a -> Endo a\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"concat")," is used to combine (2) ",Object(a.b)("inlineCode",{parentName:"p"},"Semigroup"),"s of the same type under an operation\nspecified by the ",Object(a.b)("inlineCode",{parentName:"p"},"Semigroup"),". In the case of ",Object(a.b)("inlineCode",{parentName:"p"},"Endo"),", it will combine (2)\nendofunctions under function composition."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Endo from 'crocks/Endo'\n\nimport setProp from 'crocks/helpers/setProp'\nimport mapProps from 'crocks/helpers/mapProps'\nimport objOf from 'crocks/helpers/objOf'\n\n// inc :: Number -> Number\nconst inc =\n  x => x + 1\n\n// incValue :: Endo Object\nconst incValue =\n  Endo(mapProps({ value: inc }))\n\n// addDone :: Endo Object\nconst addDone =\n  Endo(setProp('done', true))\n\n// finish :: Endo Object\nconst packResults =\n  Endo(objOf('results'))\n\n// finish :: Endo Object\nconst finish =\n  incValue.concat(addDone)\n\nfinish.runWith({ value: 99 })\n//=> { value: 100, done: true }\n\nfinish\n  .concat(packResults)\n  .runWith({ value: 99 })\n//=> { results: { value: 100, done: true } }\n")),Object(a.b)("h3",{id:"valueof"},"valueOf"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-haskell"},"Endo a ~> () -> (a -> a)\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"valueOf")," is used on all ",Object(a.b)("inlineCode",{parentName:"p"},"crocks")," ",Object(a.b)("inlineCode",{parentName:"p"},"Monoid"),"s as a means of extraction. While the\nextraction is available, types that implement ",Object(a.b)("inlineCode",{parentName:"p"},"valueOf")," are not necessarily\na ",Object(a.b)("inlineCode",{parentName:"p"},"Comonad"),". This function is used primarily for convenience for some of the\nhelper functions that ship with ",Object(a.b)("inlineCode",{parentName:"p"},"crocks"),". Calling ",Object(a.b)("inlineCode",{parentName:"p"},"valueOf")," on\nan ",Object(a.b)("inlineCode",{parentName:"p"},"Endo")," instance will result in the underlying endofunction."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Endo from 'crocks/Endo'\n\nimport filter from 'crocks/pointfree/filter'\nimport map from 'crocks/pointfree/map'\nimport mconcat from 'crocks/helpers/mconcat'\n\n// lt10 :: [ Number ] -> [ Number ]\nconst lt10 =\n  filter(x => x < 10)\n\n// double :: [ Number ] -> [ Number ]\nconst double =\n  map(x => x * 2)\n\n// buildEndo :: [ (a -> a) ] -> Endo a\nconst buildEndo =\n  mconcat(Endo)\n\n// fn :: [ Number ] -> [ Number ]\nconst fn =\n  buildEndo([ lt10, double ])\n    .valueOf()\n\nfn([ 12, 5, 3, 90 ])\n//=> [ 10, 6 ]\n\nfn([])\n//=> []\n")),Object(a.b)("h3",{id:"runwith"},"runWith"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-haskell"},"Endo a ~> a -> a\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Endo")," wraps a function and as such, its underlying endofunction can be run\nwhile inside of an ",Object(a.b)("inlineCode",{parentName:"p"},"Endo")," by calling ",Object(a.b)("inlineCode",{parentName:"p"},"runWith"),". Providing a valid value of the\nsame type required by the function, ",Object(a.b)("inlineCode",{parentName:"p"},"runWith")," will execute the underlying\nfunction and return the result."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Endo from 'crocks/Endo'\n\nimport filter from 'crocks/pointfree/filter'\nimport map from 'crocks/pointfree/map'\nimport mconcat from 'crocks/helpers/mconcat'\n\n// lt10 :: [ Number ] -> [ Number ]\nconst lt10 =\n  filter(x => x < 10)\n\n// double :: [ Number ] -> [ Number ]\nconst double =\n  map(x => x * 2)\n\n// buildEndo :: [ (a -> a) ] -> Endo a\nconst flow =\n  mconcat(Endo, [ lt10, double ])\n\nflow\n  .runWith([ 12, 5, 3, 90 ])\n//=> [ 10, 6 ]\n\nflow\n  .runWith([])\n//=> []\n")))}d.isMDXComponent=!0}}]);