(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{100:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return m}));var a=t(0),i=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=i.a.createContext({}),b=function(e){var n=i.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},d=function(e){var n=b(e.components);return i.a.createElement(l.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},u=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),d=b(t),u=a,m=d["".concat(o,".").concat(u)]||d[u]||s[u]||r;return t?i.a.createElement(m,c(c({ref:n},l),{},{components:t})):i.a.createElement(m,c({ref:n},l))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=u;var c={};for(var p in n)hasOwnProperty.call(n,p)&&(c[p]=n[p]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var l=2;l<r;l++)o[l]=t[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},79:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return p})),t.d(n,"default",(function(){return b}));var a=t(2),i=t(6),r=(t(0),t(100)),o={title:"Identity",description:"Identity Crock",layout:"guide",weight:60},c={unversionedId:"crocks/Identity",id:"crocks/Identity",isDocsHomePage:!1,title:"Identity",description:"Identity Crock",source:"@site/docs/crocks/Identity.md",slug:"/crocks/Identity",permalink:"/docs/docs/crocks/Identity",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Identity.md",version:"current",sidebar:"sidebar",previous:{title:"Equiv",permalink:"/docs/docs/crocks/Equiv"},next:{title:"Maybe",permalink:"/docs/docs/crocks/Maybe"}},p=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"of",id:"of",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"equals",id:"equals",children:[]},{value:"concat",id:"concat",children:[]},{value:"map",id:"map",children:[]},{value:"ap",id:"ap",children:[]},{value:"sequence",id:"sequence",children:[]},{value:"traverse",id:"traverse",children:[]},{value:"chain",id:"chain",children:[]},{value:"valueOf",id:"valueof",children:[]}]}],l={rightToc:p};function b(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity a\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Identity")," is a ",Object(r.b)("inlineCode",{parentName:"p"},"crock")," that can be used to wrap a common interface around\nexisting JavaScript types and functions. It maintains integrity by lifting\nand applying functions and types as is, without adding any additional structure\nor effects. By not applying and additional structure to existing functions,\n",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," can be swapped in and out for other ",Object(r.b)("inlineCode",{parentName:"p"},"Functor"),"s that do apply their\nown structure and effects."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\n\nIdentity(10)\n//=> Identity 10\n")),Object(r.b)("h2",{id:"implements"},"Implements"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Setoid"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Functor"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Traversable"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Chain"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Applicative"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Monad")),Object(r.b)("h2",{id:"construction"},"Construction"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity :: a -> Identity a\n")),Object(r.b)("p",null,"The constructor for an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," is a unary function. When a value is passed\nin an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," of the given value is returned ready for ",Object(r.b)("inlineCode",{parentName:"p"},"map")," or ",Object(r.b)("inlineCode",{parentName:"p"},"chain"),". "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\n\nconst fromComputerCode = String.fromCharCode\n\nIdentity(42)\n  .map(fromComputerCode)\n//=> Identity '*'\n")),Object(r.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(r.b)("h3",{id:"of"},"of"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity.of :: a -> Identity a\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"of")," is used to construct an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," with any given value. It is there to\nallow ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," to work as a pointed functor. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\n\nIdentity.of(42)\n//=> Identity 42\n\nIdentity.of(true)\n//=> Identity true\n")),Object(r.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(r.b)("h3",{id:"equals"},"equals"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity a ~> b -> Boolean\n")),Object(r.b)("p",null,"Used to compare the underlying values of two ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," instances for equality by\nvalue, ",Object(r.b)("inlineCode",{parentName:"p"},"equals")," takes any given argument and returns ",Object(r.b)("inlineCode",{parentName:"p"},"true")," if the passed\narguments is an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," with an underlying value equal to the underlying value\nof the ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," the method is being called on. If the passed argument is not\nan ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," or the underlying values are not equal, ",Object(r.b)("inlineCode",{parentName:"p"},"equals")," will return ",Object(r.b)("inlineCode",{parentName:"p"},"false"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\n\nimport equals from 'crocks/pointfree/equals'\n\nIdentity(33)\n  .equals(Identity(33))\n//=> true\n\nIdentity(33)\n  .equals(Identity('33'))\n//=> false\n\n// by value, not reference for most types\nIdentity({ a: 86, b: true })\n  .equals(Identity({ a: 86, b: true }))\n//=> true\n\nequals(Identity(95), 95)\n//=> false\n\nequals(Identity([ 2, 3 ]), Identity([ 2, 3 ]))\n//=> true\n")),Object(r.b)("h3",{id:"concat"},"concat"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity s => Identity s ~> Identity s -> Identity s\n")),Object(r.b)("p",null,"When an underlying value of a given ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," is fixed to a ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"concat")," can be used to concat another ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," instance with an\nunderlying ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup")," of the same type. Expecting an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," wrapping\na ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup")," of the same type, ",Object(r.b)("inlineCode",{parentName:"p"},"concat")," will give back a\nnew ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," instance wrapping the result of combining the two\nunderlying ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup"),"s."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\n\nimport Sum from 'crocks/Sum'\n\nimport compose from 'crocks/helpers/compose'\nimport concat from 'crocks/pointfree/concat'\nimport flip from 'crocks/combinators/flip'\nimport map from 'crocks/pointfree/map'\nimport mapReduce from 'crocks/helpers/mapReduce'\nimport valueOf from 'crocks/pointfree/valueOf'\n\n// empty :: Identity Sum\nconst empty =\n  Identity(Sum.empty())\n\n// sumList :: [ * ] -> Identity Number\nconst sumList = compose(\n  map(valueOf),\n  mapReduce(compose(Identity, Sum), flip(concat), empty)\n)\n\nIdentity([ 34 ])\n  .concat(Identity([ 92 ]))\n//=> Identity [ 34, 92 ]\n\nsumList([ 3, 4, 5 ])\n//=> Identity 12\n")),Object(r.b)("h3",{id:"map"},"map"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity a ~> (a -> b) -> Identity b\n")),Object(r.b)("p",null,"Used to apply transformations to values you've lifted into an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity"),", ",Object(r.b)("inlineCode",{parentName:"p"},"map")," takes\na function that it will lift into the context of the ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," and apply\nto it the wrapped value. ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," contains no behavior and will do nothing\nmore than apply the value inside the ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," to the function."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\nimport map from 'crocks/pointfree/map'\n\nconst prod = a => b => a * b\n\nconst mapDouble = map(prod(2))\n\nmapDouble(Identity(5))\n//=> Identity 10\n")),Object(r.b)("h3",{id:"ap"},"ap"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity (a -> b) ~> Identity a -> Identity b\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"ap")," allows for values wrapped in an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," to be applied to functions also\nwrapped in an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity"),". In order to use ",Object(r.b)("inlineCode",{parentName:"p"},"ap"),", the ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," must contain a\nfunction as its value. Under the hood, ",Object(r.b)("inlineCode",{parentName:"p"},"ap")," unwraps both the function\nand the value to be applied and applies the value to the function. Finally it\nwill wrap the result of that application back into an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity"),". It is required\nthat the inner function is curried."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\n\nconst prod = a => b => a * b\nconst double = prod(2)\n\nIdentity(double)\n  .ap(Identity(5))\n//=> Identity 10\n")),Object(r.b)("h3",{id:"sequence"},"sequence"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Apply f => Identity (f a) ~> (b -> f b) -> f (Identity a)\nApplicative f => Identity (f a) ~> TypeRep f -> f (Identity a)\n")),Object(r.b)("p",null,"When an instance of ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," wraps an ",Object(r.b)("inlineCode",{parentName:"p"},"Apply")," instance, ",Object(r.b)("inlineCode",{parentName:"p"},"sequence")," can be used to\nswap the type sequence. ",Object(r.b)("inlineCode",{parentName:"p"},"sequence")," requires either an ",Object(r.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or\nan ",Object(r.b)("inlineCode",{parentName:"p"},"Apply")," returning function to be provided for its argument."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"sequence")," can be derived from ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#traverse"}),Object(r.b)("inlineCode",{parentName:"a"},"traverse"))," by passing it\nan ",Object(r.b)("inlineCode",{parentName:"p"},"identity")," function (",Object(r.b)("inlineCode",{parentName:"p"},"x => x"),")."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\n\nimport Maybe from 'crocks/Maybe'\nimport sequence from 'crocks/pointfree/sequence'\n\n// seqId :: Identity Maybe a -> Maybe Identity a\nconst seqMaybe =\n  sequence(Maybe)\n\nseqMaybe(Identity(Maybe(42)))\n//=> Just Identity 42\n")),Object(r.b)("h3",{id:"traverse"},"traverse"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Apply f => Identity a ~> (a -> f b) -> f (Identity b)\nApplicative f => Identity a ~> (TypeRep f, (a -> f b)) -> f (Identity a b)\n")),Object(r.b)("p",null,'Used to apply the "effect" of an ',Object(r.b)("inlineCode",{parentName:"p"},"Apply")," to a value inside of a ",Object(r.b)("inlineCode",{parentName:"p"},"Identity"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"traverse"),' combines both the "effects" of the ',Object(r.b)("inlineCode",{parentName:"p"},"Apply")," and the ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," by\nreturning a new instance of the ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),", wrapping the result of\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),'s "effect" on the value in the ',Object(r.b)("inlineCode",{parentName:"p"},"Identity"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"traverse")," requires either an ",Object(r.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or an ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),' returning\nfunction as its first argument and a function that is used to apply the "effect"\nof the target ',Object(r.b)("inlineCode",{parentName:"p"},"Apply")," to the value inside of the ",Object(r.b)("inlineCode",{parentName:"p"},"Identity"),". Both arguments must provide\nan instance of the target ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\nimport IO from 'crocks/IO'\n\nimport compose from 'crocks/helpers/compose'\nimport isNumber from 'crocks/predicates/isNumber'\nimport traverse from 'crocks/pointfree/traverse'\nimport ifElse from 'crocks/logic/ifElse'\n\n// someGlobal :: Number\nlet someGlobal = 10\n\n// addToGlobal :: Number -> IO Number\nconst addToGlobal = x => IO(() => someGlobal + x)\n\n// safeAddToGlobal :: a -> IO (Maybe Number)\nconst safeAddToGlobal = compose(\n  traverse(IO, addToGlobal),\n  Identity,\n  ifElse(isNumber, x => x, () => NaN)\n)\n\nsafeAddToGlobal(32)\n  .run()\n//=> Identity 42\n//someGlobal => 42\n\nsafeAddToGlobal(32)\n  .run()\n  .valueOf()\n//=> 42\n\nsafeAddToGlobal(undefined)\n  .run()\n  .valueOf()\n//=> NaN\n")),Object(r.b)("h3",{id:"chain"},"chain"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity a ~> (a -> Identity b) -> Identity b\n")),Object(r.b)("p",null,"Normally one of the ways ",Object(r.b)("inlineCode",{parentName:"p"},"Monad"),"s like ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," are able to be combined and\nhave their effects applied is through ",Object(r.b)("inlineCode",{parentName:"p"},"chain"),". However ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," is different\nbecause there are no effects to apply. ",Object(r.b)("inlineCode",{parentName:"p"},"chain")," will simply take a function that\nreturns ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," and applies it to its value."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\nimport compose from 'crocks/helpers/compose'\nimport chain from 'crocks/pointfree/chain'\n\nconst prod = a => b => a * b\nconst doubleAsIdentity = compose(Identity, prod(2))\n\ndoubleAsIdentity(21)\n//=> Identity 42\n\nchain(doubleAsIdentity, Identity(5))\n//=> Identity 10\n")),Object(r.b)("h3",{id:"valueof"},"valueOf"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Identity a ~> () -> a\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"valueOf")," is used as a means of extraction. This function is used primarily for\nconvenience for some of the helper functions that ship with ",Object(r.b)("inlineCode",{parentName:"p"},"crocks"),".\nCalling ",Object(r.b)("inlineCode",{parentName:"p"},"valueOf")," on an ",Object(r.b)("inlineCode",{parentName:"p"},"Identity")," instance will return the value being\ncontained."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Identity from 'crocks/Identity'\n\nIdentity(42)\n  .valueOf()\n//=> 42\n\nIdentity([ 10, 20 ])\n  .concat(Identity([ 30, 40 ]))\n  .valueOf()\n//=>[ 10, 20, 30, 40 ]\n")))}b.isMDXComponent=!0}}]);