(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{101:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return d}));var a=t(0),r=t.n(a);function p(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){p(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},p=Object.keys(e);for(a=0;a<p.length;a++)t=p[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(a=0;a<p.length;a++)t=p[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),s=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=s(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,p=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=s(t),m=a,d=u["".concat(o,".").concat(m)]||u[m]||b[m]||p;return t?r.a.createElement(d,l(l({ref:n},c),{},{components:t})):r.a.createElement(d,l({ref:n},c))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var p=t.length,o=new Array(p);o[0]=m;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<p;c++)o[c]=t[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},84:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return l})),t.d(n,"rightToc",(function(){return i})),t.d(n,"default",(function(){return s}));var a=t(2),r=t(6),p=(t(0),t(101)),o={title:"Tuple",description:"Tuple Crock",layout:"guide",functions:["nmap","tupletoarray"],weight:150},l={unversionedId:"crocks/Tuple",id:"crocks/Tuple",isDocsHomePage:!1,title:"Tuple",description:"Tuple Crock",source:"@site/docs/crocks/Tuple.md",slug:"/crocks/Tuple",permalink:"/docs/crocks/Tuple",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Tuple.md",version:"current",sidebar:"sidebar",previous:{title:"State",permalink:"/docs/crocks/State"},next:{title:"Monoids",permalink:"/docs/monoids/"}},i=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Instance Methods",id:"instance-methods",children:[{value:"equals",id:"equals",children:[]},{value:"concat",id:"concat",children:[]},{value:"map",id:"map",children:[]},{value:"mapAll",id:"mapall",children:[]},{value:"project",id:"project",children:[]},{value:"merge",id:"merge",children:[]},{value:"toArray",id:"toarray",children:[]}]},{value:"Pointfree Functions",id:"pointfree-functions",children:[{value:"nmap",id:"nmap",children:[]},{value:"project",id:"project-1",children:[]}]},{value:"Transformation Functions",id:"transformation-functions",children:[{value:"tupleToArray",id:"tupletoarray",children:[]}]}],c={rightToc:i};function s(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(p.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Tuple(n) = n-Tuple *...n\n")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"Tuple")," provides a means to construct a Product Type of an arbitrary size.\nThis allows types to be defined with as many independent values as needed for\na given flow."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\n\nimport First from 'crocks/First'\nimport Sum from 'crocks/Sum'\n\nimport compose from 'crocks/helpers/compose'\nimport concat from 'crocks/pointfree/concat'\nimport constant from 'crocks/combinators/constant'\nimport flip from 'crocks/combinators/flip'\nimport ifElse from 'crocks/logic/ifElse'\nimport mapReduce from 'crocks/helpers/mapReduce'\nimport merge from 'crocks/pointfree/merge'\nimport nmap from 'crocks/Tuple/nmap'\nimport option from 'crocks/pointfree/option'\nimport propEq from 'crocks/predicates/propEq'\nimport valueOf from 'crocks/pointfree/valueOf'\n\n// Triple :: 3-Tuple\nconst Triple = Tuple(3)\n\n// EventRecord :: { event: String, payload: a }\n// ReportTriple :: Triple Sum Sum (First Boolean)\n\n// data :: [ EventRecord ]\nconst data = [\n  { event: 'start', payload: '' },\n  { event: 'answer', payload: { id: 4, correct: true } },\n  { event: 'answer', payload: { id: 2, correct: false } },\n  { event: 'answer', payload: { id: 5, correct: false } },\n  { event: 'stop', payload: '' },\n  { event: 'start', payload: '' },\n  { event: 'answer', payload: { id: 1, correct: true } },\n  { event: 'answer', payload: { id: 3, correct: true } },\n  { event: 'complete', payload: { passed: true } },\n  { event: 'stop', payload: '' }\n]\n\n// trimap :: (a -> d) -> (b -> e) -> (c -> f) -> Triple a b c -> Triple d e f\nconst trimap =\n  nmap(3)\n\n// reportEmpty :: () -> ReportTriple\nconst reportEmpty = () =>\n  Triple(Sum.empty(), Sum.empty(), First.empty())\n\n// encodeCorrect :: EventRecord -> Sum\nconst encodeCorrect = ifElse(\n  propEq('correct', true),\n  constant(Sum(1)),\n  Sum.empty\n)\n\n// encode :: EventRecord -> ReportTriple\nconst encode = ({ event, payload }) => {\n  switch (event) {\n  case 'stop':\n    return Triple(\n      Sum(1), Sum.empty(), First.empty()\n    )\n\n  case 'answer':\n    return Triple(\n      Sum.empty(), encodeCorrect(payload), First.empty()\n    )\n\n  case 'complete':\n    return Triple(\n      Sum.empty(), Sum.empty(), First(true)\n    )\n  }\n\n  return reportEmpty()\n}\n\n// extract :: ReportTriple -> Triple Number Number Boolean\nconst extract =\n  trimap(valueOf, valueOf, option(false))\n\n// decode :: (Number, Number, Boolean) -> Object\nconst decode = (attempts, correct, complete) =>\n  ({ attempts, correct, complete })\n\n// foldReport :: [ EventRecord ] -> ReportTriple\nconst foldReport = mapReduce(\n  encode,\n  flip(concat),\n  reportEmpty()\n)\n\n// calculate :: [ EventRecord ] -> Object\nconst calculate = compose(\n  merge(decode),\n  extract,\n  foldReport\n)\n\ncalculate(data)\n//=> { attempts: 2, correct: 3, complete: true }\n")),Object(p.b)("h2",{id:"implements"},"Implements"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"Setoid"),", ",Object(p.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(p.b)("inlineCode",{parentName:"p"},"Functor")),Object(p.b)("h2",{id:"construction"},"Construction"),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Tuple :: Number -> n-Tuple *...n\n")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"Tuple")," is a type constructor that takes a non-zero, positive ",Object(p.b)("inlineCode",{parentName:"p"},"Integer")," as its\nargument. Instead of an instance, it will return a constructor that is used\nto construct an ",Object(p.b)("inlineCode",{parentName:"p"},"n")," sized ",Object(p.b)("inlineCode",{parentName:"p"},"Tuple"),", where ",Object(p.b)("inlineCode",{parentName:"p"},"n")," is the number of independent values\nthat can be represented."),Object(p.b)("p",null,"The resulting ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," constructor is parameterized as an ",Object(p.b)("inlineCode",{parentName:"p"},"n-Functor"),", where\neach parameter can vary from instance to instance."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\n\n// Triple :: 3-Tuple\nconst Triple =\n  Tuple(3)\n\n// Quad :: 4-Tuple\nconst Quad =\n  Tuple(4)\n\nTriple(false, true, 45)\n//=> 3-Tuple (false, true, 45)\n\nQuad({ a: true }, [ 1, 2, 3 ], 60, 'string')\n//=> 4-Tuple ({ a: true }, [ 1, 2, 3 ], 60, \"string\")\n")),Object(p.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(p.b)("h3",{id:"equals"},"equals"),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"n-Tuple *...n ~> a -> Boolean\n")),Object(p.b)("p",null,"Used to compare the values of two ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," instances by value.",Object(p.b)("inlineCode",{parentName:"p"},"equals")," takes\nany given argument and will return a ",Object(p.b)("inlineCode",{parentName:"p"},"true")," if passed an ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," of the same\nsize with match values in the same positions as the ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," ",Object(p.b)("inlineCode",{parentName:"p"},"equals")," was\nrun on. If the provided argument is not an ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," of the same type or the\nunderlying values are not equal, then ",Object(p.b)("inlineCode",{parentName:"p"},"equals")," will return ",Object(p.b)("inlineCode",{parentName:"p"},"false"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\n\n// Pair :: 2-Tuple\nconst Pair =\n  Tuple(2)\n\n// Triple :: 3-Tuple\nconst Triple =\n  Tuple(3)\n\nPair(1, false)\n  .equals(Pair(1, false))\n//=> true\n\nTriple(1, false, [ 1, 2 ])\n  .equals(Triple(1, false, [ 1, 2 ]))\n//=> true\n\nTriple(1, false, [ 1, 2 ])\n  .equals(Triple(1, true, [ 3, 4 ]))\n//=> false\n\nPair(1, false)\n  .equals(Triple(1, false, [ 1, 2 ]))\n//=> false\n")),Object(p.b)("h3",{id:"concat"},"concat"),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Semigroup s1 => 1-Tuple s1 ~> 1-Tuple s1 -> 1-Tuple s1\nSemigroup s1, s2 => 2-Tuple s1 s2 ~> 2-Tuple s1 s2 -> 2-Tuple s1 s2\n...\n")),Object(p.b)("p",null,"Two instances of the same ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," can be combined using concatenation, as\nlong as both have instances of the same ",Object(p.b)("inlineCode",{parentName:"p"},"Semigroup"),"s in the same\nposition. ",Object(p.b)("inlineCode",{parentName:"p"},"concat")," will be called on each contained ",Object(p.b)("inlineCode",{parentName:"p"},"Semigroup")," instance with\nthe instance corresponding to the other ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," instance. The result of each\nconcatenation will be provided in a new ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," instance."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\nimport Sum from 'crocks/Sum'\n\n// Triple :: 3-Tuple\nconst Triple =\n  Tuple(3)\n\n// Unary :: 1-Tuple\nconst Unary =\n  Tuple(1)\n\nTriple([ 1, 3 ], Sum(10), Sum(1))\n  .concat(Triple([ 4 ], Sum.empty(), Sum(9)))\n//=> 3-Tuple( [ 1, 3, 4 ], Sum 10, Sum, 10 )\n\nUnary([ 10 ])\n  .concat(Unary([ 10 ]))\n//=> 1-Tuple( [ 10, 10 ] )\n")),Object(p.b)("h3",{id:"map"},"map"),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"1-Tuple a ~> (a -> b) -> 1-Tuple b\n2-Tuple a b ~> (b -> c) -> 2-Tuple a c\n...\n")),Object(p.b)("p",null,"Used to lift a single function into a given ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," to map the rightmost\nvalue. ",Object(p.b)("inlineCode",{parentName:"p"},"map")," takes a function ",Object(p.b)("inlineCode",{parentName:"p"},"(a -> b)")," and will return a\nnew ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," instance with the result of mapping the rightmost value from its\noriginal ",Object(p.b)("inlineCode",{parentName:"p"},"a")," type to the resulting ",Object(p.b)("inlineCode",{parentName:"p"},"b"),"."),Object(p.b)("p",null,"This method will only apply to the rightmost value. ",Object(p.b)("a",Object(a.a)({parentName:"p"},{href:"#mapall"}),Object(p.b)("inlineCode",{parentName:"a"},"mapAll"))," can be\nused to map over all values in a given ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\n\nimport Maybe from 'crocks/Maybe'\nimport chain from 'crocks/pointfree/chain'\nimport getProp from 'crocks/Maybe/getProp'\n\nconst { Just } = Maybe\n\n// Pair :: 2-Tuple\nconst Pair =\n  Tuple(2)\n\nPair(false, Just({ a: 'this is a' }))\n  .map(chain(getProp('a')))\n//=> 2-Tuple( false, Just \"this is a\" )\n")),Object(p.b)("h3",{id:"mapall"},"mapAll"),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"1-Tuple a ~> (a -> b) -> 1-Tuple b\n2-Tuple a b ~> (a -> c) -> (b -> d) -> 2-Tuple c d\n...\n")),Object(p.b)("p",null,"While ",Object(p.b)("a",Object(a.a)({parentName:"p"},{href:"#map"}),Object(p.b)("inlineCode",{parentName:"a"},"map"))," allows for the rightmost portion of a given ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," to be\nmapped, ",Object(p.b)("inlineCode",{parentName:"p"},"mapAll")," provides a means to map all values at once, independently of\neach other. A ",Object(p.b)("inlineCode",{parentName:"p"},"Tuple")," of ",Object(p.b)("inlineCode",{parentName:"p"},"n")," size requires ",Object(p.b)("inlineCode",{parentName:"p"},"n")," number of functions in the same\nleft to right order as their respective values. ",Object(p.b)("inlineCode",{parentName:"p"},"mapAll")," returns a\nnew ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," of the same size containing the results of the provided mapping\nfunctions."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\nimport objOf from 'crocks/helpers/objOf'\n\n// Triple :: 3-Tuple\nconst Triple =\n  Tuple(3)\n\n// toUpper :: String -> String\nconst toUpper =\n  x => x.toUpperCase()\n\n// negate :: a -> Boolean\nconst negate =\n  x => !x\n\nTriple('little', false, 94)\n  .mapAll(toUpper, negate, objOf('a'))\n//=> 3-Tuple( \"LITTLE\", true, { a: 94 } )\n")),Object(p.b)("h3",{id:"project"},"project"),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"1-Tuple a ~> Integer -> a\n2-Tuple a b ~> Integer -> (a | b)\n3-tuple a b c ~> Integer -> (a | b | c)\n...\n")),Object(p.b)("p",null,"Used to extract a specific value from a given ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple"),". ",Object(p.b)("inlineCode",{parentName:"p"},"project")," takes a\npositive, non-zero ",Object(p.b)("inlineCode",{parentName:"p"},"Integer")," as its input and will return the extracted value\nresiding in the provided 1 based index."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\n\n// Pair :: 2-Tuple\nconst Pair =\n  Tuple(2)\n\n// Triple :: 3-Tuple\nconst Triple =\n  Tuple(3)\n\nTriple('one', 'two', 'three')\n  .project(1)\n//=> \"one\"\n\nPair('one', 'two')\n  .project(2)\n//=> \"two\"\n")),Object(p.b)("h3",{id:"merge"},"merge"),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"1-Tuple a ~> (a -> b) -> b\n2-Tuple a b ~> ((a, b) -> c) -> c\n3-Tuple a b c ~> ((a, b, c) -> d) -> d\n...\n")),Object(p.b)("p",null,"Used to fold a given ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," into a single value, ",Object(p.b)("inlineCode",{parentName:"p"},"merge")," accepts a function\nof any arity and will apply each value in the ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple"),", in order, to the\nprovided function. ",Object(p.b)("inlineCode",{parentName:"p"},"merge")," returns the result of the application."),Object(p.b)("p",null,"When using an ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," to manage parallel processing, ",Object(p.b)("inlineCode",{parentName:"p"},"merge")," is used to\ncombine the separate branches into a single result."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\nimport curry from 'crocks/helpers/curry'\n\n// Triple :: 3-Tuple\nconst Triple =\n  Tuple(3)\n\n// buildObj :: (a, b, c) -> Object\nconst buildObj = curry(\n  (first, second, third) =>\n    ({ first, second, third })\n)\n\nTriple(99, 'name', [ 1, 5, 7 ])\n  .merge(buildObj)\n//=> { first: 99, second: \"name\", third: [ 1, 5, 7 ] }\n")),Object(p.b)("h3",{id:"toarray"},"toArray"),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"1-Tuple a ~> () -> [ a ]\n2-Tuple a b ~> () -> [ a + b ]\n3-Tuple a b c ~> () -> [ a + b + c ]\n...\n")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"toArray")," is a Natural Transformation from a given ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," to a\nJavaScript ",Object(p.b)("inlineCode",{parentName:"p"},"Array"),". Any arguments applied to ",Object(p.b)("inlineCode",{parentName:"p"},"toArray")," will be ignored and will\nreturn an Array of ",Object(p.b)("inlineCode",{parentName:"p"},"n")," size, where ",Object(p.b)("inlineCode",{parentName:"p"},"n")," corresponds to the size of\nthe ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple"),". Each value will be in the same left to right position as the\norder defined by the ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\n\n// Pair :: 2-Tuple\nconst Pair =\n  Tuple(2)\n\n// Quad :: 4-Tuple\nconst Quad =\n  Tuple(4)\n\nPair(false, { a: false })\n  .toArray()\n//=> [ false, { a: false } ]\n\nQuad([ 1, 3 ], [ 2, 4 ], 'name', 'Joe')\n  .toArray()\n//=> [ [ 1, 3 ], [ 2, 4 ], \"name\", \"Joe\" ]\n")),Object(p.b)("h2",{id:"pointfree-functions"},"Pointfree Functions"),Object(p.b)("h3",{id:"nmap"},"nmap"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"crocks/Tuple/nmap")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"nmap :: Integer -> ...(* -> *) -> m ...* -> m ...*\n")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"nmap")," takes a non-zero, positive ",Object(p.b)("inlineCode",{parentName:"p"},"Integer")," as its argument and will return\nanother function that takes the same number of unary functions as\nthe provided ",Object(p.b)("inlineCode",{parentName:"p"},"Integer"),". After all functions are provided, the last argument\nneeds to be an ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," of the same size as the provided ",Object(p.b)("inlineCode",{parentName:"p"},"Integer"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\nimport nmap from 'crocks/Tuple/nmap'\n\n// toUpper :: String -> String\nconst toUpper =\n  x => x.toUpperCase()\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// Pair :: 2-Tuple a b\nconst Pair =\n  Tuple(2)\n\n// Triple :: 3-Tuple a b c\nconst Triple =\n  Tuple(3)\n\n// bimap :: (a -> c) -> (b -> d) -> Pair a b -> Pair c d\nconst bimap =\n  nmap(2)\n\n// trimap :: (a -> d) -> (b -> e) -> (c -> f) -> Triple a b c -> Triple d e f\nconst trimap =\n  nmap(3)\n\n// pair :: Pair String Number\nconst pair =\n  Pair('jordan', 13)\n\nbimap(toUpper, add(10), pair)\n//=> 2-Tuple( \"JORDAN\", 23 )\n\nconst triple =\n  Triple(32, 'string', 0)\n\ntrimap(add(10), toUpper, add(10), triple)\n//=> 3-Tuple( 42, \"STRING\", 10 )\n")),Object(p.b)("h3",{id:"project-1"},"project"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"crocks/Tuple/project")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"project :: Integer -> m ...* -> a\n")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"project")," takes a positive, non-zero Integer as its input and returns another\nfunction that accepts an ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple"),". It then returns the value from\nthe ",Object(p.b)("inlineCode",{parentName:"p"},"n-Tuple")," that resides at the provided ",Object(p.b)("inlineCode",{parentName:"p"},"Integer")," index."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\nimport project from 'crocks/Tuple/project'\n\n// Triple :: 3-Tuple\nconst Triple = Tuple(3)('one', 'two', 'three')\n\n// getFirst :: Number -> a\nconst getFirst = project(1)\n\n// getSecond :: Number -> a\nconst getSecond = project(2)\n\ngetFirst(Triple)\n//=> \"one\"\n\ngetSecond(Triple)\n//=> \"two\"\n")),Object(p.b)("h2",{id:"transformation-functions"},"Transformation Functions"),Object(p.b)("h3",{id:"tupletoarray"},"tupleToArray"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"crocks/Tuple/tupleToArray")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"tupleToArray :: Tuple a -> [ a ]\ntupleToArray :: (a -> Tuple b) -> a -> [ b ]\n")),Object(p.b)("p",null,"Used to transform a given ",Object(p.b)("inlineCode",{parentName:"p"},"Tuple")," instance to an ",Object(p.b)("inlineCode",{parentName:"p"},"Array")," instance."),Object(p.b)("p",null,"Like all ",Object(p.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(p.b)("inlineCode",{parentName:"p"},"tupleToArray")," has two possible\nsignatures and will behave differently when passed either\na ",Object(p.b)("inlineCode",{parentName:"p"},"Tuple")," instance or a function that returns an instance\nof ",Object(p.b)("inlineCode",{parentName:"p"},"Tuple"),". When passed the instance, a transformed ",Object(p.b)("inlineCode",{parentName:"p"},"Array")," is\nreturned. When passed a ",Object(p.b)("inlineCode",{parentName:"p"},"Tuple")," returning function, a function will\nbe returned that takes a given value and returns an ",Object(p.b)("inlineCode",{parentName:"p"},"Array"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Tuple from 'crocks/Tuple'\nimport tupleToArray from 'crocks/Tuple/tupleToArray'\nimport constant from 'crocks/combinators/constant'\n\nconst Triple = Tuple(3)\n\nconst triple = Triple( 1, { key: 'value' }, 'string' )\n\ntupleToArray(triple)\n//=> [ 1, { key: 'value' }, 'string' ]\n\ntupleToArray(constant(triple))()\n//=> [ 1, { key: 'value' }, 'string' ]\n")))}s.isMDXComponent=!0}}]);