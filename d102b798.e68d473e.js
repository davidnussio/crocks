(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{106:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return c})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return p}));var r=t(3),a=t(7),o=(t(0),t(114)),i={title:"Reader",description:"Reader Crock",layout:"guide",weight:110},c={unversionedId:"crocks/Reader",id:"crocks/Reader",isDocsHomePage:!1,title:"Reader",description:"Reader Crock",source:"@site/docs/crocks/Reader.md",slug:"/crocks/Reader",permalink:"/crocks/docs/crocks/Reader",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Reader.md",version:"current",sidebar:"sidebar",previous:{title:"Pred",permalink:"/crocks/docs/crocks/Pred"},next:{title:"ReaderT",permalink:"/crocks/docs/crocks/ReaderT"}},s=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"ask",id:"ask",children:[]},{value:"of",id:"of",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"map",id:"map",children:[]},{value:"ap",id:"ap",children:[]},{value:"chain",id:"chain",children:[]},{value:"runWith",id:"runwith",children:[]}]}],l={toc:s};function p(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Reader e a\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Reader")," is a lazy Product Type that enables the  composition of computations\nthat depend on a shared environment ",Object(o.b)("inlineCode",{parentName:"p"},"(e -> a)"),". The left portion, the ",Object(o.b)("inlineCode",{parentName:"p"},"e")," must\nbe fixed to a type for all related computations. The right portion ",Object(o.b)("inlineCode",{parentName:"p"},"a")," can vary\nin its type."),Object(o.b)("p",null,"As ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," is lazy, wrapping a function of the form ",Object(o.b)("inlineCode",{parentName:"p"},"(e -> a)"),", nothing is\nexecuted until it is run with an environment. ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," provides a method on\nit's instance that will take an environment called ",Object(o.b)("a",{parentName:"p",href:"#runwith"},Object(o.b)("inlineCode",{parentName:"a"},"runWith"))," that\nwill run the instance with a given environment."),Object(o.b)("p",null,"Not only is ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),'\'s environment fixed to a type, but it should be immutable\nfor the "life" computation. If a referential type is used as the environment\ngreat care should be taken to not modify the value of the environment.'),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Reader from 'crocks/Reader'\n\nimport concat from 'crocks/pointfree/concat'\n\nconst { ask } = Reader\n\n// greet :: String -> Reader String String\nconst greet = greeting =>\n  Reader(name => `${greeting}, ${name}`)\n\n// addFarewell :: String -> Reader String String\nconst addFarewell = farewell => str =>\n  ask(env => `${str}${farewell} ${env}`)\n\n// flow :: Reader String String\nconst flow =\n  greet('Hola')\n    .map(concat('...'))\n    .chain(addFarewell('See Ya'))\n\nflow\n  .runWith('Thomas')\n//=> Hola, Thomas...See Ya Thomas\n\nflow\n  .runWith('Jenny')\n//=> Hola, Jenny...See Ya Jenny\n")),Object(o.b)("h2",{id:"implements"},"Implements"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Functor"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Apply"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Chain"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")),Object(o.b)("h2",{id:"construction"},"Construction"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Reader :: (e -> a) -> Reader e a\n")),Object(o.b)("p",null,"The constructor for a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," type is a unary function that requires another\nunary function as its input. After passing the constructor a function, it will\nreturn a new ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," instance. The left type is parameterized by the input, or\ndomain, of the wrapped function. While the right type represents the return\nvalue, or co-domain."),Object(o.b)("p",null,"The left type ",Object(o.b)("inlineCode",{parentName:"p"},"e")," represents a family of ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),"s that can be combined and must\nbe fixed to that type for all valid combination of instances."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Reader from 'crocks/Reader'\nimport setProp from 'crocks/helpers/setProp'\n\n// Reader Object Object\nReader(setProp('animal', 'cat'))\n//=> Reader (Object -> Object)\n\n// Reader a Number\nReader(x => x.length || 0)\n//=> Reader (a -> Number)\n")),Object(o.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(o.b)("h3",{id:"ask"},"ask"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Reader.ask :: () -> Reader e e\nReader.ask :: (e -> b) -> Reader e b\n")),Object(o.b)("p",null,"A construction helper that returns a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," with the environment on the right\nportion of the ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),". ",Object(o.b)("inlineCode",{parentName:"p"},"ask")," can take a function, that can be used to map the\nenvironment to a different type or value."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Reader from 'crocks/Reader'\n\nconst { ask } = Reader\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// Typical constructor\nReader(add(10))\n  .runWith(56)\n//=> 66\n\n// Using `ask` with no function\n// (identity on environment)\nask()\n  .runWith(56)\n//=> 56\n\n// Using `ask` with a function\n// (map environment before deposit)\nask(add(10))\n  .runWith(56)\n//=> 66\n")),Object(o.b)("h3",{id:"of"},"of"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Reader.of :: a -> Reader e a\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"of")," is used to construct a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," with the right portion populated with it's\nargument. ",Object(o.b)("inlineCode",{parentName:"p"},"of")," essentially will lift a value of type ",Object(o.b)("inlineCode",{parentName:"p"},"a")," into a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),", giving\nback a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),' that is "pointed" to the specific value provided. ',Object(o.b)("inlineCode",{parentName:"p"},"of")," makes\nfor a wonderful starting point for some of the more complicated flows."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Reader from 'crocks/Reader'\n\nimport objOf from 'crocks/helpers/objOf'\nimport thrush from 'crocks/combinators/applyTo'\n\nconst { ask } = Reader\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\nReader.of(34)\n  .map(add(6))\n  .runWith()\n//=> 40\n\nReader.of('Bobby')\n  .map(objOf('name'))\n  .runWith()\n//=> { name: 'Bobby' }\n\nReader.of(57)\n  .chain(x => ask(add).map(thrush(x)))\n  .runWith(43)\n//=> 100\n")),Object(o.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(o.b)("h3",{id:"map"},"map"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Reader e a ~> (a -> b) -> Reader e b\n")),Object(o.b)("p",null,"While the left side, or the environment, of the ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," must always be fixed\nto the same type, the right side, or value, of the ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," may vary.\nUsing ",Object(o.b)("inlineCode",{parentName:"p"},"map")," allows a function to be lifted into the ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),", mapping the\nresult into the result of the lifted function."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Reader from 'crocks/Reader'\n\nimport assign from 'crocks/helpers/assign'\nimport B from 'crocks/combinators/composeB'\nimport getProp from 'crocks/Maybe/getProp'\nimport objOf from 'crocks/helpers/objOf'\nimport option from 'crocks/pointfree/option'\n\nconst { ask } = Reader\n\n// length :: Array -> Number\nconst length =\n  x => x.length\n\nask()\n  .map(length)\n  .runWith([ 1, 2, 3 ])\n//=> 3\n\n// propOr :: (String, a) -> b -> a\nconst propOr = (key, def) =>\n  B(option(def), getProp(key))\n\n// lengthObj :: Array -> Object\nconst lengthObj =\n  B(objOf('length'), length)\n\n// addLength :: Object -> Reader Array Object\nconst addLength = x =>\n  ask(propOr('list', []))\n    .map(B(assign(x), lengthObj))\n\nReader.of({ num: 27 })\n  .chain(addLength)\n  .runWith({ list: [ 1, 2, 3 ] })\n//=> { length: 3, num: 27 }\n")),Object(o.b)("h3",{id:"ap"},"ap"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Reader e (a -> b) ~> Reader e a -> Reader e b\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"ap")," allows for values wrapped in a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," to be applied to functions also\nwrapped in a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),". In order to use ",Object(o.b)("inlineCode",{parentName:"p"},"ap"),", the ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," must contain a\nfunction as its value. Under the hood, ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," unwraps both the function\nand the value to be applied and applies the value to the function. Finally it\nwill wrap the result of that application back into a ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),". It is required\nthat the inner function is curried."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Reader from 'crocks/Reader'\n\nimport B from 'crocks/combinators/composeB'\nimport assign from 'crocks/helpers/assign'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport objOf from 'crocks/helpers/objOf'\n\nconst { ask } = Reader\n\n// namePart :: Number -> String -> String\nconst namePart = indx => x =>\n  x.split(' ')[indx] || ''\n\n// combine :: Object -> Reader Object\nconst combine =\n  x => ask(assign(x))\n\n// full :: Reader Object\nconst full =\n  ask(({ full }) => full)\n\n// first :: Reader Object\nconst first =\n  full\n    .map(B(objOf('first'), namePart(0)))\n\n// last :: Reader Object\nconst last =\n  full\n    .map(B(objOf('last'), namePart(1)))\n\n// fluent style\nReader.of(assign)\n  .ap(first)\n  .ap(last)\n  .chain(combine)\n  .runWith({ full: 'Mary Jones' })\n//=> { full: 'Mary Jones', first: 'Mary', last: 'Jones' }\n\n// liftAssign :: Reader Object -> Reader Object -> Reader Object\nconst liftAssign =\n  liftA2(assign)\n\n// using a lift function\nliftAssign(first, last)\n  .chain(combine)\n  .runWith({ full: 'Tom Jennings' })\n//=> { full: 'Tom Jennings', first: 'Tom', last: 'Jennings' }\n")),Object(o.b)("h3",{id:"chain"},"chain"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Reader e a ~> (a -> Reader e b) -> Reader e b\n")),Object(o.b)("p",null,"One of the ways ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),"s like ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," are able to be combined and have their\neffects applied, is by using the ",Object(o.b)("inlineCode",{parentName:"p"},"chain")," method. In the case of ",Object(o.b)("inlineCode",{parentName:"p"},"Reader"),", the\neffect is to read in and make available the shared environment. ",Object(o.b)("inlineCode",{parentName:"p"},"chain")," expects\na function that will take any ",Object(o.b)("inlineCode",{parentName:"p"},"a")," and return a new ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," with a value of ",Object(o.b)("inlineCode",{parentName:"p"},"b"),"."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Reader from 'crocks/Reader'\n\nimport B from 'crocks/combinators/composeB'\nimport getProp from 'crocks/Maybe/getProp'\nimport option from 'crocks/pointfree/option'\n\nconst { ask } = Reader\n\n// multiply :: Number -> Number -> Number\nconst multiply =\n  x => y => x * y\n\n// add :: Number -> Number -> Number\nconst add  =\n  x => y => x + y\n\n// propOr :: (String, a) -> b -> a\nconst propOr = (key, def) =>\n  B(option(def), getProp(key))\n\n// applyScale :: Number -> Reader Object Number\nconst applyScale = x =>\n  ask(propOr('scale', 1))\n    .map(multiply(x))\n\n// applyScale :: Number -> Reader Object Number\nconst applyOffset = x =>\n  ask(propOr('offset', 0))\n    .map(add(x))\n\n// applyTransforms :: Number -> Reader Object Number\nconst applyTransform = x =>\n  Reader.of(x)\n    .chain(applyOffset)\n    .chain(applyScale)\n\napplyTransform(45)\n  .runWith({})\n//=> 45\n\napplyTransform(45)\n  .runWith({ offset: 20 })\n//=> 65\n\napplyTransform(45)\n  .runWith({ scale: 2 })\n//=> 90\n\napplyTransform(45)\n  .runWith({ scale: 2, offset: 20 })\n//=> 130\n")),Object(o.b)("h3",{id:"runwith"},"runWith"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Reader e a ~> e -> a\n")),Object(o.b)("p",null,"As ",Object(o.b)("inlineCode",{parentName:"p"},"Reader")," is a lazy datatype that requires a shared environment to run, it's\ninstance provides a ",Object(o.b)("inlineCode",{parentName:"p"},"runWith")," method that takes in an environment and returns\nthe result of the computation."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Reader from 'crocks/Reader'\nimport Pair from 'crocks/Pair'\n\nimport fst from 'crocks/Pair/fst'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport snd from 'crocks/Pair/snd'\n\nconst { ask } = Reader\n\n// data :: Pair Number Number\nconst data =\n  Pair(20, 45)\n\n// getCorrect :: Reader (Pair Number Number) Number\nconst getCorrect =\n  ask(fst)\n\n// getTotal :: Reader (Pair Number Number) Number\nconst getTotal =\n  ask(snd)\n\n// divide :: Number -> Number -> Number\nconst divide =\n  x => y => x / y\n\n// formatPercent :: Number -> String\nconst formatPercent =\n  x => `${Math.floor(x * 1000) / 10}%`\n\n// calcPercent :: Reader (Pair Number Number) String\nconst calcPercent =\n  liftA2(divide, getCorrect, getTotal)\n    .map(formatPercent)\n\ncalcPercent\n  .runWith(data)\n//=. '44.4%'\n")))}p.isMDXComponent=!0},114:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return u}));var r=t(0),a=t.n(r);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=a.a.createContext({}),p=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},d=function(e){var n=p(e.components);return a.a.createElement(l.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},m=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,u=d["".concat(i,".").concat(m)]||d[m]||b[m]||o;return t?a.a.createElement(u,c(c({ref:n},l),{},{components:t})):a.a.createElement(u,c({ref:n},l))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var l=2;l<o;l++)i[l]=t[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);