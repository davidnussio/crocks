(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{100:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var b=r.a.createContext({}),l=function(e){var t=r.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.a.createElement(b.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),p=l(n),u=a,d=p["".concat(s,".").concat(u)]||p[u]||m[u]||i;return n?r.a.createElement(d,o(o({ref:t},b),{},{components:n})):r.a.createElement(d,o({ref:t},b))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var b=2;b<i;b++)s[b]=n[b];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},88:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return l}));var a=n(2),r=n(6),i=(n(0),n(100)),s={title:"Last",description:"Last Monoid",layout:"guide",weight:60},o={unversionedId:"monoids/Last",id:"monoids/Last",isDocsHomePage:!1,title:"Last",description:"Last Monoid",source:"@site/docs/monoids/Last.md",slug:"/monoids/Last",permalink:"/crocks/docs/monoids/Last",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/monoids/Last.md",version:"current",sidebar:"sidebar",previous:{title:"First",permalink:"/crocks/docs/monoids/First"},next:{title:"Max",permalink:"/crocks/docs/monoids/Max"}},c=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"empty",id:"empty",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"equals",id:"equals",children:[]},{value:"concat",id:"concat",children:[]},{value:"option",id:"option",children:[]},{value:"valueOf",id:"valueof",children:[]}]},{value:"Transformation Functions",id:"transformation-functions",children:[{value:"eitherToLast",id:"eithertolast",children:[]},{value:"firstToLast",id:"firsttolast",children:[]},{value:"maybeToLast",id:"maybetolast",children:[]},{value:"resultToLast",id:"resulttolast",children:[]}]}],b={rightToc:c};function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Last a = Last (Maybe a)\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Last")," is a ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid")," that will always return the last, non-empty value when\ntwo ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instances are combined. ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," is able to be a ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid")," because\nit implements a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," under the hood. The use of the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," allows for an\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#empty"}),Object(i.b)("inlineCode",{parentName:"a"},"empty"))," ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," to be represented with a ",Object(i.b)("inlineCode",{parentName:"p"},"Nothing"),"."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Last")," can be constructed with either a value or a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," instance. Any value\npassed to the constructor will be wrapped in a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe#just"}),Object(i.b)("inlineCode",{parentName:"a"},"Just"))," to represent a non-empty\ninstance of ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),". Any ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe")),' passed to the constructor will be lifted as\nis, allowing the ability to "choose" a value based on some disjunction.'),Object(i.b)("p",null,"While most ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid"),"s only provide a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#valueof"}),Object(i.b)("inlineCode",{parentName:"a"},"valueOf"))," function used for\nextraction, ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," takes advantage of its underlying ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," to provide an\nadditional ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#option"}),Object(i.b)("inlineCode",{parentName:"a"},"option"))," method. Using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#valueof"}),Object(i.b)("inlineCode",{parentName:"a"},"valueOf"))," will extract\nthe underlying ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe")),", while ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#option"}),Object(i.b)("inlineCode",{parentName:"a"},"option"))," will extract the underlying\nvalue in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe")),", using the provided default value when the underlying\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," is a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe#nothing"}),Object(i.b)("inlineCode",{parentName:"a"},"Nothing"))," instance."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\n\nimport and from 'crocks/logic/and'\nimport isNumber from 'crocks/predicates/isNumber'\nimport mconcatMap from 'crocks/helpers/mconcatMap'\nimport safe from 'crocks/Maybe/safe'\n\n// isEven :: Number -> Boolean\nconst isEven =\n  x => x % 2 === 0\n\n// isValid :: a -> Boolean\nconst isValid =\n  and(isNumber, isEven)\n\n// chooseLast :: [ * ] -> Last Number\nconst chooseLast =\n  mconcatMap(Last, safe(isValid))\n\nchooseLast([ 21, 45, 2, 22, 19 ])\n  .valueOf()\n//=> Just 22\n\nchooseLast([ 'a', 'b', 'c' ])\n  .option('')\n//=> \"\"\n")),Object(i.b)("h2",{id:"implements"},"Implements"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Setoid"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid")),Object(i.b)("h2",{id:"construction"},"Construction"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Last :: a -> Last (Maybe a)\nLast :: Maybe a -> Last (Maybe a)\n")),Object(i.b)("p",null,"A ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instance can be constructed by passing either a direct (unwrapped)\nvalue ",Object(i.b)("inlineCode",{parentName:"p"},"a")," or a ",Object(i.b)("inlineCode",{parentName:"p"},"Maybe a")," to the constructor. When a direct value is passed, the\nconstructor will always wrap the value in a ",Object(i.b)("inlineCode",{parentName:"p"},"Just")," and return a\nnew ",Object(i.b)("inlineCode",{parentName:"p"},"Last Just a")," instance."),Object(i.b)("p",null,"Alternatively, by passing a ",Object(i.b)("inlineCode",{parentName:"p"},"Maybe a"),", the user can programmatically provide an\nempty case to a given ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," by passing a ",Object(i.b)("inlineCode",{parentName:"p"},"Nothing"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\nimport Maybe from 'crocks/Maybe'\n\nconst { Just, Nothing } = Maybe\n\nLast(Just([ 1, 2, 3 ]))\n//=> Last( Just [ 1, 2, 3 ] )\n\nLast(Nothing())\n//=> Last( Nothing )\n\nLast(null)\n//=> Last( Just null )\n\nLast(false)\n//=> Last( Just false )\n")),Object(i.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(i.b)("h3",{id:"empty"},"empty"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Last.empty :: () -> Last a\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"empty")," provides the identity for the ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid")," in that when the value it\nprovides is ",Object(i.b)("inlineCode",{parentName:"p"},"concat"),"ed to any other value, it will return the other value. In\nthe case of ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," the result of ",Object(i.b)("inlineCode",{parentName:"p"},"empty")," is ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe#nothing"}),Object(i.b)("inlineCode",{parentName:"a"},"Nothing")),". ",Object(i.b)("inlineCode",{parentName:"p"},"empty")," is available\non both the Constructor and the Instance for convenience."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\n\nconst { empty } = Last\n\nempty()\n//=> Last( Nothing )\n\nLast(3)\n  .concat(empty())\n//=> Last( Just 3 )\n\nempty()\n  .concat(Last(3))\n//=> Last( Just 3 )\n")),Object(i.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(i.b)("h3",{id:"equals"},"equals"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Last a ~> b -> Boolean\n")),Object(i.b)("p",null,"Used to compare the underlying values of two ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instances for equality by\nvalue, ",Object(i.b)("inlineCode",{parentName:"p"},"equals")," takes any given argument and returns ",Object(i.b)("inlineCode",{parentName:"p"},"true")," if the passed argument\nis a ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," with an underlying value equal to the underlying value of\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," the method is being called on. If the passed argument is not\na ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," or the underlying values are not equal, ",Object(i.b)("inlineCode",{parentName:"p"},"equals")," will return ",Object(i.b)("inlineCode",{parentName:"p"},"false"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\n\nimport Maybe from 'crocks/Maybe'\n\nLast(33)\n  .equals(Last(33))\n//=> true\n\nLast(42)\n  .equals(Last(10))\n//=> false\n\nLast({ a: 5 })\n  .equals({ a: 5 })\n//=> false\n\nLast(95)\n  .equals(95)\n//=> false\n\nLast(95)\n  .equals(Maybe.of(95))\n//=> false\n")),Object(i.b)("h3",{id:"concat"},"concat"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Last a ~> Last a -> Last a\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"concat")," is used to combine two ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),"s of the same type under an operation\nspecified by the ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),". In the case of ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),", it will always provide the\nlast non-empty value. All previous non-empty values will be thrown away and\nwill always result in the last non-empty value."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\nimport concat from 'crocks/pointfree/concat'\n\nconst a = Last('a')\nconst b = Last('b')\nconst c = Last('c')\n\na.concat(b)\n//=> Last( Just \"b\" )\n\nb.concat(a)\n//=> Last( Just \"a\" )\n\nconcat(c, concat(b, a))\n//=> Last( Just \"c\" )\n\nconcat(concat(c, b), a)\n//=> Last( Just \"c\" )\n\nconcat(concat(a, b), c)\n//=> Last( Just \"a\" )\n")),Object(i.b)("h3",{id:"option"},"option"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Last a ~> a -> a\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Last")," wraps an underlying ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," which provides the ability to option out\na value in the case of an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#empty"}),Object(i.b)("inlineCode",{parentName:"a"},"empty"))," instance. Just like ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe#option"}),Object(i.b)("inlineCode",{parentName:"a"},"option"))," on\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," instance, it takes a value as its argument. When run on\nan ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#empty"}),Object(i.b)("inlineCode",{parentName:"a"},"empty"))," instance, the provided default will be returned.\nIf ",Object(i.b)("inlineCode",{parentName:"p"},"option")," is run on a non-empty instance however, the wrapped value will be\nextracted not only from the ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," but also from the underlying ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe#just"}),Object(i.b)("inlineCode",{parentName:"a"},"Just")),"."),Object(i.b)("p",null,"If the underlying ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," is desired, the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#valueof"}),Object(i.b)("inlineCode",{parentName:"a"},"valueOf"))," method can be\nused and will return the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," instead."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\n\nimport compose from 'crocks/helpers/compose'\nimport chain from 'crocks/pointfree/chain'\nimport getProp from 'crocks/Maybe/getProp'\nimport isString from 'crocks/predicates/isString'\nimport mconcatMap from 'crocks/helpers/mconcatMap'\nimport safe from 'crocks/Maybe/safe'\n\n// stringVal :: a -> Maybe String\nconst stringVal = compose(\n  chain(safe(isString)),\n  getProp('val')\n)\n\n// lastValid :: [ a ] -> Last String\nconst lastValid =\n  mconcatMap(Last, stringVal)\n\n// good :: [ Object ]\nconst good =\n  [ { val: 23 }, { val: 'string' }, { val: '23' } ]\n\n// bad :: [ Object ]\nconst bad =\n  [ { val: 23 }, { val: null }, {} ]\n\nlastValid(good)\n  .option('')\n//=> \"23\"\n\nlastValid(bad)\n  .option('')\n//=> \"\"\n")),Object(i.b)("h3",{id:"valueof"},"valueOf"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Last a ~> () -> Maybe a\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"valueOf")," is used on all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," ",Object(i.b)("inlineCode",{parentName:"p"},"Monoid"),"s as a means of extraction. While the\nextraction is available, types that implement ",Object(i.b)("inlineCode",{parentName:"p"},"valueOf")," are not necessarily\na ",Object(i.b)("inlineCode",{parentName:"p"},"Comonad"),". This function is used primarily for convenience for some of the\nhelper functions that ship with ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),". Calling ",Object(i.b)("inlineCode",{parentName:"p"},"valueOf")," on a ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instance\nwill result in the underlying ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe")),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\n\nimport Maybe from 'crocks/Maybe'\nimport valueOf from 'crocks/pointfree/valueOf'\n\nconst { Nothing } = Maybe\n\nvalueOf(Last(56))\n//=> Just 56\n\nvalueOf(Last.empty())\n//=> Nothing\n\nLast(37)\n  .concat(Last(99))\n  .valueOf()\n//=> Just 99\n\nLast(Nothing())\n  .concat(Last.empty())\n  .valueOf()\n//=> Nothing\n")),Object(i.b)("h2",{id:"transformation-functions"},"Transformation Functions"),Object(i.b)("h3",{id:"eithertolast"},"eitherToLast"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Last/eitherToLast")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"eitherToLast :: Either b a -> Last a\neitherToLast :: (a -> Either c b) -> a -> Last b\n")),Object(i.b)("p",null,"Used to transform a given ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either"}),Object(i.b)("inlineCode",{parentName:"a"},"Either"))," instance to\na ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instance, ",Object(i.b)("inlineCode",{parentName:"p"},"eitherToLast")," will turn a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right"))," instance into a\nnon-empty ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),", wrapping the original value contained in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either#right"}),Object(i.b)("inlineCode",{parentName:"a"},"Right")),".\nAll ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," instances will map to an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#empty"}),Object(i.b)("inlineCode",{parentName:"a"},"empty"))," ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),", mapping\nthe originally contained value to a ",Object(i.b)("inlineCode",{parentName:"p"},"Unit"),". Values on the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either#left"}),Object(i.b)("inlineCode",{parentName:"a"},"Left"))," will\nbe lost and as such this transformation is considered lossy in that regard."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"eitherToLast")," has two possible\nsignatures and will behave differently when passed either an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either"}),Object(i.b)("inlineCode",{parentName:"a"},"Either"))," instance\nor a function that returns an instance of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either"}),Object(i.b)("inlineCode",{parentName:"a"},"Either")),". When passed the instance,\na transformed ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," is returned. When passed an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either"}),Object(i.b)("inlineCode",{parentName:"a"},"Either"))," returning function,\na function will be returned that takes a given value and returns a ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\nimport Either from 'crocks/Either'\nimport eitherToLast from 'crocks/Last/eitherToLast'\n\nimport concat from 'crocks/pointfree/concat'\nimport constant from 'crocks/combinators/constant'\nimport flip from 'crocks/combinators/flip'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport mapReduce from 'crocks/helpers/mapReduce'\n\nconst { Left, Right } = Either\n\n// someNumber :: a -> Either String Number\nconst someNumber = ifElse(\n  isNumber,\n  Right,\n  constant(Left('Nope'))\n)\n\n// lastNumber :: [ a ] -> Last Number\nconst lastNumber = mapReduce(\n  eitherToLast(someNumber),\n  flip(concat),\n  Last.empty()\n)\n\n// \"Bad Times\" is lost, mapped to Nothing\neitherToLast(Left('Bad Times'))\n//=> Last( Nothing )\n\neitherToLast(Right('correct'))\n//=> Last( Just \"correct\" )\n\nlastNumber([ 'string', null, 34, 76 ])\n//=> Last( Just 76 )\n\nlastNumber([ 'string', null, true ])\n//=> Last( Nothing )\n")),Object(i.b)("h3",{id:"firsttolast"},"firstToLast"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Last/firstToLast")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"firstToLast :: First a -> Last a\nfirstToLast :: (a -> First b) -> a -> Last b\n")),Object(i.b)("p",null,"Used to transform a given ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./First"}),Object(i.b)("inlineCode",{parentName:"a"},"First"))," instance to\na ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instance, ",Object(i.b)("inlineCode",{parentName:"p"},"firstToLast")," will turn a non-empty instance into a\nnon-empty ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," wrapping the original value contained within\nthe ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./First"}),Object(i.b)("inlineCode",{parentName:"a"},"First")),". All ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#empty"}),Object(i.b)("inlineCode",{parentName:"a"},"empty"))," instances will map to\nan ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#empty"}),Object(i.b)("inlineCode",{parentName:"a"},"empty"))," ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),"."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"firstToLast")," has two possible\nsignatures and will behave differently when passed either\na ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./First"}),Object(i.b)("inlineCode",{parentName:"a"},"First"))," instance or a function that returns an instance\nof ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./First"}),Object(i.b)("inlineCode",{parentName:"a"},"First")),". When passed the instance, a transformed ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," is returned.\nWhen passed a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./First"}),Object(i.b)("inlineCode",{parentName:"a"},"First"))," returning function, a function will be returned\nthat takes a given value and returns a ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last  from 'crocks/Last'\nimport First from 'crocks/First'\nimport firstToLast from 'crocks/Last/firstToLast'\n\nimport isString from 'crocks/predicates/isString'\nimport mconcatMap from 'crocks/helpers/mconcatMap'\nimport safe from 'crocks/Maybe/safe'\n\n// firstString :: [ a ] -> First String\nconst firstString =\n  mconcatMap(First, safe(isString))\n\n// unfixFirstString :: [ a ] -> Last String\nconst unfixFirstString =\n  firstToLast(firstString)\n\nfirstToLast(First.empty())\n//=> Last( Nothing )\n\nfirstToLast(First(false))\n//=> Last( Just false )\n\nunfixFirstString([ 'one', 2, 'Three', 4 ])\n//=> Last( Just \"one\" )\n\nunfixFirstString([ 'one', 2, 'Three', 4 ])\n  .concat(Last('another string'))\n//=> Last( Just \"another string\" )\n\nunfixFirstString([ 1, 2, 3, 4 ])\n  .concat(Last('Last String'))\n//=> Last( Just \"Last String\" )\n")),Object(i.b)("h3",{id:"maybetolast"},"maybeToLast"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Last/maybeToLast")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"maybeToLast :: Maybe a -> Last a\nmaybeToLast :: (a -> Maybe b) -> a -> Last b\n")),Object(i.b)("p",null,"Used to transform a given ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," instance to\na ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instance, ",Object(i.b)("inlineCode",{parentName:"p"},"maybeToLast")," will turn a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe#just"}),Object(i.b)("inlineCode",{parentName:"a"},"Just"))," into a\nnon-empty ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instance, wrapping the original value contained within\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),". All ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe#nothing"}),Object(i.b)("inlineCode",{parentName:"a"},"Nothing"))," instances will map to\nan ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#empty"}),Object(i.b)("inlineCode",{parentName:"a"},"empty"))," ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instance."),Object(i.b)("p",null,"This function is available mostly for completion sake, as ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," can always\ntake a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," as its argument during construction. So while there is not a\nreal need for this to be used for transforming instances, it can come in\nhandy for lifting ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," returning functions."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"maybeToLast")," has two possible\nsignatures and will behave differently when passed either a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," instance\nor a function that returns an instance of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe")),". When passed the instance,\na transformed ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," is returned. When passed a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(i.b)("inlineCode",{parentName:"a"},"Maybe"))," returning function,\na function will be returned that takes a given value and returns a ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\nimport Maybe from 'crocks/Maybe'\nimport maybeToLast from 'crocks/Last/maybeToLast'\n\nimport chain from 'crocks/pointfree/chain'\nimport compose from 'crocks/helpers/compose'\nimport getProp from 'crocks/Maybe/getProp'\nimport isNumber from 'crocks/predicates/isNumber'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Nothing, Just } = Maybe\n\n// numVal :: a -> Maybe Number\nconst numVal = compose(\n  chain(safe(isNumber)),\n  getProp('val')\n)\n\n// lastNumVal :: a -> Last Number\nconst lastNumVal =\n  maybeToLast(numVal)\n\nmaybeToLast(Just(99))\n//=> Last( Just 99 )\n\nmaybeToLast(Nothing())\n//=> Last( Nothing )\n\nLast(Just(99))\n//=> Last( Just 99 )\n\nLast(Nothing())\n//=> Last( Nothing )\n\nLast(Just(80))\n  .concat(lastNumVal({ val: 97 }))\n//=> Last( Just 97 )\n\nlastNumVal({ val: 97 })\n  .concat(Last(80))\n//=> Last( Just 80 )\n\nlastNumVal(null)\n  .concat(Last(80))\n//=> Last( Just 80 )\n")),Object(i.b)("h3",{id:"resulttolast"},"resultToLast"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Last/resultToLast")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"resultToLast :: Result e a -> Last a\nresultToLast :: (a -> Result e b) -> a -> Last b\n")),Object(i.b)("p",null,"Used to transform a given ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result"))," instance to a ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," instance,\n",Object(i.b)("inlineCode",{parentName:"p"},"resultToLast")," will turn an ",Object(i.b)("inlineCode",{parentName:"p"},"Ok")," instance into a non-empty ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),",\nwrapping the original value contained in the ",Object(i.b)("inlineCode",{parentName:"p"},"Ok"),". All ",Object(i.b)("inlineCode",{parentName:"p"},"Err")," instances will map\nto an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#empty"}),Object(i.b)("inlineCode",{parentName:"a"},"empty"))," ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),", mapping the originally contained value to\na ",Object(i.b)("inlineCode",{parentName:"p"},"Unit"),". Values on the ",Object(i.b)("inlineCode",{parentName:"p"},"Err")," will be lost and as such this transformation is\nconsidered lossy in that regard."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"resultToLast")," has two possible\nsignatures and will behave differently when passed either an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result"))," instance\nor a function that returns an instance of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result")),". When passed the instance,\na transformed ",Object(i.b)("inlineCode",{parentName:"p"},"Last")," is returned. When passed a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Result"}),Object(i.b)("inlineCode",{parentName:"a"},"Result"))," returning function,\na function will be returned that takes a given value and returns a ",Object(i.b)("inlineCode",{parentName:"p"},"Last"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Last from 'crocks/Last'\nimport Result from 'crocks/Result'\nimport resultToLast from 'crocks/Last/resultToLast'\n\nimport isNumber from 'crocks/predicates/isNumber'\nimport tryCatch from 'crocks/Result/tryCatch'\n\nconst { Err, Ok } = Result\n\nfunction onlyNums(x) {\n  if(!isNumber(x)) {\n    throw new Error('something amiss')\n  }\n  return x\n}\n\n// lastNum :: a -> Last Number\nconst lastNum =\n  resultToLast(tryCatch(onlyNums))\n\n// \"this is bad\" is lost, mapped to Nothing\nresultToLast(Err('this is bad'))\n//=> Last( Nothing )\n\nresultToLast(Ok('this is great'))\n//=> Last( Just \"this is great\" )\n\nlastNum(90)\n  .concat(Last(0))\n//=> Last( Just 0 )\n\nlastNum(null)\n  .concat(Last(0))\n//=> Last( Just 0 )\n")))}l.isMDXComponent=!0}}]);