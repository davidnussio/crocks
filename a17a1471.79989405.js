(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{100:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return O}));var r=t(0),a=t.n(r);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var b=a.a.createContext({}),l=function(e){var n=a.a.useContext(b),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},p=function(e){var n=l(e.components);return a.a.createElement(b.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},u=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,b=s(e,["components","mdxType","originalType","parentName"]),p=l(t),u=r,O=p["".concat(i,".").concat(u)]||p[u]||m[u]||o;return t?a.a.createElement(O,c(c({ref:n},b),{},{components:t})):a.a.createElement(O,c({ref:n},b))}));function O(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var b=2;b<o;b++)i[b]=t[b];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},84:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return l}));var r=t(2),a=t(6),o=(t(0),t(100)),i={title:"Result",description:"Result Crock",layout:"guide",functions:["trycatch","eithertoresult","firsttoresult","lasttoresult","maybetoresult"],weight:130},c={unversionedId:"crocks/Result",id:"crocks/Result",isDocsHomePage:!1,title:"Result",description:"Result Crock",source:"@site/docs/crocks/Result.md",slug:"/crocks/Result",permalink:"/crocks/docs/crocks/Result",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Result.md",version:"current",sidebar:"sidebar",previous:{title:"ReaderT",permalink:"/crocks/docs/crocks/ReaderT"},next:{title:"State",permalink:"/crocks/docs/crocks/State"}},s=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"Err",id:"err",children:[]},{value:"Ok",id:"ok",children:[]},{value:"of",id:"of",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"equals",id:"equals",children:[]},{value:"concat",id:"concat",children:[]},{value:"map",id:"map",children:[]},{value:"alt",id:"alt",children:[]},{value:"bimap",id:"bimap",children:[]},{value:"ap",id:"ap",children:[]},{value:"sequence",id:"sequence",children:[]},{value:"traverse",id:"traverse",children:[]},{value:"chain",id:"chain",children:[]},{value:"coalesce",id:"coalesce",children:[]},{value:"bichain",id:"bichain",children:[]},{value:"swap",id:"swap",children:[]},{value:"either",id:"either",children:[]}]},{value:"Helper Functions",id:"helper-functions",children:[{value:"tryCatch",id:"trycatch",children:[]}]},{value:"Transformation Functions",id:"transformation-functions",children:[{value:"eitherToResult",id:"eithertoresult",children:[]},{value:"firstToResult",id:"firsttoresult",children:[]},{value:"lastToResult",id:"lasttoresult",children:[]},{value:"maybeToResult",id:"maybetoresult",children:[]}]}],b={rightToc:s};function l(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},b,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a = Err e | Ok a\n")),Object(o.b)("p",null,"Result is a Sum Type similar to that of ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either"))," with the added\nbehaviour of accumulating the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," when using ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ap"}),Object(o.b)("inlineCode",{parentName:"a"},"ap"))," or ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#alt"}),Object(o.b)("inlineCode",{parentName:"a"},"alt")),".\nWith ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either"))," being defined as a tagged union type, it captures the\nessence of disjunction as it provides either a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either#left"}),Object(o.b)("inlineCode",{parentName:"a"},"Left"))," value or\na ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either#right"}),Object(o.b)("inlineCode",{parentName:"a"},"Right"))," value but not both. With a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," the left contains the\nerror information from an operation and the right contains the result.\n",Object(o.b)("inlineCode",{parentName:"p"},"Result"),' is well suited for capturing disjunction when the cause of the "error"\ncase needs to be communicated. For example, when executing a function and you\nexception is important or useful.'),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," represents disjunction by using two constructors, ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," and ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),".\nAn ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," instance represents the positive result while ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," is\nconsidered the negative. With the exception\nof",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#coalesce"}),Object(o.b)("inlineCode",{parentName:"a"},"coalesce")),", ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#swap"}),Object(o.b)("inlineCode",{parentName:"a"},"swap"))," and ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#bimap"}),Object(o.b)("inlineCode",{parentName:"a"},"bimap")),", all ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," returning\nmethods on an instance will be applied to an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," returning the result.\nIf an instance is an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),", then all application is skipped and\nanother ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," instance is returned with the same containing value."),Object(o.b)("p",null,"It is recommended to use the available ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," and ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," constructors\nto construct ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instances in most cases. You can use the ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," constructor\nto construct an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),", but it will read better to just use ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport and from 'crocks/logic/and'\nimport bimap from 'crocks/pointfree/bimap'\nimport composeB from 'crocks/combinators/composeB'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport liftA2 from 'crocks/helpers/liftA2'\n\nconst { Err, Ok } = Result\n\n// gte :: Number -> Number -> Boolean\nconst gte = y => x =>\n  x >= y\n\n// lte :: Number -> Number -> Boolean\nconst lte = y => x =>\n  x <= y\n\n// between :: (Number, Number) -> Boolean\nconst between = (x, y) =>\n  and(gte(x), lte(y))\n\n// ensure :: (a -> Boolean) -> a -> Result a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// inRange :: Number -> Result\nconst inRange =\n  ensure(between(10, 15))\n\ninRange(12)\n//=> Ok 12\n\ninRange(25)\n//=> Err 25\n\ninRange('Test')\n//=> Err \"Test\"\n\n// ensureNumber :: a -> Result [a] a\nconst ensureNumber = composeB(\n  bimap(x => [ x ], x => x),\n  ensure(isNumber)\n)\n\n// prod :: Number -> Number -> Number\nconst prod = a => b =>\n  a * b\n\nensureNumber('Not a number 1')\n  .alt(ensureNumber('Not a number 2'))\n//=> Err [ \"Not a number 1\", \"Not a number 2\" ]\n\nliftA2(\n  prod,\n  ensureNumber('Not 21'),\n  ensureNumber('Not 2')\n)\n//=> Err [ \"Not 21\", \"Not 2\" ]\n\nliftA2(\n  prod,\n  ensureNumber(21),\n  ensureNumber(2)\n)\n//=> Ok 42\n")),Object(o.b)("h2",{id:"implements"},"Implements"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Setoid"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Functor"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Alt"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Apply"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Traversable"),",\n",Object(o.b)("inlineCode",{parentName:"p"},"Chain"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")),Object(o.b)("h2",{id:"construction"},"Construction"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result :: a -> Result e a\n")),Object(o.b)("p",null,"Most of the time, ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," is constructed using functions of your own making\nand helper functions like ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#trycatch"}),Object(o.b)("inlineCode",{parentName:"a"},"tryCatch"))," or by employing one of the\ninstance constructors, ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," or ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),". This is due to the nature\nof ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," and most other Sum Types."),Object(o.b)("p",null,"As a matter of consistency and completion, a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance can also be\nconstructed using its TypeRep like any other type. The ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," constructor is\na unary function that accepts any type ",Object(o.b)("inlineCode",{parentName:"p"},"a")," and returns a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," instance,\nwrapping the value passed to its argument."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport equals from 'crocks/pointfree/equals'\n\nconst { Ok, Err, of } = Result\n\nResult('some string')\n//=> Ok \"some string\"\n\nResult(null)\n//=> Ok null\n\nResult(undefined)\n//=> Ok undefined\n\nof('some string')\n//=> Ok \"some string\"\n\nof(null)\n//=> Ok null\n\nof(undefined)\n//=> Ok undefined\n\nOk('some string')\n//=> Ok \"some string\"\n\nOk(null)\n//=> Ok null\n\nOk(undefined)\n//=> Ok undefined\n\nErr('some string')\n//=> Err \"some string\"\n\nErr(null)\n//=> Err null\n\nErr(undefined)\n//=> Err undefined\n\nequals(\n  Result.Ok([ 1, 2, 3 ]),\n  Result.of([ 1, 2, 3 ])\n)\n//=> true\n\nequals(\n  of({ a: 100 }),\n  Result({ a: 100 })\n)\n//=> true\n")),Object(o.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(o.b)("h3",{id:"err"},"Err"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result.Err :: e -> Result e a\n")),Object(o.b)("p",null,"Used to construct an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),' instance that represents the "false" portion\nof a disjunction. When an instance is an ',Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),", most ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," returning\nmethods will just return a new ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," instance with the same containing\nvalue."),Object(o.b)("p",null,"The power of the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," as opposed to a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either#left"}),Object(o.b)("inlineCode",{parentName:"a"},"Left"))," or a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe#nothing"}),Object(o.b)("inlineCode",{parentName:"a"},"Nothing"))," is\nthat it can hold meaningful information on why the flow is in this path. It will\nalso accumulate this information when ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ap"}),Object(o.b)("inlineCode",{parentName:"a"},"ap"))," or ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#alt"}),Object(o.b)("inlineCode",{parentName:"a"},"alt"))," are used. This works as a\ncore tool when using Railway Orientated Programming concepts."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport bimap from 'crocks/pointfree/bimap'\nimport chain from 'crocks/pointfree/chain'\nimport composeB from 'crocks/combinators/composeB'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\n\nconst { Ok, Err } = Result\n\n// ensure :: (a -> Boolean) -> a -> Result a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// buildError :: () -> String\nconst buildError = () =>\n  'The value given was not a valid number'\n\n// add10 :: Number -> Number\nconst add10 =\n  x => x + 10\n\n// protectedAdd10 :: a -> Result String Number\nconst protectedAdd10 = composeB(\n  bimap(buildError, add10),\n  ensure(isNumber)\n)\n\nErr(undefined)\n//=> Err undefined\n\nErr(null)\n//=> Err null\n\nErr(23)\n  .map(add10)\n//=> Err 23\n\nOk(23)\n  .map(add10)\n//=> Ok 33\n\nchain(protectedAdd10, Err('number'))\n//=> Err \"number\"\n\nchain(protectedAdd10, Ok(10))\n//=> Ok 20\n")),Object(o.b)("h3",{id:"ok"},"Ok"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result.Ok :: a -> Result e a\n")),Object(o.b)("p",null,"Used to construct an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),' instance that represents the "true" portion of\na disjunction or a valid value. ',Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," will wrap any given value in an\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),", signaling the validity of the wrapped value."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport bimap from 'crocks/pointfree/bimap'\nimport composeB from 'crocks/combinators/composeB'\nimport identity from 'crocks/combinators/identity'\nimport ifElse from 'crocks/logic/ifElse'\nimport isString from 'crocks/predicates/isString'\nimport map from 'crocks/pointfree/map'\n\nconst { Ok, Err } = Result\n\n// ensure :: (a -> Boolean) -> a -> Result a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// buildError :: () -> String\nconst buildError = () =>\n  'The value given is not a valid string'\n\n// ensureString :: a -> Result String Number\nconst ensureString = composeB(\n  bimap(buildError, identity),\n  ensure(isString)\n)\n\n// toUpper :: String -> String\nconst toUpper =\n  x => x.toUpperCase()\n\nOk(32)\n//=> Ok 32\n\nOk(undefined)\n//=> Ok undefined\n\nOk(null)\n//=> Ok null\n\n// safeShout :: a -> Result String\nconst safeShout = composeB(\n  map(toUpper),\n  ensureString\n)\n\nsafeShout(45)\n//=> Err \"The value given is not a valid string\"\n\nsafeShout('Hey there!')\n//=> Ok \"HEY THERE!\"\n")),Object(o.b)("h3",{id:"of"},"of"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result.of :: a -> Result e a\n")),Object(o.b)("p",null,"Used to wrap any value into a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," as an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),", ",Object(o.b)("inlineCode",{parentName:"p"},"of"),' is used mostly\nby helper functions that work "generically" with instances of\neither ',Object(o.b)("inlineCode",{parentName:"p"},"Applicative")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")," types. When working specifically with\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," type, the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," constructor should be used. Reach for ",Object(o.b)("inlineCode",{parentName:"p"},"of")," when\nworking with functions that will work with ANY ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative"),"/",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nconst { Ok, of } = Result\n\nof('Some result!')\n//=> Ok \"Some result!\"\n\nof(undefined)\n//=> Ok undefined\n\nOk('Some result!')\n//=> Ok \"Some result!\"\n\nOk(undefined)\n//=> Ok undefined\n\nResult('Some result!')\n//=> Ok \"Some result!\"\n\nResult(undefined)\n//=> Ok undefined\n")),Object(o.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(o.b)("h3",{id:"equals"},"equals"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a ~> b -> Boolean\n")),Object(o.b)("p",null,"Used to compare the contained values of two ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instances for equality by\nvalue. ",Object(o.b)("inlineCode",{parentName:"p"},"equals")," takes any given argument and returns ",Object(o.b)("inlineCode",{parentName:"p"},"true")," if the passed\nargument is a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," (",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," or ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),") with a contained value\nequal to the contained value of the ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," the method is being called on. If\nthe passed argument is not a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," or the contained values are not equal by\nvalue then ",Object(o.b)("inlineCode",{parentName:"p"},"equals")," will return ",Object(o.b)("inlineCode",{parentName:"p"},"false"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport equals from 'crocks/pointfree/equals'\n\nconst { Ok, Err } = Result\n\nOk('result')\n  .equals(Ok('result'))\n//=> true\n\nOk(null)\n  .equals(Ok(null))\n//=> true\n\nOk('error')\n  .equals(Err('error'))\n//=> false\n\n// by value, not reference for most types\nOk([ 1, { a: 2 }, 'string' ])\n  .equals(Ok([ 1, { a: 2 }, 'string' ]))\n//=> true\n\nequals(Ok('result'), 'result')\n//=> false\n")),Object(o.b)("h3",{id:"concat"},"concat"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Semigroup s => Result e s ~> Result e s -> Result e s\n")),Object(o.b)("p",null,"When an underlying value of a given ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," is fixed to a ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(o.b)("inlineCode",{parentName:"p"},"concat")," can\nbe used to concat another ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance with an underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroup")," of\nthe same type. Expecting a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," wrapping a ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroup")," of the same\ntype, ",Object(o.b)("inlineCode",{parentName:"p"},"concat")," will give back a new ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance wrapping the result of\ncombining the two underlying ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroup"),"s. When called on\na ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," instance, ",Object(o.b)("inlineCode",{parentName:"p"},"concat")," will return an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," with the value\nof the first ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," in the chain."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport concat from 'crocks/pointfree/concat'\n\nconst { Ok, Err } = Result\n\nOk([ 1, 2, 3 ])\n  .concat(Ok([ 4, 5, 6 ]))\n//=> [ 1, 2, 3, 4, 5, 6 ]\n\nOk([ 1, 2, 3 ])\n  .concat(Err([ 4, 5, 6 ]))\n//=> Err [ 4, 5, 6 ]\n\nconcat(Ok('Result'), Err('Error'))\n//=> Err \"Error\"\n\nconcat(Err('Error'), Ok('Result'))\n//=> Err \"Error\"\n\nconcat(Err('Error 1'), Err('Error 2'))\n//=> Err \"Error 2\"\n")),Object(o.b)("h3",{id:"map"},"map"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a ~> (a -> b) -> Result e b\n")),Object(o.b)("p",null,"Used to apply transformations to values in the safety of a ",Object(o.b)("inlineCode",{parentName:"p"},"Result"),", ",Object(o.b)("inlineCode",{parentName:"p"},"map")," takes\na function that it will lift into the context of the ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," and apply to it\nthe wrapped value. When run on an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," instance, ",Object(o.b)("inlineCode",{parentName:"p"},"map")," will apply the\nwrapped value to the provided function and return the result in a new ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),"\ninstance. When run on an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),"'Err'")," ",Object(o.b)("inlineCode",{parentName:"p"},"map")," with return the error value in a new\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," instance."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport assign from 'crocks/helpers/assign'\nimport compose from 'crocks/helpers/compose'\nimport composeB from 'crocks/combinators/composeB'\nimport fanout from 'crocks/Pair/fanout'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\nimport merge from 'crocks/pointfree/merge'\nimport objOf from 'crocks/helpers/objOf'\n\nconst { Ok, Err } = Result\n\n// buildError :: () -> Result String a\nconst buildError = () =>\n  Err('The value given was not a valid number')\n\n// double :: Number -> Number\nconst double =\n  x => x * 2\n\n// fromNumber :: a -> Result String Number\nconst fromNumber =\n  ifElse(isNumber, Ok, buildError)\n\n// doubleNumber :: a -> Result String Number\nconst doubleNumber = composeB(\n  map(double),\n  fromNumber\n)\n\ndoubleNumber(21)\n//=> Ok 42\n\ndoubleNumber('down')\n//=> Err \"The value given was not a valid number\"\n\n// isEvenOrOdd :: Number -> String\nconst isEvenOrOdd = n =>\n  n % 2 === 0 ? 'Even' : 'Odd'\n\n// getParity :: Number -> Object\nconst getParity = composeB(\n  objOf('parity'),\n  isEvenOrOdd\n)\n\n// getInfo :: a -> Result String ({ parity: String, value: Number })\nconst getInfo = compose(\n  map(merge(assign)),\n  map(fanout(objOf('value'), getParity)),\n  fromNumber\n)\n\ngetInfo(5324)\n//=> Ok { parity: \"Even\", value: 5324 }\n\ngetInfo('down')\n//=> Err \"The value given was not a valid number\"\n")),Object(o.b)("h3",{id:"alt"},"alt"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a ~> Result e a -> Result e a\n")),Object(o.b)("p",null,"Providing a means for a fallback or alternative value, ",Object(o.b)("inlineCode",{parentName:"p"},"alt")," combines\ntwo ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instances and will return the first ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," it encounters or\nam ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," if neither value is an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),"."),Object(o.b)("p",null,"If the value in both ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," are ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroup"),"s of the same type then they\nwill accumulate based on their rules."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport alt from 'crocks/pointfree/alt'\nimport compose from 'crocks/helpers/compose'\nimport curry from 'crocks/core/curry'\nimport flip from 'crocks/combinators/flip'\nimport identity from 'crocks/combinators/identity'\nimport ifElse from 'crocks/logic/ifElse'\nimport map from 'crocks/pointfree/map'\nimport reduce from 'crocks/pointfree/reduce'\nimport bimap from 'crocks/pointfree/bimap'\n\nconst { Ok, Err } = Result\n\n// ensure :: (a -> Boolean) -> a -> Result a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// gte :: Number -> Number -> Boolean\nconst gte = x => y =>\n  y >= x\n\n// find :: (a -> Boolean) -> Foldable a -> Result String a\nconst find = curry(\n  pred => compose(\n    bimap(() => 'Not Found', identity),\n    reduce(flip(alt), Err()),\n    map(ensure(pred))\n  )\n)\n\nErr('Error')\n  .alt(Ok('Result'))\n//=> Ok \"Result\"\n\nOk('Result')\n  .alt(Err('Error'))\n//=> Ok \"Result\"\n\nErr('Error 1.')\n  .alt(Err('Error 2.'))\n//=> Err \"Error 1.Error 2.\"\n\nfind(gte(41), [ 17, 25, 38, 42 ])\n//=> Ok 42\n\nfind(gte(11), [ 1, 2, 3, 4 ])\n//=> Err \"Not found\"\n")),Object(o.b)("h3",{id:"bimap"},"bimap"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a ~> ((e -> d), (a -> b)) -> Result d b\n")),Object(o.b)("p",null,"While it's more common to only ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#map"}),Object(o.b)("inlineCode",{parentName:"a"},"map"))," over a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," that's an\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," there may come a time when you need to map over a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," regardless\nof whether it's an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," or an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"bimap")," takes two mapping functions as its arguments. The first function is\nused to map an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," instance, while the second maps an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),".\n",Object(o.b)("inlineCode",{parentName:"p"},"Result")," only provides a means to map an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," instance exclusively using\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#map"}),Object(o.b)("inlineCode",{parentName:"a"},"map")),". If the need arises to map an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," instance exclusively,\nthen ",Object(o.b)("inlineCode",{parentName:"p"},"bimap")," can be used, passing the mapping function to the first argument\nand ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(o.b)("inlineCode",{parentName:"a"},"identity"))," to the second."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport bimap from 'crocks/pointfree/bimap'\nimport composeB from 'crocks/combinators/composeB'\nimport identity from 'crocks/combinators/identity'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\nimport objOf from 'crocks/helpers/objOf'\nimport setProp from 'crocks/helpers/setProp'\n\nconst { Ok, Err } = Result\n\n// ensure :: (a -> Boolean) -> a -> Result a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// buildError :: () -> String\nconst buildError = () =>\n  'The value given was not a valid number'\n\n// prod :: Number -> Number -> Number\nconst prod = x => y =>\n  x * y\n\n// fromNumber :: a -> Result String Number\nconst fromNumber = composeB(\n  bimap(buildError, identity),\n  ensure(isNumber)\n)\n\n// hasError :: Boolean -> Object -> Object\nconst hasError =\n  setProp('hasError')\n\n// Outcome :: { result: Number, hasError: Boolean, error: String }\n\n// buildResult :: (String, Boolean) -> a -> Outcome\nconst buildResult = (key, isError) =>\n  composeB(hasError(isError), objOf(key))\n\n// finalize :: Result e a -> Result Outcome\nconst finalize = bimap(\n  buildResult('error', true),\n  buildResult('result', false)\n)\n\n// double :: a -> Result String Number\nconst double = composeB(\n  map(prod(2)),\n  fromNumber\n)\n\nfinalize(double(21))\n//=> Ok { hasError: false, result: 42 }\n\nfinalize(double('unk'))\n//=> Err { hasError: true, error: \"The value given was not a valid number\" }\n")),Object(o.b)("h3",{id:"ap"},"ap"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e (a -> b) ~> Result e a -> Result e b\n")),Object(o.b)("p",null,"Short for apply, ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," is used to apply a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance containing a value to\nanother ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance that contains a function, resulting in\nnew ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance with the result. ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," requires that it is called on\nan ",Object(o.b)("inlineCode",{parentName:"p"},"instance")," that is either an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," or an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," that wraps a\ncurried polyadic function."),Object(o.b)("p",null,"When either instance is an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),", ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," will return an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),".\nThis can be used to safely combine multiple values under a given combination\nfunction. If any of the inputs results in an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," than they will never\nbe applied to the function and not provide exceptions or unexpected results.\nHowever if the value in both ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," are ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroup"),"s of the same type\nthen they will accumulate based on their rules."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport map from 'crocks/pointfree/map'\n\nconst { Ok, Err } = Result\n\n// buildError :: () -> Result String a\nconst buildError = () =>\n  Err('The value given was not a valid number')\n\n// prod :: Number -> Number -> Number\nconst prod = x => y =>\n  x * y\n\n// fromNumber :: a -> Result String Number\nconst fromNumber =\n  ifElse(isNumber, Ok, buildError)\n\nmap(prod, fromNumber(2))\n  .ap(fromNumber(5))\n//=> Ok 10\n\nmap(prod, fromNumber('string'))\n  .ap(fromNumber(5))\n//=> Err \"The value given was not a valid number\"\n\nOk(prod)\n  .ap(fromNumber(2))\n  .ap(fromNumber(21))\n//=> Ok 42\n\nOk(prod)\n  .ap(fromNumber('string'))\n  .ap(fromNumber(21))\n//=> Err \"The value given was not a valid number\"\n\nliftA2(prod, fromNumber(2), fromNumber(21))\n//=> Ok 42\n\nliftA2(prod, Err('Not 2'), Err('Not 21'))\n//=> Err \"Not 2Not 21\"\n\nliftA2(prod, Err([ 'Not 2' ]), Err([ 'Not 21' ]))\n//=> Err [ \"Not 2\", \"Not 21\" ]\n")),Object(o.b)("h3",{id:"sequence"},"sequence"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Apply f => Result e (f a) ~> (b -> f b) -> f (Result e a)\nApplicative f => Result e (f a) ~> TypeRep f -> f (Result e a)\n")),Object(o.b)("p",null,"When an instance of ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," wraps an ",Object(o.b)("inlineCode",{parentName:"p"},"Apply")," instance, ",Object(o.b)("inlineCode",{parentName:"p"},"sequence")," can be used to\nswap the type sequence. ",Object(o.b)("inlineCode",{parentName:"p"},"sequence")," requires either an ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Apply")," returning function is provided for its argument. This will be used in\nthe case that the ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance is a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"sequence")," can be derived from ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#traverse"}),Object(o.b)("inlineCode",{parentName:"a"},"traverse"))," by passing it\nan ",Object(o.b)("inlineCode",{parentName:"p"},"identity")," function (",Object(o.b)("inlineCode",{parentName:"p"},"x => x"),")."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport Identity from 'crocks/Identity'\n\nconst { Err, Ok } = Result\n\n// arrayOf :: a -> [ a ]\nconst arrayOf =\n  x => [ x ]\n\nOk([ 1, 2, 3 ])\n  .sequence(arrayOf)\n//=> [ Ok 1, Ok 2, Ok 3 ]\n\nErr('no array here')\n  .sequence(arrayOf)\n//=> [ Err \"no array here\" ]\n\nOk(Identity.of(42))\n  .sequence(Identity)\n//=> Identity (Ok 42)\n\nErr(0)\n  .sequence(Identity)\n//=> Identity (Err 0)\n")),Object(o.b)("h3",{id:"traverse"},"traverse"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Apply f => Result e a ~> (c -> f c), (a -> f b)) -> f Result e b\nApplicative f => Result e a ~> (TypeRep f, (a -> f b)) -> f Result e b\n")),Object(o.b)("p",null,'Used to apply the "effect" of an ',Object(o.b)("inlineCode",{parentName:"p"},"Apply")," to a value inside of a ",Object(o.b)("inlineCode",{parentName:"p"},"Result"),",\n",Object(o.b)("inlineCode",{parentName:"p"},"traverse"),' combines both the "effects" of the ',Object(o.b)("inlineCode",{parentName:"p"},"Apply")," and the ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," by\nreturning a new instance of the ",Object(o.b)("inlineCode",{parentName:"p"},"Apply"),", wrapping the result of\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"Apply"),'s "effect" on the value in the ',Object(o.b)("inlineCode",{parentName:"p"},"Result"),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"traverse")," requires either an ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or an ",Object(o.b)("inlineCode",{parentName:"p"},"Apply"),' returning\nfunction as its first argument and a function that is used to apply the\n"effect" of the target  ',Object(o.b)("inlineCode",{parentName:"p"},"Apply")," to the value inside of the ",Object(o.b)("inlineCode",{parentName:"p"},"Result"),". This will\nbe used in the case that the ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance is a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),". Both\narguments must provide an instance of the target ",Object(o.b)("inlineCode",{parentName:"p"},"Apply"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport Pair from 'crocks/Pair'\nimport State from 'crocks/State'\nimport Sum from 'crocks/Sum'\nimport constant from 'crocks/combinators/constant'\nimport ifElse from 'crocks/logic/ifElse'\nimport traverse from 'crocks/pointfree/traverse'\n\nconst { Err, Ok } = Result\nconst { get, modify } = State\n\n// lte :: Number -> Number -> Boolean\nconst lte = y => x =>\n  x <= y\n\n// ensure :: (a -> Boolean) -> a -> Result a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// tallyOf :: Number -> Pair Sum Number\nconst tallyOf = x =>\n  Pair(Sum.empty(), x)\n\n// incBy :: Number -> Pair Sum Number\nconst incBy = x =>\n  Pair(Sum(x), x)\n\nOk(12)\n  .traverse(tallyOf, incBy)\n//=> Pair( Sum 12, Ok 12 )\n\nErr(true)\n  .traverse(tallyOf, incBy)\n//=> Pair( Sum 0, Err true )\n\n// lte10 :: Number -> Result Number\nconst lte10 =\n  ensure(lte(10))\n\n// update :: Number -> State Number\nconst update = x =>\n  modify(state => x + state)\n    .chain(constant(get()))\n\n// updateSmall :: () => State Number\nconst updateSmall = () =>\n  get(lte10)\n    .chain(traverse(State, update))\n\nupdateSmall()\n  .runWith(3)\n//=> Pair( Ok 6, 6 )\n\nupdateSmall()\n  .chain(updateSmall)\n  .runWith(3)\n//=> Pair( Ok 12, 12 )\n\nupdateSmall()\n  .chain(updateSmall)\n  .chain(updateSmall)\n  .runWith(3)\n//=> Pair( Err 12, 12 )\n\nupdateSmall()\n  .chain(updateSmall)\n  .chain(updateSmall)\n  .runWith(30)\n//=> Pair( Err 30, 30 )\n")),Object(o.b)("h3",{id:"chain"},"chain"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a ~> (a -> Result e b) -> Result e b\n")),Object(o.b)("p",null,"Combining a sequential series of transformations that capture disjunction can\nbe accomplished with ",Object(o.b)("inlineCode",{parentName:"p"},"chain"),". ",Object(o.b)("inlineCode",{parentName:"p"},"chain")," expects a unary, ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," returning\nfunction as its argument. When invoked on an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),", ",Object(o.b)("inlineCode",{parentName:"p"},"chain")," will not run\nthe function, but will instead return a new ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," instance with the\nsame containing value. When called on an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," however, the inner value\nwill be passed to provided function, returning the result as the new instance."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport chain from 'crocks/pointfree/chain'\nimport composeB from 'crocks/combinators/composeB'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport maybeToResult from 'crocks/Result/maybeToResult'\nimport map from 'crocks/pointfree/map'\nimport getProp from 'crocks/Maybe/getProp'\n\nconst { Err, Ok } = Result\n\n// errText :: (String | Number) -> String\nconst errText = name =>\n  `${name} does not exist on the value given`\n\n// buildError :: () -> Result String a\nconst buildError = () =>\n  Err('the value given is not valid')\n\n// ensure :: (a -> Boolean) -> a -> Result String a\nconst ensure = pred =>\n  ifElse(pred, Ok, buildError)\n\n// fromNumber :: a -> Result String Number\nconst fromNumber =\n  ensure(isNumber)\n\n// prop :: (String | Number) -> Object -> Result String a\nconst prop = name =>\n  maybeToResult(errText(name), getProp(name))\n\n// protectedAdd10 :: a -> Result String Number\nconst protectedAdd10 = composeB(\n  map(x => x + 10),\n  fromNumber\n)\n\n// getAge :: Object -> Result String Number\nconst getAge = composeB(\n  chain(fromNumber),\n  prop('age')\n)\n\ngetAge({ name: 'Sarah', age: 21 })\n//=> Ok 21\n\ngetAge({ name: 'Sarah', age: 'unk' })\n//=> Err \"the value given is not valid\"\n\ngetAge({ name: 'Sarah' })\n//=> Err \"age does not exist on the value given\"\n\ngetAge({ name: 'Sarah', age: 21 })\n  .chain(protectedAdd10)\n//=> Ok 31\n\ngetAge({ name: 'Sarah', age: 'unk' })\n  .chain(protectedAdd10)\n//=> Err \"the value given is not valid\"\n")),Object(o.b)("h3",{id:"coalesce"},"coalesce"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a ~> ((e -> b), (a -> b))) -> Result c b\n")),Object(o.b)("p",null,"There will come a time in your flow that you will want to ensure you have\nan ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," of a given type. ",Object(o.b)("inlineCode",{parentName:"p"},"coalesce")," allows you to ",Object(o.b)("inlineCode",{parentName:"p"},"map")," over both\nthe ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," and the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," and return an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),". ",Object(o.b)("inlineCode",{parentName:"p"},"coalesce")," expects\ntwo functions for it's inputs."),Object(o.b)("p",null,"The first function is used when invoked on a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," and will return\na ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," instance wrapping the result of the function. The second function\nis used when ",Object(o.b)("inlineCode",{parentName:"p"},"coalesce")," is invoked on a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," and is used to map the\noriginal value, returning a new ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," instance wrapping the result of the\nsecond function."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport assign from 'crocks/helpers/assign'\nimport chain from 'crocks/pointfree/chain'\nimport coalesce from 'crocks/pointfree/coalesce'\nimport compose from 'crocks/helpers/compose'\nimport composeB from 'crocks/combinators/composeB'\nimport constant from 'crocks/combinators/constant'\nimport fanout from 'crocks/Pair/fanout'\nimport hasProp from 'crocks/predicates/hasProp'\nimport identity from 'crocks/combinators/identity'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport isObject from 'crocks/predicates/isObject'\nimport map from 'crocks/pointfree/map'\nimport merge from 'crocks/pointfree/merge'\nimport objOf from 'crocks/helpers/objOf'\nimport setProp from 'crocks/helpers/setProp'\n\nconst { Err, Ok } = Result\n\n// gte :: Number -> Number -> Boolean\nconst gte = y => x =>\n  x >= y\n\n// ensure :: (a -> Boolean) -> a -> Result a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// fromNumber :: a -> Result a Number\nconst fromNumber =\n  ensure(isNumber)\n\n// ensureIsObject :: a -> Result a Object\nconst ensureIsObject =\n  ensure(isObject)\n\nfromNumber(45)\n  .coalesce(constant(42), identity)\n//=> Ok 45\n\nfromNumber('number')\n  .coalesce(constant(42), identity)\n//=> Ok 42\n\n// hasAge :: a -> Result a Boolean\nconst hasAge =\n  ensure(hasProp('age'))\n\n// prop :: String -> Object -> a\nconst prop = name => x =>\n  x[name]\n\n// Person :: { canDrink: Boolean, name: String: age: Number }\n\n// ensureHasAge :: a -> Result a Person\nconst ensureHasAge = compose(\n  coalesce(setProp('age', 0), identity),\n  chain(hasAge),\n  coalesce(constant({}), identity),\n  ensureIsObject\n)\n\n// determineCanDrink :: Number -> { canDrink: Boolean }\nconst determineCanDrink =\n  composeB(objOf('canDrink'), gte(18))\n\n// setCanDrink :: a -> Result a Person\nconst setCanDrink = compose(\n  merge(assign),\n  map(determineCanDrink),\n  fanout(identity, prop('age'))\n)\n\n// setCanDrink :: a -> Result Person\nconst getDetails = composeB(\n  map(setCanDrink),\n  ensureHasAge\n)\n\ngetDetails({ name: 'John', age: 17 })\n//=> Ok { canDrink: false, name: \"John\", age: 17 }\n\ngetDetails({ name: 'Laury', age: 22 })\n//=> Ok { canDrink: true, name: \"Laury\", age: 22 }\n\ngetDetails(null)\n//=> Ok { canDrink: false, age: 0 }\n\ngetDetails(undefined)\n//=> Ok { canDrink: false, age: 0 }\n\ngetDetails(1)\n//=> Ok { canDrink: false, age: 0 }\n\ngetDetails(false)\n//=> Ok { canDrink: false, age: 0 }\n")),Object(o.b)("h3",{id:"bichain"},"bichain"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result c a ~> ((c -> Result d b), (a -> Result d b)) -> Result d b\n")),Object(o.b)("p",null,"Combining a sequential series of transformations that capture disjunction can be\naccomplished with ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#chain"}),Object(o.b)("inlineCode",{parentName:"a"},"chain")),". Along the same lines, ",Object(o.b)("inlineCode",{parentName:"p"},"bichain")," allows you\nto do this from both ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," and ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),". ",Object(o.b)("inlineCode",{parentName:"p"},"bichain")," expects\ntwo unary, ",Object(o.b)("inlineCode",{parentName:"p"},"Either")," returning functions as its arguments. When invoked on\nan ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," instance, ",Object(o.b)("inlineCode",{parentName:"p"},"bichain")," will use\nthe left, or first, function that can return either an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," or\nan ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," instance. When called on an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," instance, it\nwill behave exactly as ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#chain"}),Object(o.b)("inlineCode",{parentName:"a"},"chain"))," would with the right, or\nsecond, function."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport bichain from 'crocks/pointfree/bichain'\nimport compose from 'crocks/helpers/compose'\nimport composeK from 'crocks/helpers/composeK'\nimport constant from 'crocks/combinators/constant'\nimport equals from 'crocks/pointfree/equals'\nimport getProp from 'crocks/Maybe/getProp'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\nimport maybeToResult from 'crocks/Result/maybeToResult'\nimport objOf from 'crocks/helpers/objOf'\nimport safe from 'crocks/Maybe/safe'\nimport substitution from 'crocks/combinators/substitution'\nimport tryCatch from 'crocks/Result/tryCatch'\n\nconst { Err, Ok } = Result\n\n// swapResult :: Result e a -> Result a e\nconst swapResult =\n  bichain(Ok, Err)\n\nswapResult(Err('err'))\n//=> Ok \"err\"\n\nswapResult(Ok('ok'))\n//=> Err \"ok\"\n\n// Wrapped :: { value: Number }\n// wrapEven :: Number -> Wrapped\nfunction wrapEven(num) {\n  if(!isNumber(num)) {\n    throw new TypeError('wrapEven: Must be a Number')\n  }\n\n  if(num % 2) {\n    throw new Error('wrapEven: Nunber must be even')\n  }\n\n  return { value: num }\n}\n\n// increment :: Number -> Number\nconst increment = x =>\n  x + 1\n\nconst checkEvenError = composeK(\n  safe(equals('wrapEven: Nunber must be even')),\n  getProp('message')\n)\n\n// alwaysWrapInc :: Number -> () -> Wrapped\nconst alwaysWrapInc = compose(\n  constant,\n  objOf('value'),\n  increment\n)\n\n// makeWrappedEven :: Number -> Error -> Maybe Wrapped\nconst makeWrappedEven = orig => compose(\n  map(alwaysWrapInc(orig)),\n  checkEvenError\n)\n\n// resolveError :: Number -> Error -> Result Error Wrapped\nconst resolveError = compose(\n  substitution(maybeToResult),\n  makeWrappedEven\n)\n\n// safeWrapEven :: Number -> Result Error Wrapped\nconst safeWrapEven = num =>\n  tryCatch(wrapEven, num)\n    .bichain(resolveError(num), Ok)\n\nsafeWrapEven(2)\n//=> Ok { value: 2 }\n\nsafeWrapEven(42)\n//=> Ok { value: 42 }\n\nsafeWrapEven(23)\n//=> Ok { value: 24 }\n\nsafeWrapEven('92')\n//=> Err TypeError: wrapEven: Must be a Number\n\nsafeWrapEven(null)\n//=> Err TypeError: wrapEven: Must be a Number\n")),Object(o.b)("h3",{id:"swap"},"swap"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a ~> ((e -> a), (a -> e)) -> Result e a\n")),Object(o.b)("p",null,"Used to map the value of a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance and transform an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," into an\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," or an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," into an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),", ",Object(o.b)("inlineCode",{parentName:"p"},"swap")," takes two functions as its arguments.\nThe first function is used to map and transform an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," into an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok")),",\nwhile the second maps and transforms an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," into an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),". If no mapping of\nthe contained values is required for either instance,\nthen ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(o.b)("inlineCode",{parentName:"a"},"identity"))," functions can be used in one or both arguments."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport constant from 'crocks/combinators/constant'\nimport identity from 'crocks/combinators/identity'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport when from 'crocks/logic/when'\nimport swap from 'crocks/pointfree/swap'\n\nconst { Ok, Err } = Result\n\n// simpleSwap :: Result e a -> Result a e\nconst simpleSwap =\n  swap(identity, identity)\n\nsimpleSwap(Ok(42))\n//=> Err 42\n\nsimpleSwap(Err(21))\n//=> Ok 21\n\n// ensure :: (a -> Boolean) -> a -> Result String a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// fromNumber :: a -> Result String Number\nconst fromNumber =\n  ensure(isNumber)\n\n// toString :: Number -> String\nconst toString = x =>\n  x.toString()\n\n// toNumber :: String -> Number\nconst toNumber = x =>\n  parseInt(x)\n\n// parseWithDefault :: Number -> a -> Number\nconst parseWithDefault = defaultValue => value =>\n  when(isNaN, constant(defaultValue), toNumber(value))\n\n// swapWith :: Result String Number -> Result String Number\nconst swapValues =\n  swap(parseWithDefault(0), toString)\n\nswapValues(fromNumber(4))\n//=> Err \"4\"\n\nswapValues(fromNumber('number'))\n//=> Ok 0\n")),Object(o.b)("h3",{id:"either"},"either"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"Result e a ~> ((e -> b), (a -> b)) -> b\n")),Object(o.b)("p",null,"Used to provide a means to map a given ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance folding it out of its\ncontainer. ",Object(o.b)("inlineCode",{parentName:"p"},"either")," expects two functions as its arguments. The first is a\nfunction that will be used to map an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),". While the second\nwill map the value wrapped in a given ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," and return the result of that\nmapping."),Object(o.b)("p",null,"By composing ",Object(o.b)("inlineCode",{parentName:"p"},"either")," you can create functions that us the power of ",Object(o.b)("inlineCode",{parentName:"p"},"ADT"),"s while\nreturning a plain javascript type."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport compose from 'crocks/helpers/compose'\nimport either from 'crocks/pointfree/either'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\nimport objOf from 'crocks/helpers/objOf'\nimport setProp from 'crocks/helpers/setProp'\n\nconst { Ok, Err } = Result\n\n// buildError :: () -> Result String a\nconst buildError = () =>\n  Err('The value given was not a valid number')\n\n// ensure :: (a -> Boolean) -> a -> Result String a\nconst ensure = pred =>\n  ifElse(pred, Ok, buildError)\n\n// fromNumber :: a -> Result String Number\nconst fromNumber =\n  ensure(isNumber)\n\n// double :: Number -> Number\nconst double = x =>\n  x * 2\n\n// hasError :: Boolean -> Object -> Object\nconst hasError =\n  setProp('hasError')\n\n// buildResult :: (String, Boolean) -> a -> Object\nconst buildResult = (key, isError) =>\n  compose(hasError(isError), objOf(key))\n\n// ResultDetail :: { result: Number, hasError: Boolean, error: String }\n\n// createResult :: Result e a -> ResultDetail\nconst createResult = either(\n  buildResult('error', true),\n  buildResult('result', false)\n)\n\n// doubleNumber :: a -> ResultDetail\nconst doubleNumber = compose(\n  createResult,\n  map(double),\n  fromNumber\n)\n\ndoubleNumber(42)\n//=> { result: 84, hasError: false }\n\ndoubleNumber('value')\n//=> { error: 'The value given was not a valid number', hasError: true }\n")),Object(o.b)("h2",{id:"helper-functions"},"Helper Functions"),Object(o.b)("h3",{id:"trycatch"},"tryCatch"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Result/tryCatch")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"tryCatch :: (* -> a) -> * -> Result e a\n")),Object(o.b)("p",null,"Used when you want to take any variadic function and wrap it with the added\nfunction of a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," type. ",Object(o.b)("inlineCode",{parentName:"p"},"tryCatch")," will execute the function with the\nparameters passed and return either an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," when successful or an\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," when an exception is thrown."),Object(o.b)("p",null,"Although we do our best to not use ",Object(o.b)("inlineCode",{parentName:"p"},"Error")," to control program flow, there are\ntimes when we don't have full control over the behaviour of a function. The\nsaviour in this situation is ",Object(o.b)("inlineCode",{parentName:"p"},"tryCatch"),". You can wrap this function and it\nwill always return a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import tryCatch from 'crocks/Result/tryCatch'\n\ntryCatch(() => {\n  throw new Error('Simple error!')\n})()\n// Err \"Simple error!\"\n\n// calculateArea :: (a, b) -> Number\nconst calculateArea = (width, height) => {\n  if (isNaN(width) || isNaN(height)) {\n    throw Error('Parameter is not a number!')\n  }\n\n  return width * height\n}\n\n// tryCalculateArea :: (a, b) -> Result String Number\nconst tryCalculateArea =\n  tryCatch(calculateArea)\n\ntryCalculateArea(3, 6)\n//=> Ok 18\n\ntryCalculateArea('String', 5)\n// Err \"Error: Parameter is not a number!\"\n\n// getLength :: a -> Number\nconst getLength = a =>\n  a.length\n\n// tryGetLength :: a -> Result String Number\nconst tryGetLength =\n  tryCatch(getLength)\n\ntryGetLength([ 3, 2, 1 ])\n//=> Ok 3\n\ntryGetLength()\n//=> Err \"TypeError: Cannot read property 'length' of undefined\"\n")),Object(o.b)("h2",{id:"transformation-functions"},"Transformation Functions"),Object(o.b)("h3",{id:"eithertoresult"},"eitherToResult"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Result/eitherToResult")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"eitherToResult :: Either b a -> Result b a\neitherToResult :: (a -> Either c b) -> a -> Result c b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either"))," instance to a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance\nor flatten a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," of ",Object(o.b)("inlineCode",{parentName:"p"},"Either")," into a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," when chained, ",Object(o.b)("inlineCode",{parentName:"p"},"eitherToMaybe")," will\nturn a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either#right"}),Object(o.b)("inlineCode",{parentName:"a"},"Right"))," instance into an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," wrapping the original value\ncontained in the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either#right"}),Object(o.b)("inlineCode",{parentName:"a"},"Right")),".\nAll ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either#left"}),Object(o.b)("inlineCode",{parentName:"a"},"Left"))," instances will map to an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),", mapping the\noriginally contained value to a ",Object(o.b)("inlineCode",{parentName:"p"},"Unit"),". Values on the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either#left"}),Object(o.b)("inlineCode",{parentName:"a"},"Left"))," will be\nlost and as such this transformation is considered lossy in that regard."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"eitherToMaybe")," has two possible\nsignatures and will behave differently when passed either\nan ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either"))," instance or a function that returns an instance\nof ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either")),". When passed the instance, a transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," is\nreturned. When passed an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either"))," returning function, a function will\nbe returned that takes a given value and returns a ",Object(o.b)("inlineCode",{parentName:"p"},"Result"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport Either from 'crocks/Either'\nimport assign from 'crocks/helpers/assign'\nimport composeK from 'crocks/helpers/composeK'\nimport composeB from 'crocks/combinators/composeB'\nimport eitherToResult from 'crocks/Result/eitherToResult'\nimport fanout from 'crocks/Pair/fanout'\nimport isNumber from 'crocks/predicates/isNumber'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport map from 'crocks/pointfree/map'\nimport maybeToEither from 'crocks/Either/maybeToEither'\nimport merge from 'crocks/pointfree/merge'\nimport objOf from 'crocks/helpers/objOf'\nimport getProp from 'crocks/Maybe/getProp'\nimport safeLift from 'crocks/Maybe/safeLift'\n\nconst { Left, Right } = Either\nconst { Ok } = Result\n\neitherToResult(Left('no good'))\n//=> Err \"no good\"\n\neitherToResult(Right('so good'))\n//=> Ok \"so good\"\n\n// safeInc :: a -> Maybe Number\nconst safeInc =\n  safeLift(isNumber, x => x + 1)\n\n// incProp :: String -> a -> Maybe Number\nconst incProp = key =>\n  composeK(safeInc, getProp(key))\n\n// incResult :: String -> a -> Either [ String ] Object\nconst incResult = key => maybeToEither(\n  [ `${key} is not valid` ],\n  composeB(\n    map(objOf(key)),\n    incProp(key)\n  )\n)\n\n// incThem :: a -> Either [ String ] Object\nconst incThem = composeB(\n  merge(liftA2(assign)),\n  fanout(incResult('b'), incResult('a'))\n)\n\nResult.of({})\n  .chain(eitherToResult(incThem))\n//=> Err [ \"b is not valid\" ]\n\nResult.of({ a: 33 })\n  .chain(eitherToResult(incThem))\n//=> Err [ \"b is not valid\" ]\n\nResult.of({ a: 99, b: '41' })\n  .chain(eitherToResult(incThem))\n//=> Err [ \"b is not valid\" ]\n\nResult.of({ a: 99, b: 41 })\n  .chain(eitherToResult(incThem))\n//=> Ok { a: 100, b: 42 }\n\nOk(Left('Err'))\n  .chain(eitherToResult)\n//=> Err \"Err\"\n\nOk(Right('42'))\n  .chain(eitherToResult)\n//=> Ok \"42\"\n")),Object(o.b)("h3",{id:"firsttoresult"},"firstToResult"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Result/firstToResult")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"firstToResult :: e -> First a -> Result e a\nfirstToResult :: e -> (a -> First b) -> a -> Result e b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," instance to a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance\nor flatten a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," of ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," into a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," when\nchained, ",Object(o.b)("inlineCode",{parentName:"p"},"firstToResult")," will turn a non-empty instance into an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," wrapping\nthe original value contained within the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First")),". All empty instances\nwill map to an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err"))," with the given value."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"firstToResult")," has two possible\nsignatures and will behave differently when passed either\na ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," instance or a function that returns an instance\nof ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First")),". When passed the instance, a transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," is\nreturned. When passed a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," returning function, a function will be\nreturned that takes a given value and returns a ",Object(o.b)("inlineCode",{parentName:"p"},"Result"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import First from 'crocks/First'\n\nimport composeB from 'crocks/combinators/composeB'\nimport concat from 'crocks/pointfree/concat'\nimport firstToResult from 'crocks/Result/firstToResult'\nimport flip from 'crocks/combinators/flip'\nimport mapReduce from 'crocks/helpers/mapReduce'\nimport getProp from 'crocks/Maybe/getProp'\n\nconst { empty } = First\n\n// Person :: { name: String, age: Number }\n\n// createPerson :: (String, Number) -> Person\nconst createPerson = (name, age) => ({\n  name, age\n})\n\n// liftName :: Person -> First String\nconst liftName = composeB(\n  First,\n  getProp('name')\n)\n\n// mergeFirstName :: [ Person ] -> First String\nconst mergeFirstName = composeB(\n  firstToResult('(No name found)'),\n  mapReduce(liftName, flip(concat), empty())\n)\n\nmergeFirstName([\n  createPerson('John', 30),\n  createPerson('Jon', 33)\n])\n//=> Ok \"John\"\n\nmergeFirstName([\n  createPerson(undefined, 30),\n  createPerson(undefined, 33)\n])\n//=> Err \"(No name found)\"\n")),Object(o.b)("h3",{id:"lasttoresult"},"lastToResult"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Result/lastToResult")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"lastToResult :: e -> Last a -> Result e a\nlastToResult :: e -> (a -> Last b) -> a -> Result e b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," instance to a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance or\nflatten a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," of ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," into a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," when chained, ",Object(o.b)("inlineCode",{parentName:"p"},"lastToResult")," will\nturn a non-empty instance into a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," wrapping the original value\ncontained within the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last")),". All empty instances will map to a\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),"."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"lastToResult")," has two possible\nsignatures and will behave differently when passed either\na ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," instance or a function that returns an instance\nof ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last")),". When passed the instance, a transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," is returned.\nWhen passed a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," returning function, a function will be returned\nthat takes a given value and returns a ",Object(o.b)("inlineCode",{parentName:"p"},"Result"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport Last from 'crocks/Last'\nimport lastToResult from 'crocks/Result/lastToResult'\n\nimport mconcat from 'crocks/helpers/mconcat'\n\nconst { Ok, Err } = Result\n\n// lastValue :: [ a ] -> Last a\nconst lastValue =\n  mconcat(Last)\n\nlastToResult('Error occurred!', Last('the end'))\n//=> Ok \"the end\"\n\nErr('Error occurred!')\n  .chain(lastToResult('Error occurred!', lastValue))\n//=> Err \"Error occurred!\"\n\nOk([])\n  .chain(lastToResult('Error occurred!', lastValue))\n//=> Err \"Error occurred!\"\n\nOk([ 'first', 'second', 'third' ])\n  .chain(lastToResult('Error occurred!', lastValue))\n//=> Ok \"third\"\n\nOk(Last('last'))\n  .chain(lastToResult('Error occurred!'))\n//=> Ok \"last\"\n")),Object(o.b)("h3",{id:"maybetoresult"},"maybeToResult"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Result/maybeToResult")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-haskell"}),"maybeToResult :: e -> Maybe a -> Result e a\nmaybeToResult :: e -> (a -> Maybe b) -> a -> Result e b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," instance to a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," instance\nor flatten a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," of ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," into a ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," when\nchained, ",Object(o.b)("inlineCode",{parentName:"p"},"maybeToResult")," will turn a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe#just"}),Object(o.b)("inlineCode",{parentName:"a"},"Just"))," instance into\nan ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#ok"}),Object(o.b)("inlineCode",{parentName:"a"},"Ok"))," wrapping the original value contained in the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe#just"}),Object(o.b)("inlineCode",{parentName:"a"},"Just")),".\nAll ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe#nothing"}),Object(o.b)("inlineCode",{parentName:"a"},"Nothing"))," instances will map to a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#err"}),Object(o.b)("inlineCode",{parentName:"a"},"Err")),", containing the\ngiven ",Object(o.b)("inlineCode",{parentName:"p"},"e")," value."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"maybeToResult")," has two possible\nsignatures and will behave differently when passed either a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," instance\nor a function that returns an instance of ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe")),". When passed the instance,\na transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," is returned. When passed a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," returning function,\na function will be returned that takes a given value and returns a ",Object(o.b)("inlineCode",{parentName:"p"},"Result"),".\nThis means that when used with the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"./Maybe#helper-functions"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe-helpers"))," and ",Object(o.b)("inlineCode",{parentName:"p"},"compose")," you\nhave a larger collection of ",Object(o.b)("inlineCode",{parentName:"p"},"Result")," returning functions."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Result from 'crocks/Result'\n\nimport composeB from 'crocks/combinators/composeB'\nimport maybeToResult from 'crocks/Result/maybeToResult'\nimport Maybe from 'crocks/Maybe'\nimport getProp from 'crocks/Maybe/getProp'\n\nconst { Ok } = Result\nconst { Just, Nothing } = Maybe\n\nmaybeToResult('An error occurred', Just('21'))\n//=> Ok \"21\"\n\nmaybeToResult('An error occurred', Nothing())\n//=> Err \"An error occurred\"\n\n// Person :: { name: string, age: Number }\n\n// getName :: Person -> Result String\nconst getName = composeB(\n  maybeToResult('Name did not exist or was undefined'),\n  getProp('name')\n)\n\ngetName({ name: 'John', age: 21 })\n//=> Ok \"John\"\n\ngetName({ age: 27 })\n//=> Err \"Name did not exist or was undefined\"\n\nOk(Just('in time!'))\n  .chain(maybeToResult('An error occurred'))\n//=> Ok \"in time!\"\n\nOk(Nothing())\n  .chain(maybeToResult('An error occurred'))\n//=> Err \"An error occurred\"\n")))}l.isMDXComponent=!0}}]);