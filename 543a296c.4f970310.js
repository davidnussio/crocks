(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{114:function(e,n,t){"use strict";t.d(n,"a",(function(){return l})),t.d(n,"b",(function(){return d}));var a=t(0),i=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function b(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=i.a.createContext({}),p=function(e){var n=i.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=p(e.components);return i.a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},m=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=b(e,["components","mdxType","originalType","parentName"]),l=p(t),m=a,d=l["".concat(o,".").concat(m)]||l[m]||u[m]||r;return t?i.a.createElement(d,s(s({ref:n},c),{},{components:t})):i.a.createElement(d,s({ref:n},c))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=m;var s={};for(var b in n)hasOwnProperty.call(n,b)&&(s[b]=n[b]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=t[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},81:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return b})),t.d(n,"default",(function(){return p}));var a=t(3),i=t(7),r=(t(0),t(114)),o={title:"Maybe",description:"Maybe Crock",layout:"guide",functions:["find","getpath","getprop","prop","proppath","safe","safeafter","safelift","eithertomaybe","firsttomaybe","lasttomaybe","resulttomaybe"],weight:90},s={unversionedId:"crocks/Maybe",id:"crocks/Maybe",isDocsHomePage:!1,title:"Maybe",description:"Maybe Crock",source:"@site/docs/crocks/Maybe.md",slug:"/crocks/Maybe",permalink:"/crocks/docs/crocks/Maybe",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Maybe.md",version:"current",sidebar:"sidebar",previous:{title:"Identity",permalink:"/crocks/docs/crocks/Identity"},next:{title:"Pair",permalink:"/crocks/docs/crocks/Pair"}},b=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"Nothing",id:"nothing",children:[]},{value:"Just",id:"just",children:[]},{value:"of",id:"of",children:[]},{value:"zero",id:"zero",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"equals",id:"equals",children:[]},{value:"concat",id:"concat",children:[]},{value:"map",id:"map",children:[]},{value:"alt",id:"alt",children:[]},{value:"ap",id:"ap",children:[]},{value:"sequence",id:"sequence",children:[]},{value:"traverse",id:"traverse",children:[]},{value:"chain",id:"chain",children:[]},{value:"coalesce",id:"coalesce",children:[]},{value:"bichain",id:"bichain",children:[]},{value:"option",id:"option",children:[]},{value:"either",id:"either",children:[]}]},{value:"Helper Functions",id:"helper-functions",children:[{value:"find",id:"find",children:[]},{value:"getPath",id:"getpath",children:[]},{value:"getProp",id:"getprop",children:[]},{value:"safe",id:"safe",children:[]},{value:"safeAfter",id:"safeafter",children:[]},{value:"safeLift",id:"safelift",children:[]}]},{value:"Transformation Functions",id:"transformation-functions",children:[{value:"eitherToMaybe",id:"eithertomaybe",children:[]},{value:"firstToMaybe",id:"firsttomaybe",children:[]},{value:"lastToMaybe",id:"lasttomaybe",children:[]},{value:"maybeToArray",id:"maybetoarray",children:[]},{value:"resultToMaybe",id:"resulttomaybe",children:[]}]}],c={toc:b};function p(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a = Nothing | Just a\n")),Object(r.b)("p",null,"Defined as a Sum Type with its left side fixed to ",Object(r.b)("inlineCode",{parentName:"p"},"()")," (",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),"), ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),' is\nwell suited for capturing disjunction when the cause of the "error" case does\nnot need to be communicated. For example, providing default values on specific\nconditions.'),Object(r.b)("p",null,"A ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," represents disjunction by using two constructors, ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),".\nA ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," instance represents the truth case while ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," is considered\nfalse. With the exception of ",Object(r.b)("a",{parentName:"p",href:"#coalesce"},Object(r.b)("inlineCode",{parentName:"a"},"coalesce")),", all ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," returning\nmethods on an instance will be applied to a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," returning the result. If an\ninstance is a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),", then all application is skipped and another ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," is\nreturned."),Object(r.b)("p",null,"It is recommended to use the available ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," and ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing")),"\nconstructors to construct ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instances in most cases. You can use\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," constructor to construct a ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),", but it may read better to just\nuse ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport chain from 'crocks/pointfree/chain'\nimport compose from 'crocks/helpers/compose'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\n\nconst { Just, Nothing } = Maybe\n\n// gt5 :: Number -> Boolean\nconst gt5 =\n  x => x > 5\n\n// safe :: (a -> Boolean) -> a -> Maybe b\nconst safe = pred =>\n  ifElse(pred, Just, Nothing)\n\n// safeNumber :: a -> Maybe Number\nconst safeNumber =\n  safe(isNumber)\n\n// maybeBig :: Number -> Maybe Number\nconst maybeBig =\n  safe(gt5)\n\n// bigNumber :: a -> Maybe Number\nconst bigNumber = compose(\n  chain(maybeBig), safeNumber\n)\n\nsafeNumber(45)\n//=> Just 45\n\nsafeNumber('99')\n//=> Nothing\n\nmaybeBig(99)\n//=> Just 99\n\nmaybeBig(2)\n//=> Nothing\n\nbigNumber(34)\n//=> Just 34\n\nbigNumber('string')\n//=> Nothing\n\nbigNumber(3)\n//=> Nothing\n")),Object(r.b)("h2",{id:"implements"},"Implements"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Setoid"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Functor"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Alt"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Plus"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Traversable"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"Chain"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Applicative"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Alternative"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Monad")),Object(r.b)("h2",{id:"construction"},"Construction"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe :: a -> Maybe a\n")),Object(r.b)("p",null,"Most of the time, ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," is constructed using helper functions\nlike ",Object(r.b)("a",{parentName:"p",href:"#safe"},Object(r.b)("inlineCode",{parentName:"a"},"safe"))," or by employing one of the instance\nconstructors, ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," or ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing")),". This is due to the\nnature of ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," and most other Sum Types."),Object(r.b)("p",null,"As a matter of consistency and completion, a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance can also be\nconstructed using its TypeRep like any other type. The ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," constructor is a\nunary function that accepts any type ",Object(r.b)("inlineCode",{parentName:"p"},"a")," and returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," instance, wrapping\nthe value passed to its argument."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\nimport equals from 'crocks/pointfree/equals'\n\nMaybe('some string')\n//=> Just \"some string\"\n\nMaybe(null)\n//=> Just null\n\nMaybe(undefined)\n//=> Just undefined\n\nMaybe.of('some string')\n//=> Just \"some string\"\n\nMaybe.of(null)\n//=> Just null\n\nMaybe.of(undefined)\n//=> Just undefined\n\nMaybe.Just('some string')\n//=> Just \"some string\"\n\nMaybe.Just(null)\n//=> Just null\n\nMaybe.Just(undefined)\n//=> Just undefined\n\nequals(\n  Maybe.Just([ 1, 2, 3 ]),\n  Maybe.of([ 1, 2, 3 ])\n)\n//=> true\n\nequals(\n  Maybe.of({ a: 100 }),\n  Maybe({ a: 100 })\n)\n//=> true\n")),Object(r.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(r.b)("h3",{id:"nothing"},"Nothing"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe.Nothing :: () -> Maybe a\n")),Object(r.b)("p",null,"Used to construct a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),' instance that represents the "false" portion of\na disjunction. When an instance is a ',Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),", most ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," returning methods\nwill just return another ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),". Anything passed to the constructor will\nbe thrown out and mapped to ",Object(r.b)("inlineCode",{parentName:"p"},"()"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport chain from 'crocks/pointfree/chain'\nimport isNumber from 'crocks/predicates/isNumber'\nimport safeLift from 'crocks/Maybe/safeLift'\n\nconst { Just, Nothing } = Maybe\n\n// add10 :: Number -> Number\nconst add10 =\n  x => x + 10\n\n// safeAdd10 :: a -> Maybe Number\nconst safeAdd10 =\n  safeLift(isNumber, add10)\n\nJust(23)\n  .map(add10)\n//=> Just 33\n\nNothing(23)\n  .map(add10)\n//=> Nothing\n\nchain(safeAdd10, Just(10))\n//=> Just 20\n\nchain(safeAdd10, Nothing())\n//=> Nothing\n")),Object(r.b)("h3",{id:"just"},"Just"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe.Just :: a -> Maybe a\n")),Object(r.b)("p",null,"Used to construct a ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),' instance that represents the "true" portion of a\ndisjunction or a valid value.  ',Object(r.b)("inlineCode",{parentName:"p"},"Just")," will wrap any given value in\na ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),", signaling the validity of the wrapped value."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport compose from 'crocks/helpers/compose'\nimport ifElse from 'crocks/logic/ifElse'\nimport isString from 'crocks/predicates/isString'\nimport map from 'crocks/pointfree/map'\n\nconst { Just, Nothing } = Maybe\n\n// toUpper :: String -> String\nconst toUpper =\n  x => x.toUpperCase()\n\n// safe :: (a -> Boolean) -> a -> Maybe a\nconst safe =\n  pred => ifElse(pred, Just, Nothing)\n\n// safeShout :: a -> Maybe String\nconst safeShout = compose(\n  map(toUpper),\n  safe(isString)\n)\n\nsafeShout(45)\n//=> Nothing\n\nsafeShout('Hey there!')\n//=> Just \"HEY THERE!\"\n")),Object(r.b)("h3",{id:"of"},"of"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe.of :: a -> Maybe a\n")),Object(r.b)("p",null,"Used to wrap any value into a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," as a ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),", ",Object(r.b)("inlineCode",{parentName:"p"},"of"),' is used mostly by\nhelper functions that work "generically" with instances of\neither ',Object(r.b)("inlineCode",{parentName:"p"},"Applicative")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Monad"),". When working specifically with\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," type, the ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," constructor should be used. Reach\nfor ",Object(r.b)("inlineCode",{parentName:"p"},"of")," when working with functions that will work with\nANY ",Object(r.b)("inlineCode",{parentName:"p"},"Applicative"),"/",Object(r.b)("inlineCode",{parentName:"p"},"Monad"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport curry from 'crocks/helpers/curry'\nimport isString from 'crocks/predicates/isString'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Just } = Maybe\n\nMaybe(35)\n//=> Just 35\n\nJust(35)\n//=> Just 35\n\nMaybe.of(35)\n//=> Just 35\n\nconst safeString =\n  safe(isString)\n\n// lift2 :: Applicative m => (a -> b -> c) -> m a -> m b -> m c\nconst lift2 = curry(\n  (fn, x, y) => x.of(fn).ap(x).ap(y)\n)\n\n// join :: Applicative m => m String -> m String -> m String\nconst join =\n  lift2(a => b => `${a} ${b}`)\n\njoin(safeString('Brad'), safeString('Pitt'))\n//=> Just \"Brad Pitt\"\n\njoin(safeString(34), safeString('Pitt'))\n//=> Nothing\n")),Object(r.b)("h3",{id:"zero"},"zero"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe.zero :: () -> Maybe a\n")),Object(r.b)("p",null,"When working with ",Object(r.b)("inlineCode",{parentName:"p"},"Alt"),"s, ",Object(r.b)("inlineCode",{parentName:"p"},"zero")," provides a sort of ",Object(r.b)("inlineCode",{parentName:"p"},"empty")," or identity\nfor ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," when used with ",Object(r.b)("a",{parentName:"p",href:"#alt"},Object(r.b)("inlineCode",{parentName:"a"},"alt")),". ",Object(r.b)("inlineCode",{parentName:"p"},"zero")," takes no arguments and returns\na ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," instance. Just like an ",Object(r.b)("inlineCode",{parentName:"p"},"empty")," method on a given ",Object(r.b)("inlineCode",{parentName:"p"},"Monoid"),", ",Object(r.b)("inlineCode",{parentName:"p"},"zero")," can\nbe used to fold a collection of ",Object(r.b)("inlineCode",{parentName:"p"},"Alt"),"s under ",Object(r.b)("inlineCode",{parentName:"p"},"alt"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport alt from 'crocks/pointfree/alt'\nimport flip from 'crocks/combinators/flip'\nimport isNumber from 'crocks/predicates/isNumber'\nimport mapReduce from 'crocks/helpers/mapReduce'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Nothing, Just, zero } = Maybe\n\n// firstValid :: [ * ] -> Maybe Number\nconst firstValid =\n  mapReduce(safe(isNumber), flip(alt), zero())\n\nJust(33)\n  .alt(zero())\n//=> Just 33\n\nzero()\n  .alt(Just(33))\n//=> Just 33\n\nNothing()\n  .alt(zero())\n//=> Nothing\n\nzero()\n  .alt(Nothing())\n//=> Nothing\n\nfirstValid([ null, 'nope', 10, 45 ])\n//=> Just 10\n\nfirstValid([ 75, null, 'nope' ])\n//=> Just 75\n\nfirstValid([ null, undefined, 'wrong' ])\n//=> Nothing\n")),Object(r.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(r.b)("h3",{id:"equals"},"equals"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a ~> b -> Boolean\n")),Object(r.b)("p",null,"Used to compare the underlying values of two ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instances for equality by\nvalue, ",Object(r.b)("inlineCode",{parentName:"p"},"equals")," takes any given argument and returns ",Object(r.b)("inlineCode",{parentName:"p"},"true")," if the passed\narguments is a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," with an underlying value equal to the underlying value\nof the ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," the method is being called on. If the passed argument is not\na ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," or the underlying values are not equal, ",Object(r.b)("inlineCode",{parentName:"p"},"equals")," will return ",Object(r.b)("inlineCode",{parentName:"p"},"false"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport equals from 'crocks/pointfree/equals'\n\nconst { Nothing, Just } = Maybe\n\nJust(33)\n  .equals(Just(33))\n//=> true\n\nNothing()\n  .equals(Nothing())\n//=> true\n\nNothing()\n  .equals(Just(33))\n//=> false\n\n// by value, not reference for most types\nJust({ a: 86, b: true })\n  .equals(Just({ a: 86, b: true }))\n//=> true\n\nequals(Just(95), 95)\n//=> false\n\nequals(undefined, Nothing())\n//=> false\n\nequals(Just([ 2, 3 ]), Just([ 2, 3 ]))\n//=> true\n")),Object(r.b)("h3",{id:"concat"},"concat"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Semigroup s => Maybe s ~> Maybe s -> Maybe s\n")),Object(r.b)("p",null,"When an underlying value of a given ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," is fixed to a ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(r.b)("inlineCode",{parentName:"p"},"concat")," can\nbe used to concat another ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance with an underlying ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup")," of\nthe same type. Expecting a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," wrapping a ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup")," of the same\ntype, ",Object(r.b)("inlineCode",{parentName:"p"},"concat")," will give back a new ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance wrapping the result of combining\nthe two underlying ",Object(r.b)("inlineCode",{parentName:"p"},"Semigroup"),"s. When called on a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," instance, ",Object(r.b)("inlineCode",{parentName:"p"},"concat")," will\nreturn a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport Sum from 'crocks/Sum'\n\nimport compose from 'crocks/helpers/compose'\nimport concat from 'crocks/pointfree/concat'\nimport flip from 'crocks/combinators/flip'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\nimport mapReduce from 'crocks/helpers/mapReduce'\nimport safeLift from 'crocks/Maybe/safeLift'\nimport valueOf from 'crocks/pointfree/valueOf'\n\nconst { Nothing, Just } = Maybe\n\n// safeSum :: a -> Maybe Sum\nconst safeSum =\n  safeLift(isNumber, Sum)\n\n// empty :: Maybe Sum\nconst empty =\n  Just(Sum.empty())\n\n// sumList :: [ * ] -> Maybe Number\nconst sumList = compose(\n  map(valueOf),\n  mapReduce(safeSum, flip(concat), empty)\n)\n\nJust([ 34 ])\n  .concat(Just([ 92 ]))\n//=> Just [ 34, 92 ]\n\nJust([ 34 ])\n  .concat(Nothing())\n//=> Nothing\n\nsumList([ 3, 4, 5 ])\n//=> Just 12\n\nsumList([ 'three', 4, 'five' ])\n//=> Nothing\n")),Object(r.b)("h3",{id:"map"},"map"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a ~> (a -> b) -> Maybe b\n")),Object(r.b)("p",null,"Used to apply transformations to values in the safety of a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),", ",Object(r.b)("inlineCode",{parentName:"p"},"map")," takes\na function that it will lift into the context of the ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," and apply to it\nthe wrapped value. When ran on a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," instance, ",Object(r.b)("inlineCode",{parentName:"p"},"map")," will apply the wrapped\nvalue to the provided function and return the result in a new ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," instance."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport assign from 'crocks/helpers/assign'\nimport compose from 'crocks/helpers/compose'\nimport isObject from 'crocks/predicates/isObject'\nimport isString from 'crocks/predicates/isString'\nimport map from 'crocks/pointfree/map'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Nothing, Just } = Maybe\n\n// add10 :: Number -> Number\nconst add10 =\n  x => x + 10\n\n// toUpper :: String -> String\nconst toUpper = x =>\n  x.toUpperCase()\n\n// safeObj :: a -> Maybe Object\nconst safeObj =\n  safe(isObject)\n\n// shout :: a -> Maybe String\nconst shout = x =>\n  safe(isString, x)\n    .map(toUpper)\n\n// setProcessed :: a -> Maybe Object\nconst setProcessed = compose(\n  map(assign({ processed: true })),\n  safeObj\n)\n\nJust(0)\n  .map(add10)\n//=> Just 10\n\nNothing()\n  .map(add10)\n//=> Nothing\n\nshout('good news')\n//=> Just \"GOOD NEWS\"\n\nshout(33)\n//=> Nothing\n\nsetProcessed({ cheese: true })\n//=> Just { cheese: true, processed: true }\n\nsetProcessed(null)\n//=> Nothing\n")),Object(r.b)("h3",{id:"alt"},"alt"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a ~> Maybe a -> Maybe a\n")),Object(r.b)("p",null,"Providing a means for a fallback or alternative value, ",Object(r.b)("inlineCode",{parentName:"p"},"alt")," combines\ntwo ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instances and will return the first ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," it encounters or ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," if\nit does not have a ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),". This can be used in conjunction with ",Object(r.b)("a",{parentName:"p",href:"#zero"},Object(r.b)("inlineCode",{parentName:"a"},"zero"))," to\nreturn the first valid value in contained in a ",Object(r.b)("inlineCode",{parentName:"p"},"Foldable")," structure."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport alt from 'crocks/pointfree/alt'\nimport isArray from 'crocks/predicates/isArray'\nimport flip from 'crocks/combinators/flip'\nimport mapReduce from 'crocks/helpers/mapReduce'\nimport safe from 'crocks/Maybe/safe'\n\nconst { zero, Nothing, Just } = Maybe\n\n// firstArray :: Foldable f => f * -> Maybe Array\nconst firstArray =\n  mapReduce(safe(isArray), flip(alt), zero())\n\nNothing()\n  .alt(Just(33))\n//=> Just 33\n\nJust(42)\n  .alt(Nothing())\n  .alt(Just(99))\n//=> Just 42\n\nfirstArray([ 'Not Array', null, [ 2, 3, 4 ], [ 1, 2 ] ])\n//=> Just [ 2, 3, 4 ]\n\nfirstArray([ null, 5, '76' ])\n//=> Nothing\n")),Object(r.b)("h3",{id:"ap"},"ap"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe (a -> b) ~> Maybe a -> Maybe b\n")),Object(r.b)("p",null,"Short for apply, ",Object(r.b)("inlineCode",{parentName:"p"},"ap")," is used to apply a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance containing a value\nto another ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance that contains a function, resulting in\nnew ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance with the result. ",Object(r.b)("inlineCode",{parentName:"p"},"ap")," requires that it is called on\nan ",Object(r.b)("inlineCode",{parentName:"p"},"instance")," that is either a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," or a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," that wraps a curried\npolyadic function."),Object(r.b)("p",null,"When either ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," is a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),", ",Object(r.b)("inlineCode",{parentName:"p"},"ap")," will return a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),". This can be\nused to safely combine multiple values under a given combination function. If\nany of the inputs results in a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," than they will never be applied to\nthe function and not provide exceptions or unexpected results."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport compose from 'crocks/helpers/compose'\nimport chain from 'crocks/pointfree/chain'\nimport curry from 'crocks/helpers/curry'\nimport fanout from 'crocks/Pair/fanout'\nimport getProp from 'crocks/Maybe/getProp'\nimport isString from 'crocks/predicates/isString'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport merge from 'crocks/pointfree/merge'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Nothing, Just } =  Maybe\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// joinWith :: String -> String -> String -> String\nconst joinWith = curry(\n  (del, x, y) => x + del + y\n)\n\n// stringProp :: String -> a -> Maybe String\nconst stringProp = key => compose(\n  chain(safe(isString)),\n  getProp(key)\n)\n\n// getNames :: a -> Pair (Maybe String) (Maybe String)\nconst getNames = fanout(\n  stringProp('first'),\n  stringProp('last')\n)\n\n// joinNames :: Pair (Maybe String) (Maybe String) -> Maybe String\nconst joinNames =\n  merge(liftA2(joinWith(' ')))\n\n// fullName :: a -> Maybe String\nconst fullName =\n  compose(joinNames, getNames)\n\nMaybe.of(add)\n  .ap(Just(5))\n  .ap(Just(27))\n//=> Just 32\n\nJust('hello')\n  .map(joinWith(' -- '))\n  .ap(Just('friend'))\n//=> Just \"hello -- friend\"\n\nMaybe.of(add)\n  .ap(Just(29))\n  .ap(Nothing())\n//=> Nothing\n\nfullName({ first: 'Joey', last: 'Fella' })\n//=> Just \"Joey Fella\"\n\nfullName(null)\n//=> Nothing\n\nfullName({ first: 'Lizzy' })\n//=> Nothing\n")),Object(r.b)("h3",{id:"sequence"},"sequence"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Apply f => Maybe (f a) ~> (b -> f b) -> f (Maybe a)\nApplicative f => Maybe (f a) ~> TypeRep f -> f (Maybe a)\n")),Object(r.b)("p",null,"When an instance of ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," wraps an ",Object(r.b)("inlineCode",{parentName:"p"},"Apply")," instance, ",Object(r.b)("inlineCode",{parentName:"p"},"sequence")," can be used to\nswap the type sequence. ",Object(r.b)("inlineCode",{parentName:"p"},"sequence")," requires either an ",Object(r.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or\nan ",Object(r.b)("inlineCode",{parentName:"p"},"Apply")," returning function is provided for its argument. This will be used in\nthe case that the ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance is a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"sequence")," can be derived from ",Object(r.b)("a",{parentName:"p",href:"#traverse"},Object(r.b)("inlineCode",{parentName:"a"},"traverse"))," by passing it\nan ",Object(r.b)("inlineCode",{parentName:"p"},"identity")," function (",Object(r.b)("inlineCode",{parentName:"p"},"x => x"),")."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport Identity from 'crocks/Identity'\nimport sequence from 'crocks/pointfree/sequence'\n\nconst { Nothing, Just } = Maybe\n\n// seqId :: Maybe Identity a -> Identity Maybe a\nconst seqId =\n  sequence(Identity)\n\nseqId(Just(Identity(34)))\n//=> Identity Just 34\n\nseqId(Nothing())\n//=> Identity Nothing\n")),Object(r.b)("h3",{id:"traverse"},"traverse"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Apply f => Maybe a ~> (c -> f c), (a -> f b)) -> f Maybe b\nApplicative f => Maybe a ~> (TypeRep f, (a -> f b)) -> f Maybe b\n")),Object(r.b)("p",null,'Used to apply the "effect" of an ',Object(r.b)("inlineCode",{parentName:"p"},"Apply")," to a value inside of a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"traverse"),' combines both the "effects" of the ',Object(r.b)("inlineCode",{parentName:"p"},"Apply")," and the ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," by\nreturning a new instance of the ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),", wrapping the result of\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),'s "effect" on the value in the ',Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"traverse")," requires either an ",Object(r.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or an ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),' returning\nfunction as its first argument and a function that is used to apply the "effect"\nof the target  ',Object(r.b)("inlineCode",{parentName:"p"},"Apply")," to the value inside of the ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),". This will be used in\nthe case that the ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance is a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),". Both arguments must provide\nan instance of the target ",Object(r.b)("inlineCode",{parentName:"p"},"Apply"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import IO from 'crocks/IO'\n\nimport compose from 'crocks/helpers/compose'\nimport isNumber from 'crocks/predicates/isNumber'\nimport safe from 'crocks/Maybe/safe'\nimport traverse from 'crocks/pointfree/traverse'\n\n// someGlobal :: Number\nlet someGlobal = 10\n\n// addToGlobal :: Number -> IO Number\nconst addToGlobal = x => IO(function() {\n  someGlobal = someGlobal + x\n  return someGlobal\n})\n\n// safeAddToGlobal :: a -> IO (Maybe Number)\nconst safeAddToGlobal = compose(\n  traverse(IO, addToGlobal),\n  safe(isNumber)\n)\n\nsafeAddToGlobal(32)\n  .run()\n//=> Just 42\n//someGlobal => 42\n\nsafeAddToGlobal(undefined)\n  .run()\n//=> Nothing\n")),Object(r.b)("h3",{id:"chain"},"chain"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a ~> (a -> Maybe b) -> Maybe b\n")),Object(r.b)("p",null,"Combining a sequential series of transformations that capture disjunction can be\naccomplished with ",Object(r.b)("inlineCode",{parentName:"p"},"chain"),". ",Object(r.b)("inlineCode",{parentName:"p"},"chain")," expects a unary, ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," returning function\nas its argument. When invoked on a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),", ",Object(r.b)("inlineCode",{parentName:"p"},"chain")," will not run the function,\nbut will instead return another ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),". When called on a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," however, the\ninner value will be passed to provided function, returning the result as the\nnew instance."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport chain from 'crocks/pointfree/chain'\nimport compose from 'crocks/helpers/compose'\nimport getProp from 'crocks/Maybe/getProp'\nimport isNumber from 'crocks/predicates/isNumber'\nimport isString from 'crocks/predicates/isString'\nimport safe from 'crocks/Maybe/safe'\nimport safeLift from 'crocks/Maybe/safeLift'\n\nconst { Nothing, Just } = Maybe\n\n// double :: Number -> Number\nconst double =\n  x => x + x\n\n// chainNumber :: Maybe a -> Maybe Number\nconst chainNumber =\n  chain(safe(isNumber))\n\n// doubleValue :: a -> Maybe Number\nconst doubleValue = compose(\n  chain(safeLift(isNumber, double)),\n  getProp('value')\n)\n\nchainNumber(Just(45))\n//=> Just 45\n\nchainNumber(Nothing())\n//=> Nothing\n\nJust(45)\n  .chain(safe(isString))\n//=> Nothing\n\ndoubleValue(undefined)\n//=> Nothing\n\ndoubleValue({ value: '45' })\n//=> Nothing\n\ndoubleValue({ number: 45 })\n//=> Nothing\n\ndoubleValue({ value: 45 })\n//=> Just 90\n")),Object(r.b)("h3",{id:"coalesce"},"coalesce"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a ~> ((() -> b), (a -> b))) -> Maybe b\n")),Object(r.b)("p",null,"When one would like to ",Object(r.b)("a",{parentName:"p",href:"#option"},Object(r.b)("inlineCode",{parentName:"a"},"option"))," a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," but would like to remain\nwithin a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," type, ",Object(r.b)("inlineCode",{parentName:"p"},"coalesce")," can be used. ",Object(r.b)("inlineCode",{parentName:"p"},"coalesce")," expects two functions\nfor its inputs."),Object(r.b)("p",null,"The first function is used when invoked on a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," and will return\na ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," instance wrapping the result of the function. The second function is\nused when ",Object(r.b)("inlineCode",{parentName:"p"},"coalesce")," is invoked on a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," and is used to map the original value,\nreturning a new ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," instance wrapping the result of the second function."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport compose from 'crocks/helpers/compose'\nimport composeK from 'crocks/helpers/composeK'\nimport coalesce from 'crocks/pointfree/coalesce'\nimport constant from 'crocks/combinators/constant'\nimport getProp from 'crocks/Maybe/getProp'\nimport identity from 'crocks/combinators/identity'\nimport isString from 'crocks/predicates/isString'\nimport map from 'crocks/pointfree/map'\nimport objOf from 'crocks/helpers/objOf'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Nothing, Just } = Maybe\n\n// shout :: String -> String\nconst shout =\n  x => x.toUpperCase()\n\n// defaultString :: Maybe String -> Maybe String\nconst defaultString =\n  coalesce(constant(''), identity)\n\n// shoutOut :: String -> Object\nconst shoutOut = compose(\n  objOf('shout'),\n  shout\n)\n\n// stringValue :: a -> Maybe String\nconst stringValue = composeK(\n  safe(isString),\n  getProp('value')\n)\n\n// shoutValue :: a -> Maybe Object\nconst shoutValue = compose(\n  map(shoutOut),\n  defaultString,\n  stringValue\n)\n\nJust(76)\n  .coalesce(constant(0), identity)\n//=> Just 76\n\nNothing()\n  .coalesce(constant(0), identity)\n//=> Just 0\n\nshoutValue({ value: 'hello' })\n//=> Just { shout: 'HELLO' }\n\nshoutValue(undefined)\n//=> Just { shout: '' }\n\nshoutValue({ value: 49 })\n//=> Just { shout: '' }\n\nshoutValue({})\n//=> Just { shout: '' }\n")),Object(r.b)("h3",{id:"bichain"},"bichain"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a ~> ((() -> Maybe b), (a -> Maybe b)) -> Maybe b\n")),Object(r.b)("p",null,"Combining a sequential series of transformations that capture disjunction can be\naccomplished with ",Object(r.b)("a",{parentName:"p",href:"#chain"},Object(r.b)("inlineCode",{parentName:"a"},"chain")),". Along the same lines, ",Object(r.b)("inlineCode",{parentName:"p"},"bichain")," allows you\nto do this from both ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing"))," and ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just")),". ",Object(r.b)("inlineCode",{parentName:"p"},"bichain")," expects\ntwo unary, ",Object(r.b)("inlineCode",{parentName:"p"},"Either")," returning functions as its arguments. When invoked on\na ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing"))," instance, ",Object(r.b)("inlineCode",{parentName:"p"},"bichain")," will use\nthe left, or first, function that can return either a ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing"))," or\na ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," instance. When called on a ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," instance, it\nwill behave exactly as ",Object(r.b)("a",{parentName:"p",href:"#chain"},Object(r.b)("inlineCode",{parentName:"a"},"chain"))," would with the right, or\nsecond, function."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport bichain from 'crocks/pointfree/bichain'\nimport constant from 'crocks/combinators/constant'\n\nconst { Nothing, Just } = Maybe\n\n// swapMaybe :: Maybe a -> Maybe b\nconst swapMaybe = bichain(\n  constant(Just('nothing')),\n  Nothing\n)\n\nswapMaybe(Nothing())\n//=> Just Nothing\n\nswapMaybe(Just('just'))\n//=> Nothing\n")),Object(r.b)("h3",{id:"option"},"option"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a ~> a -> a\n")),Object(r.b)("p",null,'Used as the primary way to "fold" a value out of a ',Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),", ",Object(r.b)("inlineCode",{parentName:"p"},"option")," expects a\ndefault value. The default value provided will be returned when ",Object(r.b)("inlineCode",{parentName:"p"},"option")," is\ninvoked on a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," instance. When invoked on a ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),", the underlying value\nis returned, discarding the provided default value. ",Object(r.b)("inlineCode",{parentName:"p"},"option"),' is typically ran\nat the "edge" of a flow, to provide default values for complicated\nrepresentations of disjunction.'),Object(r.b)("p",null,"When the need to immediately map the result of optioning a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," arises,\nthen ",Object(r.b)("a",{parentName:"p",href:"#either"},Object(r.b)("inlineCode",{parentName:"a"},"either"))," may be employed to combine it in one operation."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nconst { Nothing, Just } = Maybe\n\nNothing()\n  .option(0)\n//=> 0\n\nJust(99)\n  .option(0)\n//=> 99\n")),Object(r.b)("h3",{id:"either"},"either"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"Maybe a ~> ((() -> b), (a -> b)) -> b\n")),Object(r.b)("p",null,"Used to provide a means to map a given ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance while optioning out the\nwrapped value. ",Object(r.b)("a",{parentName:"p",href:"#option"},Object(r.b)("inlineCode",{parentName:"a"},"option"))," can handle most cases for optioning ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),",\nbut does not provide a means to map a given value at the time of\noptioning. ",Object(r.b)("inlineCode",{parentName:"p"},"either")," expects two functions as its arguments. The first is a\npointed function that will be used when invoked on a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),". While the second\nwill map the value wrapped in a given ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," and return the result of that\nmapping."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport either from 'crocks/pointfree/either'\n\nconst { Nothing, Just } = Maybe\n\n// wrap :: a -> [ a ]\nconst wrap =\n  x => [ x ]\n\n// empty :: () -> [ a ]\nconst empty =\n  () => []\n\n// toArray :: Maybe a -> [ a ]\nconst toArray =\n  either(empty, wrap)\n\ntoArray(Just(56))\n//=> [ 56 ]\n\ntoArray(Nothing())\n//=> []\n")),Object(r.b)("h2",{id:"helper-functions"},"Helper Functions"),Object(r.b)("h3",{id:"find"},"find"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/find")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"find :: Foldable f => ((a -> Boolean) | Pred) -> f a -> Maybe a\n")),Object(r.b)("p",null,"Using a provided predicate function or a ",Object(r.b)("inlineCode",{parentName:"p"},"Pred")," datatype, ",Object(r.b)("inlineCode",{parentName:"p"},"find")," takes\na ",Object(r.b)("inlineCode",{parentName:"p"},"Foldable")," instance and executes for every value in the ",Object(r.b)("inlineCode",{parentName:"p"},"Foldable"),", skipping\nempty indexes. ",Object(r.b)("inlineCode",{parentName:"p"},"find")," then returns the first value it finds that passes the\npredicate. If found, ",Object(r.b)("inlineCode",{parentName:"p"},"find")," returns the value in a ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),", otherwise\na ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," is returned."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import find from 'crocks/Maybe/find'\nimport Pred from 'crocks/Pred'\nimport isNumber from 'crocks/predicates/isNumber'\n\n// isEven :: Number -> Boolean\nconst isEven =\n  x => x % 2 === 0\n\n// largeNumber :: Pred a\nconst largeNumber =\n  Pred(isNumber)\n    .concat(Pred(x => x > 100))\n\nfind(largeNumber, [ 10, '12', 150, 200, 2000 ])\n//=> Just 150\n\nfind(largeNumber, [ 1, 2, 3, 4, 5 ])\n//=> Nothing\n\nfind(isEven, [ 1, 2, 3, 4, 5 ])\n//=> Just 2\n")),Object(r.b)("h3",{id:"getpath"},"getPath"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/getPath")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"getPath :: [ (String | Integer) ] -> a -> Maybe b\n")),Object(r.b)("p",null,"While ",Object(r.b)("a",{parentName:"p",href:"#getprop"},Object(r.b)("inlineCode",{parentName:"a"},"getProp"))," is good for simple, single-level structures, there\nmay come a time when you have to work with nested POJOs or Arrays. When you run\ninto this situation, just pull in ",Object(r.b)("inlineCode",{parentName:"p"},"getPath")," (formally known as ",Object(r.b)("inlineCode",{parentName:"p"},"propPath"),") and\npass it a left-to-right traversal path of keys, indices or a combination of\nboth. This will kick you back a function that behaves just\nlike ",Object(r.b)("a",{parentName:"p",href:"#getprop"},Object(r.b)("inlineCode",{parentName:"a"},"getProp")),". You pass it some data, and it will attempt to\nresolve your provided path. If the path is valid, it will return the value\nresiding there (",Object(r.b)("inlineCode",{parentName:"p"},"null")," and ",Object(r.b)("inlineCode",{parentName:"p"},"NaN")," included!) in a ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),'. But, if at any point,\nthat path "breaks", it will give you back a ',Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import composeK from 'crocks/helpers/composeK'\nimport isString from 'crocks/predicates/isString'\nimport getPath from 'crocks/Maybe/getPath'\nimport safe from 'crocks/Maybe/safe'\n\n// getFirstValue :: a -> Maybe b\nconst getFirstValue =\n  getPath([ 'value', 0 ])\n\n// getStringFirst :: a -> Maybe String\nconst getStringFirst = composeK(\n  safe(isString),\n  getFirstValue\n)\n\ngetFirstValue({ value: [] })\n//=> Nothing\n\ngetFirstValue({ value: 84 })\n//=> Nothing\n\ngetFirstValue(undefined)\n//=> Nothing\n\ngetFirstValue({ value: [ 'a', 'b' ] })\n//=> Just \"a\"\n\ngetStringFirst(false)\n//=> Nothing\n\ngetStringFirst({ towel: true })\n//=> Nothing\n\ngetStringFirst({ value: [ 0, 54 ] })\n//=> Nothing\n\ngetStringFirst({ value: [ 'nice', 'jobb' ] })\n//=> Just \"nice\"\n")),Object(r.b)("h3",{id:"getprop"},"getProp"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/getProp")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"getProp :: (String | Integer) -> a -> Maybe b\n")),Object(r.b)("p",null,"If you want some safety around pulling a value out of an ",Object(r.b)("inlineCode",{parentName:"p"},"Object")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Array")," with\na single key or index, you can always reach for ",Object(r.b)("inlineCode",{parentName:"p"},"getProp"),", previously known\nas ",Object(r.b)("inlineCode",{parentName:"p"},"prop"),". Well, as long as you are working with non-nested data that is. Just\ntell ",Object(r.b)("inlineCode",{parentName:"p"},"getProp")," either the key or index you are interested in, and you will get\nback a function that will take anything and return a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," with the wrapped\nvalue if the key/index is defined. If the key/index is not defined, you will get\nback a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import composeK from 'crocks/helpers/composeK'\nimport getProp from 'crocks/Maybe/getProp'\n\n// getValue :: a -> Maybe b\nconst getValue =\n  getProp('value')\n\n// getHead :: a -> Maybe b\nconst getHead =\n  getProp(0)\n\n// getFirstValue :: a -> Maybe b\nconst getFirstValue = composeK(\n  getHead,\n  getValue\n)\n\ngetValue({ some: false })\n//=> Nothing\n\ngetValue(undefined)\n//=> Nothing\n\ngetValue({ value: 'correct' })\n//=> Just \"correct\"\n\ngetFirstValue({ value: [] })\n//=> Nothing\n\ngetFirstValue({ value: 84 })\n//=> Nothing\n\ngetFirstValue(null)\n//=> Nothing\n\ngetFirstValue({ value: [ 'a', 'b' ] })\n//=> Just \"a\"\n")),Object(r.b)("h3",{id:"safe"},"safe"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/safe")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"safe :: ((b -> Boolean) | Pred) -> b -> Maybe a\n")),Object(r.b)("p",null,"When using a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),", it is a common practice to lift into a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," or\na ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," depending on a condition on the value to be lifted.  It is so\ncommon that it warrants a function, and that function is called ",Object(r.b)("inlineCode",{parentName:"p"},"safe"),". Provide\na predicate (a function that returns a Boolean) or a ",Object(r.b)("a",{parentName:"p",href:"./Pred"},Object(r.b)("inlineCode",{parentName:"a"},"Pred"))," datatype\nand the value to be lifted. The value will be evaluated against the predicate,\nand will lift it into a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," if true and a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," if false."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Pred from 'crocks/Pred'\n\nimport isArray from 'crocks/predicates/isArray'\nimport safe from 'crocks/Maybe/safe'\n\n// length :: Array -> Number\nconst length =\n  x => x.length\n\n// lte2 :: Number -> Boolean\nconst lte2 =\n  x => x <= 2\n\n// isSmall :: Pred a\nconst isSmall =\n  Pred(isArray)\n    .concat(Pred(lte2).contramap(length))\n\nsafe(lte2, 87)\n//=> Nothing\n\nsafe(lte2, 1)\n//=> Just 1\n\nsafe(isArray, {})\n//=> Nothing\n\nsafe(isArray, [ 1, 2, 3 ])\n//=> Just [ 1, 2, 3 ]\n\nsafe(isSmall, [ 1, 2, 3 ])\n//=> Nothing\n\nsafe(isSmall, { ar: [ 1, 2, 3 ] })\n//=> Nothing\n\nsafe(isSmall, null)\n//=> Nothing\n\nsafe(isSmall, [ 1, 2 ])\n//=> Just [ 1, 2 ]\n")),Object(r.b)("h3",{id:"safeafter"},"safeAfter"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/safeAfter")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"safeAfter :: ((b -> Boolean) | Pred) -> (a -> b) -> a -> Maybe b\n")),Object(r.b)("p",null,"Many times, you might want to lift the result of a function into a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," based\non some predicate. This may be because some parts of our code might return unsafe values for\nfurther computations we may like to perform. Similar to ",Object(r.b)("a",{parentName:"p",href:"#safe"},Object(r.b)("inlineCode",{parentName:"a"},"safe")),", you pass either a\n",Object(r.b)("a",{parentName:"p",href:"./Pred"},Object(r.b)("inlineCode",{parentName:"a"},"Pred"))," or a predicate function, along with a unary function. ",Object(r.b)("inlineCode",{parentName:"p"},"safeAfter")," then gives\nyou a new  function, which when invoked evaluates the predicate against the result of executing\nthe unary function. This result is then lifted into a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," if the predicate evaluates\nto ",Object(r.b)("inlineCode",{parentName:"p"},"true"),", or a ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing")," if it returns ",Object(r.b)("inlineCode",{parentName:"p"},"false")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Pred from 'crocks/Pred'\nimport curry from 'crocks/helpers/curry'\nimport isDefined from 'crocks/predicates/isDefined'\nimport isNumber from 'crocks/predicates/isNumber'\nimport safeAfter from 'crocks/Maybe/safeAfter'\n\n// prop :: String -> Object -> a | undefined\nconst prop = curry(\n  (key, x) => x[key]\n)\n\n// divide :: Number -> Number -> Number\nconst divide = curry(\n  (x, y) => x / y\n)\n\n// safeDivide :: Number -> Number -> Maybe FiniteNumber\nconst safeDivide = curry(\n  x => safeAfter(isFinite, divide(x))\n)\n\n// isValid :: Pred a\nconst isValid =\n  Pred(isDefined)\n    .concat(Pred(isNumber))\n\n// safePropNumber :: String -> Object -> Maybe Number\nconst validProp = curry(\n  key => safeAfter(isValid, prop(key))\n)\n\ndivide(3, 0)\n//=> Infinity\n\nsafeDivide(3, 0)\n//=> Nothing\n\ndivide(3, 1)\n//=> 3\n\nsafeDivide(3, 1)\n//=> Just 3\n\nprop('a', { b: 32 })\n//=> undefined\n\nprop('a', { a: 'thirty-two' })\n//=> 'thirty-two'\n\nprop('a', { a: 32 })\n//=> 32\n\nvalidProp('a', { a: 'thirty-two' })\n//=> Nothing\n\nvalidProp('a', { b: 32 })\n//=> Nothing\n\nvalidProp('a', { a: 32 })\n//=> Just 32\n")),Object(r.b)("h3",{id:"safelift"},"safeLift"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/safeLift")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"safeLift :: ((c -> Boolean) | Pred) -> (a -> b) -> c -> Maybe b\n")),Object(r.b)("p",null,"While ",Object(r.b)("a",{parentName:"p",href:"#safe"},Object(r.b)("inlineCode",{parentName:"a"},"safe"))," is used to lift a value into a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),", you can reach\nfor ",Object(r.b)("inlineCode",{parentName:"p"},"safeLift")," when you want to run a function in the safety of\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," context. Just like ",Object(r.b)("a",{parentName:"p",href:"#safe"},Object(r.b)("inlineCode",{parentName:"a"},"safe")),", you pass it either\na ",Object(r.b)("a",{parentName:"p",href:"./Pred"},Object(r.b)("inlineCode",{parentName:"a"},"Pred"))," or a predicate function to determine if you get a ",Object(r.b)("inlineCode",{parentName:"p"},"Just")," or\na ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),", but then instead of a value, you pass it a unary\nfunction. ",Object(r.b)("inlineCode",{parentName:"p"},"safeLift")," will then give you back a new function that will first\nlift its argument into a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," and then maps your original function over\nthe result."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Pred from 'crocks/Pred'\n\nimport isNumber from 'crocks/predicates/isNumber'\nimport safeLift from 'crocks/Maybe/safeLift'\n\n// doubleOf :: Number -> Number\nconst doubleOf =\n  x => x * 2\n\n// halfOf :: Number -> Number\nconst halfOf =\n  x => x / 2\n\n// gt100 :: Number -> Boolean\nconst gt100 =\n  x => x > 100\n\n// safeDouble :: a -> Maybe Number\nconst safeDouble =\n  safeLift(isNumber, doubleOf)\n\n// isLargeNumber :: Pred a\nconst isLargeNumber =\n  Pred(isNumber)\n    .concat(Pred(gt100))\n\n// halfLarge :: a -> Maybe Number\nconst halfLarge =\n  safeLift(isLargeNumber, halfOf)\n\nsafeDouble(null)\n// Nothing\n\nsafeDouble('33')\n// Nothing\n\nsafeDouble(33)\n// Just 66\n\nhalfLarge('1000')\n// Nothing\n\nhalfLarge(100)\n// Nothing\n\nhalfLarge(false)\n// Nothing\n\nhalfLarge(786)\n// Just 383\n\nhalfLarge(100)\n// Nothing\n\nhalfLarge(false)\n// Nothing\n")),Object(r.b)("h2",{id:"transformation-functions"},"Transformation Functions"),Object(r.b)("h3",{id:"eithertomaybe"},"eitherToMaybe"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/eitherToMaybe")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"eitherToMaybe :: Either b a -> Maybe a\neitherToMaybe :: (a -> Either c b) -> a -> Maybe b\n")),Object(r.b)("p",null,"Used to transform a given ",Object(r.b)("a",{parentName:"p",href:"./Either"},Object(r.b)("inlineCode",{parentName:"a"},"Either"))," instance to a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance\nor flatten a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," of ",Object(r.b)("inlineCode",{parentName:"p"},"Either")," into a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," when chained, ",Object(r.b)("inlineCode",{parentName:"p"},"eitherToMaybe")," will\nturn a ",Object(r.b)("a",{parentName:"p",href:"./Either#right"},Object(r.b)("inlineCode",{parentName:"a"},"Right"))," instance into a ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," wrapping the original\nvalue contained in the ",Object(r.b)("a",{parentName:"p",href:"./Either#right"},Object(r.b)("inlineCode",{parentName:"a"},"Right")),".\nAll ",Object(r.b)("a",{parentName:"p",href:"./Either#left"},Object(r.b)("inlineCode",{parentName:"a"},"Left"))," instances will map to a ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing")),", mapping the\noriginally contained value to a ",Object(r.b)("inlineCode",{parentName:"p"},"Unit"),". Values on the ",Object(r.b)("a",{parentName:"p",href:"./Either#left"},Object(r.b)("inlineCode",{parentName:"a"},"Left"))," will be\nlost and as such this transformation is considered lossy in that regard."),Object(r.b)("p",null,"Like all ",Object(r.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(r.b)("inlineCode",{parentName:"p"},"eitherToMaybe")," has two possible\nsignatures and will behave differently when passed either\nan ",Object(r.b)("a",{parentName:"p",href:"./Either"},Object(r.b)("inlineCode",{parentName:"a"},"Either"))," instance or a function that returns an instance\nof ",Object(r.b)("a",{parentName:"p",href:"./Either"},Object(r.b)("inlineCode",{parentName:"a"},"Either")),". When passed the instance, a transformed ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," is\nreturned. When passed an ",Object(r.b)("a",{parentName:"p",href:"./Either"},Object(r.b)("inlineCode",{parentName:"a"},"Either"))," returning function, a function will\nbe returned that takes a given value and returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport Either from 'crocks/Either'\n\nimport eitherToMaybe from 'crocks/Maybe/eitherToMaybe'\n\nimport constant from 'crocks/combinators/constant'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\n\nconst { Nothing, Just } = Maybe\n\nconst { Left, Right } = Either\n\n// someNumber :: a -> Either String Number\nconst someNumber = ifElse(\n  isNumber,\n  Right,\n  constant(Left('Nope'))\n)\n\neitherToMaybe(Left(56))\n//=> Nothing\n\neitherToMaybe(Right('correct'))\n//=> Just \"correct\"\n\nJust('ten')\n  .chain(eitherToMaybe(someNumber))\n//=> Nothing\n\nNothing()\n  .chain(eitherToMaybe(someNumber))\n//=> Nothing\n\nJust(99)\n  .chain(eitherToMaybe(someNumber))\n//=> Just 99\n\nJust(Right(42))\n  .chain(eitherToMaybe)\n// Just 42\n\nJust(Left(24))\n  .chain(eitherToMaybe)\n// Nothing\n")),Object(r.b)("h3",{id:"firsttomaybe"},"firstToMaybe"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/firstToMaybe")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"firstToMaybe :: First a -> Maybe a\nfirstToMaybe :: (a -> First b) -> a -> Maybe b\n")),Object(r.b)("p",null,"Used to transform a given ",Object(r.b)("a",{parentName:"p",href:"../monoids/First"},Object(r.b)("inlineCode",{parentName:"a"},"First"))," instance to a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance or\nflatten a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," of ",Object(r.b)("inlineCode",{parentName:"p"},"First")," into a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," when chained, ",Object(r.b)("inlineCode",{parentName:"p"},"firstToMaybe")," will\nturn a non-empty instance into a ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," wrapping the original value\ncontained within the ",Object(r.b)("a",{parentName:"p",href:"../monoids/First"},Object(r.b)("inlineCode",{parentName:"a"},"First")),". All empty instances will map to\na ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing")),"."),Object(r.b)("p",null,"Like all ",Object(r.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(r.b)("inlineCode",{parentName:"p"},"firstToMaybe")," has two possible\nsignatures and will behave differently when passed either\na ",Object(r.b)("a",{parentName:"p",href:"../monoids/First"},Object(r.b)("inlineCode",{parentName:"a"},"First"))," instance or a function that returns an instance\nof ",Object(r.b)("a",{parentName:"p",href:"../monoids/First"},Object(r.b)("inlineCode",{parentName:"a"},"First")),". When passed the instance, a transformed ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," is\nreturned. When passed a ",Object(r.b)("a",{parentName:"p",href:"../monoids/First"},Object(r.b)("inlineCode",{parentName:"a"},"First"))," returning function, a function will be\nreturned that takes a given value and returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport First from 'crocks/First'\nimport firstToMaybe from 'crocks/Maybe/firstToMaybe'\n\nimport mconcat from 'crocks/helpers/mconcat'\n\nconst { Nothing, Just } = Maybe\n\n// firstValue :: [ a ] -> First a\nconst firstValue =\n  mconcat(First)\n\nfirstToMaybe(First.empty())\n//=> Nothing\n\nfirstToMaybe(First('winner'))\n//=> Just \"Winner\"\n\nNothing()\n  .chain(firstToMaybe(firstValue))\n//=> Nothing\n\nJust([])\n  .chain(firstToMaybe(firstValue))\n//=> Nothing\n\nJust([ 'first', 'second', 'third' ])\n  .chain(firstToMaybe(firstValue))\n//=> Just \"first\"\n\nJust(First('first'))\n  .chain(firstToMaybe)\n//=> Just \"first\"\n\nJust(First.empty())\n  .chain(firstToMaybe)\n//=> Nothing\n")),Object(r.b)("h3",{id:"lasttomaybe"},"lastToMaybe"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/lastToMaybe")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"lastToMaybe :: Last a -> Maybe a\nlastToMaybe :: (a -> Last b) -> a -> Maybe b\n")),Object(r.b)("p",null,"Used to transform a given ",Object(r.b)("a",{parentName:"p",href:"../monoids/Last"},Object(r.b)("inlineCode",{parentName:"a"},"Last"))," instance to a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance or\nflatten a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," of ",Object(r.b)("inlineCode",{parentName:"p"},"Last")," into a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," when chained, ",Object(r.b)("inlineCode",{parentName:"p"},"lastToMaybe")," will\nturn a non-empty instance into a ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," wrapping the original value\ncontained within the ",Object(r.b)("a",{parentName:"p",href:"../monoids/Last"},Object(r.b)("inlineCode",{parentName:"a"},"Last")),". All empty instances will map to a\n",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing")),"."),Object(r.b)("p",null,"Like all ",Object(r.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(r.b)("inlineCode",{parentName:"p"},"lastToMaybe")," has two possible\nsignatures and will behave differently when passed either\na ",Object(r.b)("a",{parentName:"p",href:"../monoids/Last"},Object(r.b)("inlineCode",{parentName:"a"},"Last"))," instance or a function that returns an instance\nof ",Object(r.b)("a",{parentName:"p",href:"../monoids/Last"},Object(r.b)("inlineCode",{parentName:"a"},"Last")),". When passed the instance, a transformed ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," is returned.\nWhen passed a ",Object(r.b)("a",{parentName:"p",href:"../monoids/Last"},Object(r.b)("inlineCode",{parentName:"a"},"Last"))," returning function, a function will be returned\nthat takes a given value and returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport Last from 'crocks/Last'\nimport lastToMaybe from 'crocks/Maybe/lastToMaybe'\n\nimport mconcat from 'crocks/helpers/mconcat'\n\nconst { Nothing, Just } = Maybe\n\n// lastValue :: [ a ] -> Last a\nconst lastValue =\n  mconcat(Last)\n\nlastToMaybe(Last.empty())\n//=> Nothing\n\nlastToMaybe(Last('the end'))\n//=> Just \"the end\"\n\nNothing()\n  .chain(lastToMaybe(lastValue))\n//=> Nothing\n\nJust([])\n  .chain(lastToMaybe(lastValue))\n//=> Nothing\n\nJust([ 'first', 'second', 'third' ])\n  .chain(lastToMaybe(lastValue))\n//=> Just \"third\"\n\nJust(Last('last'))\n  .chain(lastToMaybe)\n//=> Just \"last\"\n\nJust(Last.empty())\n  .chain(lastToMaybe)\n//=> Nothing\n")),Object(r.b)("h3",{id:"maybetoarray"},"maybeToArray"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/maybeToArray")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"maybeToArray :: Maybe a -> [ a ]\nmaybeToArray :: (a -> Maybe b) -> a -> [ b ]\n")),Object(r.b)("p",null,"Used to transform a given ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance to an ",Object(r.b)("inlineCode",{parentName:"p"},"Array")," or\nflatten an ",Object(r.b)("inlineCode",{parentName:"p"},"Array")," of ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," into an ",Object(r.b)("inlineCode",{parentName:"p"},"Array")," when chained, ",Object(r.b)("inlineCode",{parentName:"p"},"maybeToArray")," will\nturn a ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," instance into a single element ",Object(r.b)("inlineCode",{parentName:"p"},"Array"),", wrapping the\noriginal value contained within\nthe ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," instance. All ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing"))," instances will map to an\nempty ",Object(r.b)("inlineCode",{parentName:"p"},"Array"),"."),Object(r.b)("p",null,"Like all ",Object(r.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(r.b)("inlineCode",{parentName:"p"},"maybeToArray")," has two possible\nsignatures and will behave differently when passed either\na ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance or a function that returns an instance of ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),". When\npassed the instance, a transformed ",Object(r.b)("inlineCode",{parentName:"p"},"Array")," is returned. When passed\na ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," returning function, a function will be returned that takes a given\nvalue and returns an ",Object(r.b)("inlineCode",{parentName:"p"},"Array"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport chain from 'crocks/pointfree/chain'\nimport composeK from 'crocks/helpers/composeK'\nimport getProp from 'crocks/Maybe/getProp'\nimport isString from 'crocks/predicates/isString'\nimport safe from 'crocks/Maybe/safe'\n\nimport maybeToArray from 'crocks/Maybe/maybeToArray'\n\nconst { Nothing, Just } = Maybe\n\nmaybeToArray(Nothing())\n//=> []\n\nmaybeToArray(Just(33))\n//=> [ 33 ]\n\n// flatten :: [ Maybe a ] -> [ a ]\nconst flatten =\n  chain(maybeToArray)\n\nflatten([ Just(33), Just('text') ])\n//=> [ 33, 'text' ]\n\nflatten([ Just('left'), Nothing(), Just('right') ])\n//=> [ 'left', 'right' ]\n\n// getUser :: a -> Maybe String\nconst getUser = composeK(\n  safe(isString),\n  getProp('user')\n)\n\n// getUsers :: [ * ] -> [ String ]\nconst getUsers =\n  chain(maybeToArray(getUser))\n\n// data :: [ * ]\nconst data = [\n  { user: 'Allison' },\n  'Ben',\n  { user: 'Beth' },\n  null,\n  { user: 'Claire' }\n]\n\ngetUsers(data)\n//=> [ 'Allison', 'Beth', 'Claire' ]\n")),Object(r.b)("h3",{id:"resulttomaybe"},"resultToMaybe"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"crocks/Maybe/resultToMaybe")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},"resultToMaybe :: Result e a -> Maybe a\nresultToMaybe :: (a -> Result e b) -> a -> Maybe b\n")),Object(r.b)("p",null,"Used to transform a given ",Object(r.b)("a",{parentName:"p",href:"./Result"},Object(r.b)("inlineCode",{parentName:"a"},"Result"))," instance to a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," instance\nor flatten a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," of ",Object(r.b)("a",{parentName:"p",href:"./Result"},Object(r.b)("inlineCode",{parentName:"a"},"Result"))," into a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," when\nchained, ",Object(r.b)("inlineCode",{parentName:"p"},"resultToMaybe")," will turn an ",Object(r.b)("inlineCode",{parentName:"p"},"Ok")," instance into a ",Object(r.b)("a",{parentName:"p",href:"#just"},Object(r.b)("inlineCode",{parentName:"a"},"Just"))," wrapping\nthe original value contained in the ",Object(r.b)("inlineCode",{parentName:"p"},"Ok"),".\nAll ",Object(r.b)("inlineCode",{parentName:"p"},"Err")," instances will map to a ",Object(r.b)("a",{parentName:"p",href:"#nothing"},Object(r.b)("inlineCode",{parentName:"a"},"Nothing")),", mapping the originally\ncontained value to a ",Object(r.b)("inlineCode",{parentName:"p"},"Unit"),". Values on the ",Object(r.b)("inlineCode",{parentName:"p"},"Err")," will be lost and as such this\ntransformation is considered lossy in that regard."),Object(r.b)("p",null,"Like all ",Object(r.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(r.b)("inlineCode",{parentName:"p"},"resultToMaybe")," has two possible\nsignatures and will behave differently when passed either an ",Object(r.b)("a",{parentName:"p",href:"./Result"},Object(r.b)("inlineCode",{parentName:"a"},"Result"))," instance\nor a function that returns an instance of ",Object(r.b)("a",{parentName:"p",href:"./Result"},Object(r.b)("inlineCode",{parentName:"a"},"Result")),". When passed the instance,\na transformed ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe")," is returned. When passed a ",Object(r.b)("a",{parentName:"p",href:"./Result"},Object(r.b)("inlineCode",{parentName:"a"},"Result"))," returning function,\na function will be returned that takes a given value and returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Maybe"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"runkit",runkit:!0},"import Maybe from 'crocks/Maybe'\n\nimport Result from 'crocks/Result'\n\nimport resultToMaybe from 'crocks/Maybe/resultToMaybe'\n\nimport identity from 'crocks/combinators/identity'\nimport tryCatch from 'crocks/Result/tryCatch'\n\nconst { Nothing, Just } = Maybe\n\nconst { Err, Ok } = Result\n\nfunction datErrTho() {\n  throw new Error('something amiss')\n}\n\nresultToMaybe(Err('this is bad'))\n//=> Nothing\n\nresultToMaybe(Ok('this is great'))\n//=> Just \"this is great\"\n\nNothing()\n  .chain(resultToMaybe(identity))\n//=> Nothing\n\nJust('so good')\n  .chain(resultToMaybe(tryCatch(datErrTho)))\n//=> Nothing\n\nJust('so good')\n  .chain(resultToMaybe(Ok))\n//=> Just \"so good\"\n\nJust(Result('in time!'))\n  .chain(resultToMaybe)\n//=> Just \"in time!\"\n\nJust(Err('to be human'))\n  .chain(resultToMaybe)\n//=> Nothing\n")))}p.isMDXComponent=!0}}]);