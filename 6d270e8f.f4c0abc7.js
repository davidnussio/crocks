(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{100:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return u}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=r.a.createContext({}),b=function(e){var n=r.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},m=function(e){var n=b(e.components);return r.a.createElement(s.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},d=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),m=b(t),d=a,u=m["".concat(o,".").concat(d)]||m[d]||l[d]||i;return t?r.a.createElement(u,c(c({ref:n},s),{},{components:t})):r.a.createElement(u,c({ref:n},s))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var c={};for(var p in n)hasOwnProperty.call(n,p)&&(c[p]=n[p]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<i;s++)o[s]=t[s];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},70:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return p})),t.d(n,"default",(function(){return b}));var a=t(2),r=t(6),i=(t(0),t(100)),o={title:"Pair",description:"Canonical Product Type",layout:"guide",functions:["branch","fanout","fst","snd","topairs","writertopair"],weight:100},c={unversionedId:"crocks/Pair",id:"crocks/Pair",isDocsHomePage:!1,title:"Pair",description:"Canonical Product Type",source:"@site/docs/crocks/Pair.md",slug:"/crocks/Pair",permalink:"/crocks/docs/docs/crocks/Pair",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Pair.md",version:"current",sidebar:"sidebar",previous:{title:"Maybe",permalink:"/crocks/docs/docs/crocks/Maybe"},next:{title:"Pred",permalink:"/crocks/docs/docs/crocks/Pred"}},p=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Instance Methods",id:"instance-methods",children:[{value:"equals",id:"equals",children:[]},{value:"concat",id:"concat",children:[]},{value:"map",id:"map",children:[]},{value:"bimap",id:"bimap",children:[]},{value:"ap",id:"ap",children:[]},{value:"chain",id:"chain",children:[]},{value:"sequence",id:"sequence",children:[]},{value:"traverse",id:"traverse",children:[]},{value:"extend",id:"extend",children:[]},{value:"swap",id:"swap",children:[]},{value:"fst",id:"fst",children:[]},{value:"snd",id:"snd",children:[]},{value:"toArray",id:"toarray",children:[]},{value:"merge",id:"merge",children:[]}]},{value:"Helper Functions",id:"helper-functions",children:[{value:"branch",id:"branch",children:[]},{value:"fanout",id:"fanout",children:[]},{value:"toPairs",id:"topairs",children:[]}]},{value:"Pointfree Functions",id:"pointfree-functions",children:[{value:"fst (pointfree)",id:"fst-pointfree",children:[]},{value:"snd (pointfree)",id:"snd-pointfree",children:[]}]},{value:"Transformation Functions",id:"transformation-functions",children:[{value:"writerToPair",id:"writertopair",children:[]}]}],s={rightToc:p};function b(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Pair")," allows the ability to represent two distinct values of different types.\nMuch like how ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Either"}),Object(i.b)("inlineCode",{parentName:"a"},"Either"))," is known as canonical Sum Type and defines the basis for\nall other Sum Types that ship with ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," is known as the canonical\nProduct Type and also at the heart of all Product Types in ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),"."),Object(i.b)("p",null,"As ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," is a ",Object(i.b)("inlineCode",{parentName:"p"},"Bifunctor"),", it can vary in each of the two types it represents.\nWhen used as a normal ",Object(i.b)("inlineCode",{parentName:"p"},"Functor"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," will always have a bias for the far\nright or second value, matching the pattern of the other ADTs in ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),". When\nmapped with a function, the function will only be applied to the second value,\nand will leave the first value untouched."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Pair")," also provides the ability to use  ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#ap"}),Object(i.b)("inlineCode",{parentName:"a"},"ap"))," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#chain"}),Object(i.b)("inlineCode",{parentName:"a"},"chain")),", but in order to\ncombine the resulting instances in a predictable, repeatable fashion the first\nvalues in the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"s must be ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup")," instances of the same type. When\napplied,  ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#ap"}),Object(i.b)("inlineCode",{parentName:"a"},"ap"))," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#chain"}),Object(i.b)("inlineCode",{parentName:"a"},"chain"))," will concatenate the ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),"s providing the result\nof the concatenation in the first position of the resulting ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"."),Object(i.b)("p",null,"A helpful benefit of the ",Object(i.b)("inlineCode",{parentName:"p"},"Bifunctor")," aspects ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," allows for defining parallel\ncomputations. There are many functions that ship with ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," that allow for\nparallelization such as ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#branch"}),Object(i.b)("inlineCode",{parentName:"a"},"branch")),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#merge"}),Object(i.b)("inlineCode",{parentName:"a"},"merge"))," and\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fanout"}),Object(i.b)("inlineCode",{parentName:"a"},"fanout")),". Using those helpers in conjunction with the ability to\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#bimap"}),Object(i.b)("inlineCode",{parentName:"a"},"bimap"))," functions over a given ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"s values."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport Sum from 'crocks/Sum'\nimport bimap from 'crocks/pointfree/bimap'\nimport branch from 'crocks/Pair/branch'\nimport compose from 'crocks/helpers/compose'\nimport mreduce from 'crocks/helpers/mreduce'\nimport merge from 'crocks/pointfree/merge'\n\n// negate :: a -> Boolean\nconst negate =\n  x => !x\n\n// inc :: Number -> Number\nconst inc =\n  x => x + 1\n\n// length :: Array -> Number\nconst length =\n  x => x.length\n\n// divide :: Number -> Number\nconst divide =\n  (x, y) => x / y\n\nPair(76, false)\n  .bimap(inc, negate)\n//=> Pair(77, true)\n\n// average :: [ Number ] -> Number\nconst average = compose(\n  merge(divide),\n  bimap(mreduce(Sum), length),\n  branch\n)\n\naverage([ 9, 77, 34 ])\n//=> 40\n")),Object(i.b)("h2",{id:"implements"},"Implements"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Setoid"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Functor"),",  ",Object(i.b)("inlineCode",{parentName:"p"},"Bifunctor"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Chain"),",\n",Object(i.b)("inlineCode",{parentName:"p"},"Traversable"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Extend")),Object(i.b)("h2",{id:"construction"},"Construction"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair :: (a, b) -> Pair a b\n")),Object(i.b)("p",null,"In order to construct a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),", two values of any type are required by the\nconstructor. The types of the arguments can, and often do, vary. None of the\nconstructors in crocks are curried by default, so both arguments must be\nprovided at the same time in order to construct the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"."),Object(i.b)("p",null,"Once both arguments are provided, the constructor will return a new ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance\nwith the first argument in the left portion and the second argument in the\nright position."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\n\nPair(34, false)\n//=> Pair Number Boolean\n\nPair(34, Pair(true, 'string'))\n//=> Pair Number (Pair Boolean String)\n")),Object(i.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(i.b)("h3",{id:"equals"},"equals"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b ~> c -> Boolean\n")),Object(i.b)("p",null,"Used to compare the underlying values of two ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instances for equality by\nvalue. ",Object(i.b)("inlineCode",{parentName:"p"},"equals")," takes any given argument and returns ",Object(i.b)("inlineCode",{parentName:"p"},"true")," if the passed\narguments is a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," with an underlying values both in the first and second are\nequal to the underlying values in the first and second  of the ",Object(i.b)("inlineCode",{parentName:"p"},"Maybe")," the\nmethod is being called on. If the passed argument is not a ",Object(i.b)("inlineCode",{parentName:"p"},"Maybe")," or the\nunderlying values are not equal, ",Object(i.b)("inlineCode",{parentName:"p"},"equals")," will return ",Object(i.b)("inlineCode",{parentName:"p"},"false"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport equals from 'crocks/pointfree/equals'\n\nPair({ num: 33 }, 'string')\n  .equals(Pair({ num: 33 }, 'string'))\n//=> true\n\nPair({ num: 33 }, 'string')\n  .equals(Pair({ num: 10 }, 'string'))\n//=> false\n\nPair({ num: 33 }, 'string')\n  .equals(Pair({ num: 33 }, 'different'))\n//=> false\n\nequals(Pair([ 1, 2 ], ''), [ 1, 2 ])\n//=> false\n")),Object(i.b)("h3",{id:"concat"},"concat"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Semigroup s, t => Pair s t ~> Pair s t -> Pair s t\n")),Object(i.b)("p",null,"When both underlying values of a given ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," are fixed to\na ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),", ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," can be used to concatenate another ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance\nwith underlying ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),"s of the same type and structure. Expecting\na ",Object(i.b)("inlineCode",{parentName:"p"},"Maybe")," wrapping a ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup")," of the same type, ",Object(i.b)("inlineCode",{parentName:"p"},"concat")," will give back a\nnew ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instancewrapping the result of combining the\nunderlying ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup")," instances."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport Maybe from 'crocks/Maybe'\nimport Sum from 'crocks/Sum'\n\nimport compose from 'crocks/helpers/compose'\nimport concat from 'crocks/pointfree/concat'\nimport fanout from 'crocks/Pair/fanout'\nimport flip from 'crocks/combinators/flip'\nimport getProp from 'crocks/Maybe/getProp'\nimport map from 'crocks/pointfree/map'\nimport mapReduce from 'crocks/helpers/mapReduce'\nimport option from 'crocks/pointfree/option'\n\nPair(Sum(3), [ 3 ])\n  .concat(Pair(Sum(10), [ 10 ]))\n//=> Pair( Sum 13, [ 3, 10 ] )\n\n// Person :: { name: String, age: Number }\n// peeps :: [ Person ]\nconst peeps = [\n  { name: 'Haskell', age: 82 },\n  { name: 'Heinrich', age: 81 },\n  { name: 'Maria', age: 93 }\n]\n\n// mapProp :: (String, (a -> b)) -> Object -> Maybe b\nconst mapProp = (key, fn) =>\n  compose(map(fn), getProp(key))\n\n// Combined :: Pair (Maybe [ String ]) (Maybe Sum)\n// splitPerson :: Person -> Combined\nconst splitPerson = fanout(\n  mapProp('name', x => [ x ]),\n  mapProp('age', Sum)\n)\n\n// empty :: Combined\nconst empty =\n  Pair(Maybe([]), Maybe(Sum.empty()))\n\n// combine :: [ Person ] -> Combined\nconst combine = mapReduce(\n  splitPerson,\n  flip(concat),\n  empty\n)\n\ncombine(peeps)\n  .bimap(option([]), option(Sum(0)))\n//=> Pair( [ \"Haskell\", \"Heinrich\", \"Maria\" ], Sum 256 )\n")),Object(i.b)("h3",{id:"map"},"map"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair c a ~> (a -> b) -> Pair c b\n")),Object(i.b)("p",null,"Used to apply transformations to values to the second portion of a\ngiven ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance. ",Object(i.b)("inlineCode",{parentName:"p"},"map")," takes a function that it will lift into the\ncontext of the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," and apply to it second value in the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),", returning a\nnew ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance. The new instance will contain the result of mapping in the\nsecond, leaving the value in the first untouched. If you need to map the first\nvalue, ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#bimap"}),Object(i.b)("inlineCode",{parentName:"a"},"bimap"))," can be used instead."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\n\nimport compose from 'crocks/helpers/compose'\nimport map from 'crocks/pointfree/map'\nimport merge from 'crocks/pointfree/merge'\nimport objOf from 'crocks/helpers/objOf'\n\n// length :: String -> Number\nconst length =\n  x => x.length\n\n// add10 :: Number -> Number\nconst add10 =\n  x => x + 10\n\n// keyedLength :: Pair String String -> Object\nconst keyedLength =\n  compose(merge(objOf), map(length))\n\nPair('number', 32)\n  .map(add10)\n//=> Pair(\"number\", 42)\n\nkeyedLength(\n  Pair('text', 'This is some text')\n)\n//=> { text: 17 }\n")),Object(i.b)("h3",{id:"bimap"},"bimap"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b ~> ((a -> c), (b -> d)) -> Pair c d\n")),Object(i.b)("p",null,"The types and values that make up a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," can vary independently in both the\nfirst and second portions of the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),". While ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#map"}),Object(i.b)("inlineCode",{parentName:"a"},"map"))," can be used to\napply these transformations, ",Object(i.b)("inlineCode",{parentName:"p"},"bimap")," allows for independent transformations\non both sides, in parallel."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"bimap")," takes two mapping functions as its arguments. The first function is used\nto map the first, while the second maps the second. ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," only provides a\nmeans to map the second's value exclusively using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#map"}),Object(i.b)("inlineCode",{parentName:"a"},"map")),". If the need\narises to map the first portion exclusively, use ",Object(i.b)("inlineCode",{parentName:"p"},"bimap")," passing the mapping\nfunction to the first argument and an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(i.b)("inlineCode",{parentName:"a"},"identity"))," to the second."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport Sum from 'crocks/Sum'\n\nimport compose from 'crocks/helpers/compose'\nimport bimap from 'crocks/pointfree/bimap'\nimport branch from 'crocks/Pair/branch'\nimport identity from 'crocks/combinators/identity'\nimport merge from 'crocks/pointfree/merge'\nimport mreduce from 'crocks/helpers/mreduce'\n\n// add10 :: Number -> Number\nconst add10 =\n  x => x + 10\n\n// divide :: (Number, Number) -> Number\nconst divide =\n  (x, y) => x / y\n\n// length :: [ Number ] -> Number\nconst length =\n  x => x.length\n\n// average :: [ Number ] -> Number\nconst average = compose(\n  merge(divide),\n  bimap(mreduce(Sum), length),\n  branch\n)\n\nPair(35, 'number')\n  .bimap(add10, identity)\n//=> Pair( 45, 'number' )\n\naverage([ 2, 3, 4 ])\n//=> 3\n")),Object(i.b)("h3",{id:"ap"},"ap"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Semigroup s => Pair s (a -> b) ~> Pair s a -> Pair s b\n")),Object(i.b)("p",null,"Short for apply, ",Object(i.b)("inlineCode",{parentName:"p"},"ap")," is used to apply a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance containing a value on\nits second portion to another ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance that contains a function in its\nsecond portion. The result of this application provides a new ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance\ncontaining the result in the second portion. ",Object(i.b)("inlineCode",{parentName:"p"},"ap")," requires that it is called on\nan instance that wraps a curried polyadic function in the second."),Object(i.b)("p",null,"An additional constraint when using ",Object(i.b)("inlineCode",{parentName:"p"},"ap")," is that the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," must contain\na ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup")," instance in its first. This is required for both the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," with\nthe function and the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," with the value to be applied. With\nboth ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroups")," being of the same type."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport liftA2 from 'crocks/helpers/liftA2'\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// NumberRec :: Pair [ Number ] Number\n\n// twentyThree :: NumberRec\nconst twentyThree =\n  Pair([ 23 ], 23)\n\n// seventySeven :: NumberRec\nconst seventySeven =\n  Pair([ 77 ], 77)\n\n// combine :: NumberRec -> NumberRec -> NumberRec\nconst combine =\n  liftA2(add)\n\ntwentyThree\n  .map(add)\n  .ap(seventySeven)\n// Pair( [ 23, 77 ], 100 )\n\ncombine(twentyThree, seventySeven)\n// Pair( [ 23, 77 ], 100 )\n")),Object(i.b)("h3",{id:"chain"},"chain"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Semigroup s => Pair s a ~> (a -> Pair s b) -> Pair s b\n")),Object(i.b)("p",null,"Combining a sequential series of transformations that allows for custom\naccumulation in addition to transforming a value. ",Object(i.b)("inlineCode",{parentName:"p"},"chain")," requires\na ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," returning function that contains a ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup")," in its first position.\nAs anadditional requirement, is that instances of the same ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup")," must\noccupy the first position of the source ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," and the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," returned by the\nfunction."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"const Pair = require('crocks/Pair')\n\nconst setProp = require('crocks/helpers/setProp')\nconst omit = require('crocks/helpers/omit')\n\n// addTmp :: (String, a, Object) -> Pair [ String ] Object\nconst addTmp = (key, value, x) =>\n  Pair([ key ], setProp(key, value, x))\n\n// add :: Object -> Pair [ String ] Object\nconst add = data => {\n  const { a, b } = data\n  return addTmp('sum', a + b, data)\n}\n\n// multiply :: Object -> Pair [ String ] Object\nconst multiply = data => {\n  const { a, b } = data\n  return addTmp('product', a * b, data)\n}\n\n// calc :: Object -> Object\nconst calc = data => {\n  const { product, sum } = data\n  return setProp('result', product - sum, data)\n}\n\n// flow :: Object -> Object\nconst flow = x =>\n  Pair([], x)\n    .chain(add)\n    .chain(multiply)\n    .map(calc)\n    .merge(omit)\n\nflow({ a: 34, b: 76 })\n//=> { a: 34, b: 76, result: 2474 }\n\nflow({ a: 10, b: 5 })\n//=> { a: 10, b: 5, result: 35 }\n")),Object(i.b)("h3",{id:"sequence"},"sequence"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Apply f => Pair a (f b) ~> (c -> f c) -> f (Pair a b)\nApplicative f => Pair a (f b) ~> TypeRep f -> f (Pair a b)\n")),Object(i.b)("p",null,"When an instance of ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," wraps an ",Object(i.b)("inlineCode",{parentName:"p"},"Apply")," instance in its second\nposition, ",Object(i.b)("inlineCode",{parentName:"p"},"sequence")," can be used to swap the type sequence. ",Object(i.b)("inlineCode",{parentName:"p"},"sequence")," requires\neither an ",Object(i.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or an ",Object(i.b)("inlineCode",{parentName:"p"},"Apply")," returning function is provided\nfor its argument."),Object(i.b)("p",null,"While it is not a requirement that the first position be occupied by\na ",Object(i.b)("inlineCode",{parentName:"p"},"Semigroup"),", in having an instance there sequencing back on a data structure\nwith multiple items can allow for accumulation then sequencing back."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"sequence")," can be derived from ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#traverse"}),Object(i.b)("inlineCode",{parentName:"a"},"traverse"))," by passing it an\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(i.b)("inlineCode",{parentName:"a"},"identity"))," function (",Object(i.b)("inlineCode",{parentName:"p"},"x => x"),")."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport Sum from 'crocks/Sum'\n\nimport bimap from 'crocks/pointfree/bimap'\nimport compose from 'crocks/helpers/compose'\nimport concat from 'crocks/pointfree/concat'\nimport flip from 'crocks/combinators/flip'\nimport mapReduce from 'crocks/helpers/mapReduce'\nimport sequence from 'crocks/pointfree/sequence'\n\n// pair :: Pair Number [ String ]\nconst pair =\n  Pair(1, [ 'a', 'b', 'c' ])\n\n// empty :: () -> Pair Sum String\nconst empty =\n  () => Pair(Sum.empty(), '')\n\n// seqArray :: Traversable t => t [ a ] -> [ t a ]\nconst seqArray =\n  sequence(Array)\n\n// toUpper :: String -> String\nconst toUpper =\n  x => x.toUpperCase()\n\n// combine :: [ Pair Number String ] -> Pair Sum String\nconst combine = mapReduce(\n  bimap(Sum, toUpper),\n  flip(concat),\n  empty()\n)\n\n// flow :: Pair Number [ String ] -> Pair Sum String\nconst flow =\n  compose(combine, seqArray)\n\nseqArray(pair)\n//=> [ Pair(1, \"a\"), Pair(1, \"b\"), Pair(1, \"c\") ]\n\nflow(pair)\n//=> Pair(Sum 3, \"ABC\")\n")),Object(i.b)("h3",{id:"traverse"},"traverse"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Apply f => Pair a b ~> ((d -> f d), (b -> f c)) -> f (Pair a c)\nApplicative f => Pair a b ~> (TypeRep f, (b -> f c)) -> f (Pair a c)\n")),Object(i.b)("p",null,'Used to apply the "effect" of an ',Object(i.b)("inlineCode",{parentName:"p"},"Apply")," to a value in the second position of\na ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),", ",Object(i.b)("inlineCode",{parentName:"p"},"traverse"),' combines both the "effects" of the ',Object(i.b)("inlineCode",{parentName:"p"},"Apply")," and\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," by returning a new instance of the ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),", wrapping the result of\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),'s "effect" on the value in the second position of the ',Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"traverse")," method requires either an ",Object(i.b)("inlineCode",{parentName:"p"},"Applicative TypeRep")," or an ",Object(i.b)("inlineCode",{parentName:"p"},"Apply"),' returning\nfunction as its first argument and a function that is used to apply the "effect"\nof the target ',Object(i.b)("inlineCode",{parentName:"p"},"Apply")," to the value in the second position of the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),'. The\n"effect" will only be applied to second value and leaves the first value\nuntouched. Both arguments must return an instance of the target ',Object(i.b)("inlineCode",{parentName:"p"},"Apply"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Maybe from 'crocks/Maybe'\nimport Pair from 'crocks/Pair'\n\nimport identity from 'crocks/combinators/identity'\nimport safe from 'crocks/Maybe/safe'\nimport traverse from 'crocks/pointfree/traverse'\n\nconst { Just, Nothing } = Maybe\n\n// isOdd :: Integer -> Boolean\nconst isOdd =\n  x => !!(x % 2)\n\n// safeOdd :: Traversable t => t Integer -> Maybe (t Integer)\nconst safeOdd =\n  traverse(Maybe, safe(isOdd))\n\n// seqMaybe :: Traversable t => t (Maybe a) -> Maybe (t a)\nconst seqMaybe =\n  traverse(Maybe.of, identity)\n\n// odd :: Pair [ Number ] Integer\nconst odd =\n  Pair([ 10 ], 23)\n\n// even :: Pair String  Integer\nconst even =\n  Pair('nope', 42)\n\nsafeOdd(odd)\n//=> Just Pair( [ 10 ], 23 )\n\nsafeOdd(even)\n//=> Nothing\n\nseqMaybe(Pair(true, Just('good')))\n//=> Just Pair( true, \"good\" )\n\nseqMaybe(Pair(false, Nothing()))\n//=> Nothing\n")),Object(i.b)("h3",{id:"extend"},"extend"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b ~> (Pair a b -> c) -> Pair a c\n")),Object(i.b)("p",null,"Used map the second position of a given ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance by taking the\nentire ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," into consideration. ",Object(i.b)("inlineCode",{parentName:"p"},"extend")," takes a function the receives\na ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," as its input and returns a new ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," with the result of that function\nin the second position, while leaving the value in the first position untouched."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\n\nimport extend from 'crocks/pointfree/extend'\nimport merge from 'crocks/pointfree/merge'\nimport objOf from 'crocks/helpers/objOf'\n\n// name :: Pair String String\nconst name =\n  Pair('name', 'Thomas')\n\n// mergeObj :: Pair String a -> Object\nconst mergeObj =\n  merge(objOf)\n\n// makeObj :: Pair String a -> Pair String Object\nconst makeObj =\n  extend(mergeObj)\n\nmakeObj(name)\n//=> Pair(\"name\", { name: \"Thomas\" })\n")),Object(i.b)("h3",{id:"swap"},"swap"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b ~> ((a -> c), (b -> d)) -> Pair d c\n")),Object(i.b)("p",null,"Used to map the value of a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"s first position into the second position and\nthe second position into the first, ",Object(i.b)("inlineCode",{parentName:"p"},"swap")," takes two functions as its arguments.\nThe first function is used to map the value in the first position to the second,\nwhile the second maps the second into the first. If no mapping is required on\neither side, then ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(i.b)("inlineCode",{parentName:"a"},"identity"))," functions can be used in one or both\narguments."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\n\nimport identity from 'crocks/combinators/identity'\nimport swap from 'crocks/pointfree/swap'\n\n// toString :: a -> String\nconst toString =\n  x => x.toString()\n\n// swapMap :: Pair a String -> Pair Number String\nconst swapMap =\n  swap(toString, parseInt)\n\n// m :: Pair Number String\nconst m =\n  Pair(76, '105')\n\nm.swap(identity, identity)\n//=> Pair(\"105\", 76)\n\nswapMap(m)\n//=> Pair(105, \"76\")\n")),Object(i.b)("h3",{id:"fst"},"fst"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b ~> () -> a\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"fst")," is one of two projection methods used to extract the values contained in\na given ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance. ",Object(i.b)("inlineCode",{parentName:"p"},"fst")," takes nothing as its input and will unwrap and\nprovide the value in the first position, throwing away the value in the second.\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#snd"}),Object(i.b)("inlineCode",{parentName:"a"},"snd"))," is the other projection function provided and is used to extract\nthe value in the second position."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\n\nPair('left', 'right')\n  .fst()\n//=> \"left\"\n")),Object(i.b)("h3",{id:"snd"},"snd"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b ~> () -> b\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"snd")," is one of two projection methods used to extract the values contained in\na given ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance. ",Object(i.b)("inlineCode",{parentName:"p"},"snd")," takes nothing as its input and will unwrap and\nprovide the value in the second position, throwing away the value in the first.\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fst"}),Object(i.b)("inlineCode",{parentName:"a"},"fst"))," is the other projection function provided and is used to extract\nthe value in the first position."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\n\nPair('left', 'right')\n  .snd()\n//=> \"right\"\n")),Object(i.b)("h3",{id:"toarray"},"toArray"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b ~> () -> [ a, b ]\n")),Object(i.b)("p",null,"While both ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fst"}),Object(i.b)("inlineCode",{parentName:"a"},"fst"))," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#snd"}),Object(i.b)("inlineCode",{parentName:"a"},"snd"))," can be used to extract specific\nvalues out of the structure of ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),", ",Object(i.b)("inlineCode",{parentName:"p"},"toArray")," extracts values but\nmaintains the structure. Taking nothing as its input, ",Object(i.b)("inlineCode",{parentName:"p"},"toArray")," will return\nan ",Object(i.b)("inlineCode",{parentName:"p"},"Array")," of two values. The first value in the ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," will occupy the ","[0]","\nindex, while the ","[1]"," index will house the second."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport compose from 'crocks/helpers/compose'\n\n// toArray :: Pair a b -> [ a, b ]\nconst toArray =\n  x => x.toArray()\n\n// toObject :: [ a, b ] -> Object\nconst toObject =\n  ([ left, right ]) => ({ left, right })\n\n// pairToObject :: Pair a b -> Object\nconst pairToObject =\n  compose(toObject, toArray)\n\n// m :: Pair String Number\nconst m =\n  Pair('a', 1)\n\nm.toArray()\n//=> [ 'a', 1 ]\n\npairToObject(m)\n//=> { left: 'a', right: 1 }\n")),Object(i.b)("h3",{id:"merge"},"merge"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Pair a b ~> ((a, b) -> c) -> c\n")),Object(i.b)("p",null,"Acting as a means to fold a given ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," over a binary operation, ",Object(i.b)("inlineCode",{parentName:"p"},"merge")," takes\na binary function as its sole argument. Using the function, ",Object(i.b)("inlineCode",{parentName:"p"},"merge")," will unwrap\neach of its values and apply them to the function in order from first to second.\nThe result of the provided function is then provided as the overall result\nfor ",Object(i.b)("inlineCode",{parentName:"p"},"merge"),"."),Object(i.b)("p",null,"This method comes in handy when using a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," as a means to run parallel\ncomputations and combine their results into a final answer. Typically this\nmethod works hand in hand with the either the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#branch"}),Object(i.b)("inlineCode",{parentName:"a"},"branch"))," or\n","[",Object(i.b)("inlineCode",{parentName:"p"},"fanout"),"][fanout]"," helper functions."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Sum from 'crocks/Sum'\n\nimport compose from 'crocks/helpers/compose'\nimport fanout from 'crocks/Pair/fanout'\nimport merge from 'crocks/pointfree/merge'\nimport mreduce from 'crocks/helpers/mreduce'\n\n// length :: [ a ] -> Integer\nconst length =\n  x => x.length\n\n// divide :: (Number, Number) -> Number\nconst divide =\n  (x, y) => x / y\n\n// average :: [ Number ] -> Number\nconst average = compose(\n  merge(divide),\n  fanout(mreduce(Sum), length)\n)\n\n// nums :: [ Number ]\nconst nums =\n  [ 23, 96, 90, 4, 21 ]\n\naverage(nums)\n// 46.8\n")),Object(i.b)("h2",{id:"helper-functions"},"Helper Functions"),Object(i.b)("h3",{id:"branch"},"branch"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Pair/branch")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"branch :: a -> Pair a a\n")),Object(i.b)("p",null,"Typically the starting point for handling parallel computations on a single\nvalue, ",Object(i.b)("inlineCode",{parentName:"p"},"branch")," takes a single value of any type as its only argument. ",Object(i.b)("inlineCode",{parentName:"p"},"branch")," then\nreturns a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," with the reference or value in both the first and second positions."),Object(i.b)("p",null,"Using ",Object(i.b)("inlineCode",{parentName:"p"},"branch")," can simplify how computations that depend on the same value are\nconstructed and encoded by removing the need to keep the original value in some\nstate that needs to be passed from function to function."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import assign from 'crocks/helpers/assign'\nimport bimap from 'crocks/pointfree/bimap'\nimport branch from 'crocks/Pair/branch'\nimport compose from 'crocks/helpers/compose'\nimport curry from 'crocks/helpers/curry'\nimport objOf from 'crocks/helpers/objOf'\nimport merge from 'crocks/pointfree/merge'\n\n// add10 :: Number -> Number\nconst add10 =\n  x => x + 10\n\n// applyChange :: (a -> b) -> a -> Object\nconst applyChange = fn =>\n  compose(objOf('current'), fn)\n\n// createUndo :: (a -> b) -> a -> Object\nconst createUndo = curry(fn =>\n  compose(\n    merge(assign),\n    bimap(objOf('orig'), applyChange(fn)),\n    branch\n  )\n)\n\n// applyAdd10 :: Number -> Object\nconst applyAdd10 =\n  createUndo(add10)\n\napplyAdd10(5)\n// { current: 15, orig: 5 }\n")),Object(i.b)("h3",{id:"fanout"},"fanout"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Pair/fanout")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"fanout :: (a -> b) -> (a -> c) -> (a -> Pair b c)\nfanout :: Arrow a b -> Arrow a c -> Arrow a (Pair b c)\nfanout :: Monad m => Star a (m b) -> Star a (m c) -> Star a (m (Pair b c))\n")),Object(i.b)("p",null,"There are may times that you need to keep some running or persistent state while\nperforming a given computation. A common way to do this is to take the input to\nthe computation and branch it into a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," and perform different operations on\neach version of the input. This is such a common pattern that it warrants\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"fanout")," function to take care of the initial split and mapping. Just\nprovide a pair of either simple functions or a pair of one of the computation\ntypes (",Object(i.b)("inlineCode",{parentName:"p"},"Arrow")," or ",Object(i.b)("inlineCode",{parentName:"p"},"Star"),"). You will get back something of the same type that is\nconfigured to split it's input into a pair and than apply the first Function/ADT\nto the first portion of the underlying ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," and the second on the second."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import compose from 'crocks/helpers/compose'\nimport fanout from 'crocks/Pair/fanout'\nimport getProp from 'crocks/Maybe/getProp'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport map from 'crocks/pointfree/map'\nimport Maybe from 'crocks/Maybe'\nimport merge from 'crocks/pointfree/merge'\nimport sequence from 'crocks/pointfree/sequence'\n\n// Person :: { first: String, last: String }\n// people :: [Person]\nconst people = [\n  { first: 'Ziggy', last: 'Stardust' },\n  { first: 'Lizard', last: 'King' }\n]\n\n// concat :: String -> String -> String\nconst concat = a => b => `${a} ${b}`\n\n// join :: String -> [a] -> String\nconst join = sep => arr => arr.join(sep)\n\n// getName :: Person -> String\nconst getName = compose(\n  merge(liftA2(concat)),\n  fanout(getProp('first'), getProp('last'))\n)\n\n// getPersons :: [Person] -> String\nconst getPersons = compose(\n  map(join(', ')),\n  sequence(Maybe),\n  map(getName)\n)\n\ngetPersons(people)\n//=> Just \"Ziggy Stardust, Lizard King\"\n")),Object(i.b)("h3",{id:"topairs"},"toPairs"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Pair/toPairs")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"toPairs :: Object -> List (Pair String a)\n")),Object(i.b)("p",null,"When dealing with ",Object(i.b)("inlineCode",{parentName:"p"},"Object"),"s, sometimes it makes more sense to work in\na ",Object(i.b)("inlineCode",{parentName:"p"},"Foldable")," structure like a ",Object(i.b)("inlineCode",{parentName:"p"},"List")," of key-value ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"s. ",Object(i.b)("inlineCode",{parentName:"p"},"toPairs")," provides\na means to take an object and give you back a ",Object(i.b)("inlineCode",{parentName:"p"},"List")," of ",Object(i.b)("inlineCode",{parentName:"p"},"Pairs")," that have\na ",Object(i.b)("inlineCode",{parentName:"p"},"String")," that represents the key in the ",Object(i.b)("inlineCode",{parentName:"p"},"fst")," and the value for that key in\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"snd"),". The primitive values are copied, while non-primitive values are\nreferences. Like most of the ",Object(i.b)("inlineCode",{parentName:"p"},"Object")," functions in ",Object(i.b)("inlineCode",{parentName:"p"},"crocks"),", any keys\nwith ",Object(i.b)("inlineCode",{parentName:"p"},"undefined")," values will be omitted from the result. ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," provides an\ninverse to this function named ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/helpers#frompairs"}),Object(i.b)("inlineCode",{parentName:"a"},"fromPairs")),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import compose from 'crocks/helpers/compose'\nimport map from 'crocks/pointfree/map'\nimport merge from 'crocks/pointfree/merge'\nimport toPairs from 'crocks/Pair/toPairs'\n\n// record :: Object\nconst record = {\n  firstName: 'Joey',\n  lastName: 'Fella',\n  age: 34\n}\n\n// joinField :: (String, a) -> String\nconst joinField = (key, value) =>\n  `${key}:${value}`\n\n// joinRecord :: List String -> String\nconst joinRecord = list =>\n  list.toArray()\n    .join('|')\n\n// buildRecord :: Object -> String\nconst buildRecord = compose(\n  joinRecord,\n  map(merge(joinField)),\n  toPairs\n)\n\nbuildRecord(record)\n//=> \"firstName:Joey|lastName:Fella|age:34\"\n")),Object(i.b)("h2",{id:"pointfree-functions"},"Pointfree Functions"),Object(i.b)("h3",{id:"fst-pointfree"},"fst (pointfree)"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Pair/fst")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"fst :: Pair a b -> a\n")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"fst")," pointfree function is used extract the leftmost value of a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," by\ninvoking the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fst"}),Object(i.b)("inlineCode",{parentName:"a"},"fst"))," method on a given instance, returning the result.\n",Object(i.b)("inlineCode",{parentName:"p"},"fst")," takes a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," as its only argument and returns the value wrapped in the\nleftmost portion of the provided ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\n\nimport flip from 'crocks/combinators/flip'\nimport fst from 'crocks/Pair/fst'\nimport ifElse from 'crocks/logic/ifElse'\nimport merge from 'crocks/pointfree/merge'\nimport snd from 'crocks/Pair/snd'\n\n// lte :: (Number, Number) -> Boolean\nconst lte =\n  (y, x) => x <= y\n\n// min :: Pair Number Number -> Number\nconst min = ifElse(\n  merge(flip(lte)),\n  fst,\n  snd\n)\n\nmin(Pair(1, 2))\n//=> 1\n\nmin(Pair(45, 22))\n//=> 22\n\nmin(Pair(100, 100))\n//=> 100\n")),Object(i.b)("h3",{id:"snd-pointfree"},"snd (pointfree)"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Pair/snd")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"snd :: Pair a b -> b\n")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"snd")," pointfree function is used extract the rightmost value of a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," by\ninvoking the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#snd"}),Object(i.b)("inlineCode",{parentName:"a"},"snd"))," method on a given instance, returning the result.\n",Object(i.b)("inlineCode",{parentName:"p"},"snd")," takes a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," as its only argument and returns the value wrapped in the\nrightmost portion of the provided ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport Unit from 'crocks/Unit'\n\nimport chain from 'crocks/pointfree/chain'\nimport compose from 'crocks/helpers/compose'\nimport map from 'crocks/pointfree/map'\nimport snd from 'crocks/Pair/snd'\n\n// Box :: a -> Pair () a\nconst Box =\n  x => Pair(Unit(), x)\n\n// unbox :: Pair a b -> b\nconst unbox =\n  snd\n\n// add :: Number -> Number -> Number\nconst add =\n  x => y => x + y\n\n// doubleBoxed :: Number -> Pair () Number\nconst doubleBoxed =\n  m => Box(m * 2)\n\n// flow :: Number -> Number\nconst flow = compose(\n  unbox,\n  chain(doubleBoxed),\n  map(add(10)),\n  Box\n)\n\nflow(10)\n//=> 40\n")),Object(i.b)("h2",{id:"transformation-functions"},"Transformation Functions"),Object(i.b)("h3",{id:"writertopair"},"writerToPair"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"crocks/Pair/writerToPair")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"writerToPair :: Monoid m => Writer m a -> Pair m a\nwriterToPair :: Monoid m => (a -> Writer m b) -> a -> Pair m b\n")),Object(i.b)("p",null,"Used to transform a ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," instance to a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance or\nflatten a ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," of ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," into an ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," when chained, ",Object(i.b)("inlineCode",{parentName:"p"},"writerToPair")," will\ntake a given ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," and provide a new ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," with the ",Object(i.b)("inlineCode",{parentName:"p"},"log")," portion of\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," in the first position and the ",Object(i.b)("inlineCode",{parentName:"p"},"resultant")," in the second."),Object(i.b)("p",null,"Like all ",Object(i.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(i.b)("inlineCode",{parentName:"p"},"writerToPair")," has two possible\nsignatures and will behave differently when passed either a ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," instance\nor a function that returns an instance of ",Object(i.b)("inlineCode",{parentName:"p"},"Writer"),". When passed the instance,\na ",Object(i.b)("inlineCode",{parentName:"p"},"Pair")," instance is returned. When passed a ",Object(i.b)("inlineCode",{parentName:"p"},"Writer")," returning function,\na function will be returned that takes a given value and returns an ",Object(i.b)("inlineCode",{parentName:"p"},"Pair"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Pair from 'crocks/Pair'\nimport Sum from 'crocks/Sum'\nimport Writer from 'crocks/Writer'\nimport fanout from 'crocks/helpers/fanout'\n\nimport writerToPair from 'crocks/Pair/writerToPair'\n\n// SumWriter :: Writer Sum a\nconst SumWriter =\n  Writer(Sum)\n\n// appendItem :: a -> [ a ] -> SumWriter [ a ]\nconst appendItem = item => xs =>\n  SumWriter(1, xs.concat([ item ]))\n\nSumWriter(0, [])\n  .chain(appendItem('one'))\n  .chain(appendItem('two'))\n  .chain(appendItem('three'))\n//=> Writer (Sum 3) [ \"one\", \"two\", \"three\" ]\n\nwriterToPair(SumWriter(2, 'result'))\n//=> Pair(Sum 2, 'result')\n\nPair(Sum.empty(), [])\n  .chain(writerToPair(appendItem('one')))\n  .chain(writerToPair(appendItem('two')))\n  .chain(writerToPair(appendItem('three')))\n//=> Pair(Sum 3, [ \"one\", \"two\", \"three\"])\n\nfanout(Sum, x => appendItem(x)([ x ]), 1)\n  .chain(writerToPair)\n")))}b.isMDXComponent=!0}}]);