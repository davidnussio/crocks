[{"title":"Crocks","type":0,"sectionRef":"#","url":"docs/crocks/","content":"The crocks are the heart and soul of this library. This is where you will find all your favorite ADT's you have grown to love. They include gems such as:Maybe, Either and IO, to name a few. They are usually just a simple constructor that takes either a function or value (depending on the type) and will return you a \"container\" that wraps whatever you passed it. Each container provides a variety of functions that act as the operations you can do on the contained value. There are many types that share the same function names, but what they do from type to type may vary. Crock\tConstructor\tInstanceArrow\tid\tboth, compose, contramap,first, map, promap, runWith, second Async\tRejected, Resolved, all, resolveAfter, rejectAfter, fromNode, fromPromise, of\talt, ap, bichain, bimap, chain, coalesce, fork, map, of, race, swap, toPromise Const\tempty, of\tap, concat, empty, equals, map, of, valueOf Either\tLeft, Right, of\talt, ap, bichain, bimap, chain, coalesce, concat, either, equals, map, of, sequence, swap, traverse Equiv\tempty\tconcat, contramap, compareWith, valueOf Identity\tof\tap, chain, concat, equals, map, of, sequence, traverse, valueOf IO\tof\tap, chain, map, of, run List\tempty, fromArray, of\tap, chain, concat, cons, empty, equals, filter, fold, foldMap, head, init, last, map, of, reduce, reduceRight, reject, sequence, tail, toArray, traverse, valueOf Maybe\tNothing, Just, of, zero\talt, ap, bichain, chain, coalesce, concat, equals, either, map, of, option, sequence, traverse, zero Pair\t---\tap, bimap, chain, concat, equals, extend, fst, map, merge, sequence, snd, swap, traverse, toArray Pred *\tempty\tconcat, contramap, runWith, valueOf Reader\task, of\tap, chain, map, runWith ReaderT\task, lift, liftFn, of\tap, chain, map, runWith Result\tErr, Ok, of\talt, ap, bichain, bimap, chain, coalesce, concat, either, equals, map, of, sequence, swap, traverse Star\tid\tboth, compose, contramap, map, promap, runWith State\tget, modify, of, put\tap, chain, evalWith, execWith, map, runWith Tuple\t---\tconcat, equals, map, mapAll, merge, project, toArray Unit\tempty, of\tap, chain, concat, empty, equals, map, of, valueOf Writer\tof\tap, chain, equals, log, map, of, read, valueOf * based on this article","keywords":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Getting Started","url":"docs/#installation","content":"crocks is available from npm and is just a shell command away. All you need to do is run the following to save it as a dependency in your current project folder: Copy $ npm install crocks -S This will pull down crocks into your project's node_modules folder and can be accessed by adding something like the following in the file that needs it: Copy // node require syntax const crocks =require('crocks') // JavaScript modules (if you are transpiling) import crocks from'crocks' "},{"title":"Import only what's needed","type":1,"pageTitle":"Getting Started","url":"docs/#import-only-whats-needed","content":"There is a lot to this library, and as such it may not be desired to bring in the whole thing when bundling for a library or frontend application. If this is the case, the code is organized in a manner that groups all functions that return or construct a given ADT into their respective folders. While general purpose functions are spread across the following folders: combinators, helpers, logic, pointfree and predicates. To access the types, just reference the folder like: crocks/Maybe, or crocks/Result. If you want to access a function that constructs a given type, reference it by name, like: crocks/Maybe/safe or crocks/Result/tryCatch. This organization helps ensure that you only include what you need. "},{"title":"Entire library (CommonJS)","type":1,"pageTitle":"Getting Started","url":"docs/#entire-library-commonjs","content":"Copy // namespace entire suite to crocks variable const crocks =require('crocks') // pluck anything that does not require name-spacing const{ safe, isNumber }= crocks // still requires entire object, but removes name-spacing const{ and, liftA2 }=require('crocks') // divide :: Number -> Number constdivide= x=>y=> x / y // safeNumber :: a -> Maybe Number const safeNumber = safe(isNumber) // notZero :: a -> Maybe Number const notZero =safe( and(isNumber,x=> x !==0) ) // safeDivide:: a -> Maybe Number const safeDivide = crocks.curry( (x, y)=>liftA2(divide,safeNumber(x),notZero(y)) ) safeDivide(20,0) //=> Nothing safeDivide(20,5) //=> Just 4 safeDivide('number',5) //=> Nothing runkit "},{"title":"Entire library (JS Modules)","type":1,"pageTitle":"Getting Started","url":"docs/#entire-library-js-modules","content":"Copy // namespace entire suite to crocks variable import crocks from'crocks' // still imports entire object, but removes name-spacing import{ and, liftA2 }from'crocks' // pluck anything that does not require name-spacing const{ safe, isNumber }= crocks // divide :: Number -> Number constdivide= x=>y=> x / y // safeNumber :: a -> Maybe Number const safeNumber = safe(isNumber) // notZero :: a -> Maybe Number const notZero =safe( and(isNumber,x=> x !==0) ) // safeDivide:: a -> Maybe Number const safeDivide = crocks.curry( (x, y)=>liftA2(divide,safeNumber(x),notZero(y)) ) safeDivide(20,0) //=> Nothing safeDivide(20,5) //=> Just 4 safeDivide('number',5) //=> Nothing runkit "},{"title":"Single entities (CommonJS)","type":1,"pageTitle":"Getting Started","url":"docs/#single-entities-commonjs","content":"Copy // require in each entity directly const and =require('crocks/logic/and') const curry =require('crocks/helpers/curry') const isNumber =require('crocks/predicates/isNumber') const liftA2 =require('crocks/helpers/liftA2') const safe =require('crocks/Maybe/safe') // divide :: Number -> Number constdivide= x=>y=> x / y // safeNumber :: a -> Maybe Number const safeNumber = safe(isNumber) // notZero :: a -> Maybe Number const notZero =safe( and(isNumber,x=> x !==0) ) // safeDivide:: a -> Maybe Number const safeDivide =curry( (x, y)=>liftA2(divide,safeNumber(x),notZero(y)) ) safeDivide(20,0) //=> Nothing safeDivide(20,5) //=> Just 4 safeDivide('number',5) //=> Nothing runkit "},{"title":"Single entities (JS Modules)","type":1,"pageTitle":"Getting Started","url":"docs/#single-entities-js-modules","content":"Copy // import in each entity directly import and from'crocks/logic/and' import curry from'crocks/helpers/curry' import isNumber from'crocks/predicates/isNumber' import liftA2 from'crocks/helpers/liftA2' import safe from'crocks/Maybe/safe' // divide :: Number -> Number constdivide= x=>y=> x / y // safeNumber :: a -> Maybe Number const safeNumber = safe(isNumber) // notZero :: a -> Maybe Number const notZero =safe( and(isNumber,x=> x !==0) ) // safeDivide:: a -> Maybe Number const safeDivide =curry( (x, y)=>liftA2(divide,safeNumber(x),notZero(y)) ) safeDivide(20,0) //=> Nothing safeDivide(20,5) //=> Just 4 safeDivide('number',5) //=> Nothing runkit "},{"title":"Const","type":0,"sectionRef":"#","url":"docs/crocks/Const","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Const","url":"docs/crocks/Const#implements","content":"Setoid, Semigroup, Monoid, Functor, Apply, Applicative "},{"title":"Construction","type":1,"pageTitle":"Const","url":"docs/crocks/Const#construction","content":"Copy Const :: TypeRep T => T -> Const T Const c :: c -> Const c a Const is a Type Constructor that take a Constructor or TypeRep and will give back an Instance Constructor that will take a value of the type provided. Copy importConstfrom'crocks/Const' // StrConst :: Const String a constStrConst= Const(String) // BoolConst :: Const Boolean a constBoolConst= Const(Boolean) StrConst('always and forever') //=> Const(String) \"always and forever\" BoolConst(false) //=> Const(Boolean) false runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Const","url":"docs/crocks/Const#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Const","url":"docs/crocks/Const#empty","content":"Copy Monoid m => Const(m).empty :: () -> Const m () When Const is fixed to a Monoid type, we automatically get a Monoid implementation by creating an instance that points to the empty element of the underlying Monoid. As this is just a \"pass through\" of the underlying Monoid, everything valid for the underlying type, holds true for Const. empty will throw a TypeError if the underlying Type does not point to a type of Monoid.  "},{"title":"of","type":1,"pageTitle":"Const","url":"docs/crocks/Const#of","content":"Copy Monoid m => Const(m).of :: a -> Const m a When Const is fixed to a Monoid type, we automatically get an Applicative implementation by creating an instance that points to the empty element of the underlying Monoid. The Applicative laws work due to the fact that we can derive an Apply by mapping all every morphism to the concat method of a pointed to Semigroup. As, we must be a Semigroup before we can be a Monoid, ap is guaranteed. of will throw a TypeError if the underlying Type does not point to a type of Monoid.  "},{"title":"Instance Methods","type":1,"pageTitle":"Const","url":"docs/crocks/Const#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Const","url":"docs/crocks/Const#equals","content":"Copy Const c a ~> b -> Boolean Used to compare the underlying values of two Const instances for equality by value, equals takes any given argument and returns true if the passed argument is a Const with an underlying left value equal to the underlying value of the Const the method is being called on. If the passed argument is not a Const or the underlying values are not equal, equals will return false. Copy importConstfrom'crocks/Const' // NumConst :: Const Number a constNumConst= Const(Number) // ArrConst :: Const Array a constArrConst= Const(Array) NumConst(2) .equals(NumConst(5)) //=> false NumConst(5) .equals(NumConst(5)) //=> true ArrConst(['a','b']) .equals(ArrConst(['c','d'])) //=> false ArrConst(['c','d']) .equals(ArrConst(['c','d'])) //=> true runkit "},{"title":"concat","type":1,"pageTitle":"Const","url":"docs/crocks/Const#concat","content":"Copy Semigroup s => Const s a ~> Const s a -> Const s a concat is used to combine two Semigroups of the same type under an operation specified by the Semigroup. When a Const instance is fixed to a Semigroup type, it will combine the two values that each Const points to using the concat method of the underlying Semigroup. concat will throw a TypeError if the underlying Type does not point to a type of Semigroup. Copy importConstfrom'crocks/Const' importMaybefrom'crocks/Maybe' importSumfrom'crocks/Sum' const{Just}=Maybe constArrayConst= Const(Array) constMaybeConst= Const(Maybe) ArrayConst(['a','b']) .concat(ArrayConst(['c'])) //=> Const(Array) [ \"a\", \"b\", \"c\" ] // a :: Maybe Sum const a = Just(Sum(10)) // b :: Maybe Sum const b = Just(Sum(32)) MaybeConst(a) .concat(MaybeConst(b)) .valueOf() //=> Just (Sum 42) runkit "},{"title":"map","type":1,"pageTitle":"Const","url":"docs/crocks/Const#map","content":"Copy Const c a ~> (a -> b) -> Const c b Typically used to lift a function into the context of an ADT, but due to the unique behavior of Const, any function that is passed in to map will be validated but it will not be applied. map will return a new Const with the same left value. Copy importConstfrom'crocks/Const' importIdentityfrom'crocks/Identity' importMaybefrom'crocks/Maybe' import map from'crocks/pointfree/map' const{Just}=Maybe // MaybeConst :: Maybe a -> MaybeConst (Maybe a) constMaybeConst= Const(Maybe) // add10 :: Functor f => f Number -> f Number const add10 = map(x=> x +10) Identity(Just(3)) .map(add10) //=> Identity Just 13 MaybeConst(Just(3)) .map(add10) //=> Const(Maybe) Just 3 runkit "},{"title":"ap","type":1,"pageTitle":"Const","url":"docs/crocks/Const#ap","content":"Copy Semigroup s => Const s (a -> b) ~> Const s a -> Const s b The unique nature of the Const functor allows any underlying Semigroup to act an an Apply. When on Const is applied to another Const whose underlying Semigroups match, the Semigroups will be combined by calling concat on the underlying Semigroup. ap will throw a TypeError if the underlying Type does not point to a type of Semigroup. Copy importConstfrom'crocks/Const' // prod :: Number -> Number -> Number constprod= x=>y=> x * y Const(5) .map(prod) .ap(Const(27)) //=> Const 5 runkit "},{"title":"valueOf","type":1,"pageTitle":"Const","url":"docs/crocks/Const#valueof","content":"Copy Const c a ~> () -> c valueOf is used as a means of extraction. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Const instance will result in the underlying left value of the Product type. Copy importConstfrom'crocks/Const' constArrayConst= Const(Array) ArrayConst([33]) .valueOf() //=> [ 33 ] ArrayConst([35]) .concat(ArrayConst([20])) .valueOf() //=> [ 35, 20 ] runkit "},{"title":"Identity","type":0,"sectionRef":"#","url":"docs/crocks/Identity","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#implements","content":"Setoid, Semigroup, Functor, Traversable, Apply, Chain, Applicative, Monad "},{"title":"Construction","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#construction","content":"Copy Identity :: a -> Identity a The constructor for an Identity is a unary function. When a value is passed in an Identity of the given value is returned ready for map or chain. Copy importIdentityfrom'crocks/Identity' const fromComputerCode =String.fromCharCode Identity(42) .map(fromComputerCode) //=> Identity '*' runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#constructor-methods","content":""},{"title":"of","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#of","content":"Copy Identity.of :: a -> Identity a of is used to construct an Identity with any given value. It is there to allow Identity to work as a pointed functor. Copy importIdentityfrom'crocks/Identity' Identity.of(42) //=> Identity 42 Identity.of(true) //=> Identity true runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#equals","content":"Copy Identity a ~> b -> Boolean Used to compare the underlying values of two Identity instances for equality by value, equals takes any given argument and returns true if the passed arguments is an Identity with an underlying value equal to the underlying value of the Identity the method is being called on. If the passed argument is not an Identity or the underlying values are not equal, equals will return false. Copy importIdentityfrom'crocks/Identity' import equals from'crocks/pointfree/equals' Identity(33) .equals(Identity(33)) //=> true Identity(33) .equals(Identity('33')) //=> false // by value, not reference for most types Identity({ a:86, b:true}) .equals(Identity({ a:86, b:true})) //=> true equals(Identity(95),95) //=> false equals(Identity([2,3]),Identity([2,3])) //=> true runkit "},{"title":"concat","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#concat","content":"Copy Identity s => Identity s ~> Identity s -> Identity s When an underlying value of a given Identity is fixed to a Semigroup,concat can be used to concat another Identity instance with an underlying Semigroup of the same type. Expecting an Identity wrapping a Semigroup of the same type, concat will give back a new Identity instance wrapping the result of combining the two underlying Semigroups. Copy importIdentityfrom'crocks/Identity' importSumfrom'crocks/Sum' import compose from'crocks/helpers/compose' import concat from'crocks/pointfree/concat' import flip from'crocks/combinators/flip' import map from'crocks/pointfree/map' import mapReduce from'crocks/helpers/mapReduce' import valueOf from'crocks/pointfree/valueOf' // empty :: Identity Sum const empty = Identity(Sum.empty()) // sumList :: [ * ] -> Identity Number const sumList =compose( map(valueOf), mapReduce(compose(Identity,Sum),flip(concat), empty) ) Identity([34]) .concat(Identity([92])) //=> Identity [ 34, 92 ] sumList([3,4,5]) //=> Identity 12 runkit "},{"title":"map","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#map","content":"Copy Identity a ~> (a -> b) -> Identity b Used to apply transformations to values you've lifted into an Identity, map takes a function that it will lift into the context of the Identity and apply to it the wrapped value. Identity contains no behavior and will do nothing more than apply the value inside the Identity to the function. Copy importIdentityfrom'crocks/Identity' import map from'crocks/pointfree/map' constprod=a=>b=> a * b const mapDouble =map(prod(2)) mapDouble(Identity(5)) //=> Identity 10 runkit "},{"title":"ap","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#ap","content":"Copy Identity (a -> b) ~> Identity a -> Identity b ap allows for values wrapped in an Identity to be applied to functions also wrapped in an Identity. In order to use ap, the Identity must contain a function as its value. Under the hood, ap unwraps both the function and the value to be applied and applies the value to the function. Finally it will wrap the result of that application back into an Identity. It is required that the inner function is curried. Copy importIdentityfrom'crocks/Identity' constprod=a=>b=> a * b const double =prod(2) Identity(double) .ap(Identity(5)) //=> Identity 10 runkit "},{"title":"sequence","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#sequence","content":"Copy Apply f => Identity (f a) ~> (b -> f b) -> f (Identity a) Applicative f => Identity (f a) ~> TypeRep f -> f (Identity a) When an instance of Identity wraps an Apply instance, sequence can be used to swap the type sequence. sequence requires either an Applicative TypeRep or an Apply returning function to be provided for its argument. sequence can be derived from traverse by passing it an identity function (x => x). Copy importIdentityfrom'crocks/Identity' importMaybefrom'crocks/Maybe' import sequence from'crocks/pointfree/sequence' // seqId :: Identity Maybe a -> Maybe Identity a const seqMaybe = sequence(Maybe) seqMaybe(Identity(Maybe(42))) //=> Just Identity 42 runkit "},{"title":"traverse","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#traverse","content":"Copy Apply f => Identity a ~> (a -> f b) -> f (Identity b) Applicative f => Identity a ~> (TypeRep f, (a -> f b)) -> f (Identity a b) Used to apply the \"effect\" of an Apply to a value inside of a Identity,traverse combines both the \"effects\" of the Apply and the Identity by returning a new instance of the Apply, wrapping the result of the Applys \"effect\" on the value in the Identity. traverse requires either an Applicative TypeRep or an Apply returning function as its first argument and a function that is used to apply the \"effect\" of the target Apply to the value inside of the Identity. Both arguments must provide an instance of the target Apply. Copy importIdentityfrom'crocks/Identity' importIOfrom'crocks/IO' import compose from'crocks/helpers/compose' import isNumber from'crocks/predicates/isNumber' import traverse from'crocks/pointfree/traverse' import ifElse from'crocks/logic/ifElse' // someGlobal :: Number let someGlobal =10 // addToGlobal :: Number -> IO Number constaddToGlobal=x=>IO(()=> someGlobal + x) // safeAddToGlobal :: a -> IO (Maybe Number) const safeAddToGlobal =compose( traverse(IO, addToGlobal), Identity, ifElse(isNumber,x=> x,()=>NaN) ) safeAddToGlobal(32) .run() //=> Identity 42 //someGlobal => 42 safeAddToGlobal(32) .run() .valueOf() //=> 42 safeAddToGlobal(undefined) .run() .valueOf() //=> NaN runkit "},{"title":"chain","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#chain","content":"Copy Identity a ~> (a -> Identity b) -> Identity b Normally one of the ways Monads like Identity are able to be combined and have their effects applied is through chain. However Identity is different because there are no effects to apply. chain will simply take a function that returns Identity and applies it to its value. Copy importIdentityfrom'crocks/Identity' import compose from'crocks/helpers/compose' import chain from'crocks/pointfree/chain' constprod=a=>b=> a * b const doubleAsIdentity =compose(Identity,prod(2)) doubleAsIdentity(21) //=> Identity 42 chain(doubleAsIdentity,Identity(5)) //=> Identity 10 runkit "},{"title":"valueOf","type":1,"pageTitle":"Identity","url":"docs/crocks/Identity#valueof","content":"Copy Identity a ~> () -> a valueOf is used as a means of extraction. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Identity instance will return the value being contained. Copy importIdentityfrom'crocks/Identity' Identity(42) .valueOf() //=> 42 Identity([10,20]) .concat(Identity([30,40])) .valueOf() //=>[ 10, 20, 30, 40 ] runkit "},{"title":"Equiv","type":0,"sectionRef":"#","url":"docs/crocks/Equiv","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#implements","content":"Semigroup, Monoid, Contravariant "},{"title":"Construction","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#construction","content":"Copy Equiv :: ((a, a) -> Boolean)-> Equiv a a The constructor for Equiv is a unary function that takes a binary predicate function as its argument. The binary function's arguments should be the same type, although a union of multiple types can be used. The Equiv type is parameterized by the inputs, or domain, of the function it was constructed with. If the function does not strictly return a Boolean, then the underlying result will be coerced to a Boolean. Copy importEquivfrom'crocks/Equiv' // samePartition :: (a -> b) -> (a, a) -> Boolean constsamePartition=fn=>(x, y)=> fn(x)===fn(y) // mod12 :: Integer -> Integer constmod12= x=> x %12 // Equiv Integer Integer Equiv(samePartition(mod12)) //=> Equiv (Integer, Integer) -> Boolean runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#empty","content":"Copy Equiv.empty :: () -> Equiv a a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Equiv the result of empty is an Equiv that will always return true. empty is available on both the Constructor and the Instance for convenience. Copy importEquivfrom'crocks/Equiv' import equals from'crocks/pointfree/equals' const eq = Equiv(equals) const empty = Equiv.empty() eq .concat(empty) .compareWith({ a:32},{ a:32}) //=> true empty .concat(eq) .compareWith({ a:32},{ a:32}) //=> true empty .concat(eq) .compareWith({ a:32, b:19},{ a:32}) //=> false runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#instance-methods","content":""},{"title":"concat","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#concat","content":"Copy Equiv a a ~> Equiv a a -> Equiv a a concat is used to combine two Semigroups of the same type under an operation specified by the Semigroup. In the case of Equiv, the results of both Equivs are combined under logical conjunction. Copy importEquivfrom'crocks/Equiv' import compareWith from'crocks/pointfree/compareWith' import equals from'crocks/pointfree/equals' import isSameType from'crocks/predicates/isSameType' import getPropOr from'crocks/helpers/getPropOr' // objLength :: Object -> Number constobjLength= x=>Object.keys(x).length // eq :: Equiv a a const eq = Equiv(equals) // sameType :: Equiv a a const sameType = Equiv(isSameType) // sameType :: Equiv Object Object const length = eq.contramap(objLength) // sameType :: Equiv a a constsameTypeProp=key=> sameType.contramap(getPropOr(null, key)) // run :: Equiv Object Object const run =compareWith( { a:19, b:'string'}, { a:32, c:false} ) run(length) //=> true run(sameTypeProp('a')) //=> true run(sameTypeProp('b')) //=> false run( sameTypeProp('a') .concat(length) ) // true run( sameTypeProp('b') .concat(length) ) // false runkit "},{"title":"contramap","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#contramap","content":"Copy Equiv a a ~> (b -> a) -> Equiv b b The far right parameter of Equiv fixed to Boolean which means we cannot map the value as expected. However the left two parameters can vary, although they must vary in the same manner. This is where contramap comes into play as it can be used to adapt an Equiv of a given type to accept a different type or modify the value. Provide it a function that has a return type that matches the input types of the Equiv. This will return a new Equiv matching the input type of the provided function. Copy importEquivfrom'crocks/Equiv' import equals from'crocks/pointfree/equals' // length :: String -> Number constlength= x=> x.length // eq :: Equiv a a const eq = Equiv(equals) // sameLength :: Equiv String String const sameLength = eq.contramap(length) // sameAmplitude :: Equiv Float Float const sameAmplitude = eq.contramap(Math.abs) sameAmplitude .compareWith(-0.5011,0.5011) //=> true sameAmplitude .compareWith(-0.755,0.8023) //=> false sameLength .compareWith('aBcD','1234') //=> true sameLength .compareWith('AB','ABC') //=> false runkit "},{"title":"valueOf","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#valueof","content":"Copy Equiv a a ~> () -> a -> a -> Boolean valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Equiv instance will result in the underlying curried equivalence function. Copy importEquivfrom'crocks/Equiv' import compose from'crocks/helpers/compose' import equals from'crocks/pointfree/equals' import getPropOr from'crocks/helpers/getPropOr' // toLower :: String -> String consttoLower= x=> x.toLowerCase() // length :: String -> String constlength= x=> x.length // lowerName :: Object -> String const lowerName = compose(toLower,getPropOr('','name')) // itemsLen :: Object -> Number const itemsLen = compose(length,getPropOr('','items')) // eq :: Equiv a a const eq = Equiv(equals) // checkName :: Equiv Object Object const checkName = eq.contramap(lowerName) // checkName :: Equiv Object Object const checkItems = eq.contramap(itemsLen) // test :: Object -> Object -> Boolean const test = checkName .concat(checkItems) .valueOf() test( { name:'Bob', items:[1,2,4]}, { name:'bOb', items:[9,12,9]} ) //=> true runkit "},{"title":"compareWith","type":1,"pageTitle":"Equiv","url":"docs/crocks/Equiv#comparewith","content":"Copy Equiv a a ~> a -> a -> Boolean As Equiv wraps a function, it needs a means to be run with two values for comparison. Instances provide a curried method called compareWith that takes two values for comparison and will run them through the equivalence function, returning the resulting Boolean. Due to the laziness of this type, complicated comparisons can be built out from combining and mapping smaller, simpler units of equivalence comparison. Copy importEquivfrom'crocks/Equiv' // both :: Equiv Boolean Boolean const both = Equiv((x, y)=> x && y) // isEven :: Number -> Boolean constisEven= x=> x %2===0 // isBig :: Number -> Boolean constisBig= x=> x >10 // bothEven :: Equiv Number Number const bothEven = both.contramap(isEven) // bothBig :: Equiv Number Number const bothBig = both.contramap(isBig) bothEven .compareWith(12,20) //=> true bothEven .compareWith(17,20) //=> false bothBig .compareWith(17)(20) //=> true bothBig .compareWith(7)(20) //=> false bothBig .concat(bothEven) .compareWith(8)(54) //=> false runkit "},{"title":"Arrow","type":0,"sectionRef":"#","url":"docs/crocks/Arrow","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#implements","content":"Semigroupoid, Category, Functor, Contravariant, Profunctor "},{"title":"Construction","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#construction","content":"Copy Arrow :: (a -> b) -> Arrow a b An Arrow is constructed with a unary function of type (a -> b). The input, or domain, of the function is the left parameter in the type signature and the output, or co-domain, of the function represents the right. Copy importArrowfrom'crocks/Arrow' import compose from'crocks/helpers/compose' import getProp from'crocks/Maybe/getProp' import option from'crocks/pointfree/option' // length :: a -> Integer const length =compose( option(0), getProp('length') ) // Arrow a Integer Arrow(length) //=> Arrow (a -> Integer) runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#constructor-methods","content":""},{"title":"id","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#id","content":"Copy Arrow.id :: () -> Arrow a id provides the identity for the Arrow in that when it is composed to either the left or right side of a given function, it will essentially result in a morphism that is, for all intents and purposes, the given function. For Arrow,id is the simple identity function that echoes it's given argument (x => x). As a convenience, id is also available on the Arrow instance. Copy importArrowfrom'crocks/Arrow' // arrId :: Arrow a const id =Arrow.id() // arrow :: Arrow a String const arrow = Arrow(x=> x.toString()) // left :: Arrow a String const left = id.compose(arrow) // right :: Arrow a String const right = arrow.compose(id) right.runWith(12) //=> '12' left.runWith(12) //=> '12' runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#instance-methods","content":""},{"title":"both","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#both","content":"Copy Pair p => Arrow a b ~> () -> Arrow (p a a) (p b b) both allows for the mode of a given Arrow to switch to a manner that applies itself to both slots of a Pair that is passed through the Arrow. As noted in the type signature, both will give back an Arrow has a new signature that utilizes a Pair on both sides. Copy importArrowfrom'crocks/Arrow' importPairfrom'crocks/Pair' import merge from'crocks/pointfree/merge' // double :: Number -> Number constdouble= x=> x *2 // add :: (Number, Number) -> Number constadd= (x, y)=> x + y // arrDouble :: Arrow Number const arrDouble = Arrow(double) // arrDoubleAndAdd :: Arrow (Pair Number Number) Number const arrDoubleAndAdd = arrDouble .both() .map(merge(add)) arrDouble .runWith(200) //=> 400 arrDoubleAndAdd .runWith(Pair(200,10)) //=> 420 runkit "},{"title":"compose","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#compose","content":"Copy Arrow a b ~> Arrow b c -> Arrow a c compose allows you to compose two Arrows together, resulting in a new Arrow that is the result of the composition. Copy importArrowfrom'crocks/Arrow' import filter from'crocks/pointfree/filter' import map from'crocks/pointfree/map' // arrFilterEven :: Arrow [ Number ] const arrFilterEven = Arrow(filter(x=>!(x %2))) // arrDoubleNumbers :: Arrow [ Number ] const arrDoubleNumbers = Arrow(map(x=> x *2)) // arrLength :: Arrow [ a ] -> Number const arrLength = Arrow(x=> x.length) // arrDoubleEven :: Arrow [ Number ] const arrDoubleEven = arrFilterEven .compose(arrDoubleNumbers) // arrEvenCount :: Arrow [ Number ] Number const arrEvenCount = arrFilterEven .compose(arrLength) // data :: [ Number ] const data = [12,2,36,35] arrDoubleEven .runWith(data) //=> [ 24, 4, 72 ] arrEvenCount .runWith(data) //=> 3 runkit "},{"title":"contramap","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#contramap","content":"Copy Arrow a b ~> (c -> a) -> Arrow c b When using contramap on an Arrow, a function can be lifted that will map a given type into the type required for the original Arrow's input. This allows for \"adaption\" of given Arrow's input for better reuse. The resulting type of the lifted function must match the input type of the Arrow. Copy importArrowfrom'crocks/Arrow' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import getProp from'crocks/Maybe/getProp' import isNumber from'crocks/predicates/isNumber' import option from'crocks/pointfree/option' import safe from'crocks/Maybe/safe' // getValue :: (String, Number) -> a -> Number constgetValue=(key, def)=>compose( option(def), chain(safe(isNumber)), getProp(key) ) // arrAdd10 :: Arrow Number const arrAdd10 = Arrow(x=> x +10) // arrAdd10Value :: Arrow Object Number const arrAdd10Value = arrAdd10 .contramap(getValue('value',0)) arrAdd10 .runWith(23) //=> 33 arrAdd10Value .runWith({ value:23}) //=> 33 arrAdd10Value .runWith({ value:'23'}) //=> 10 arrAdd10Value .runWith({ num:23}) //=> 10 runkit "},{"title":"first","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#first","content":"Copy Pair p => Arrow a b ~> () -> Arrow (p a c) (p b c) When calling first on an Arrow, a new Arrow is returned that will expect a Pair with the original input type in the first slot of the Pair. When run, the Arrow will only be applied to the first slot in the Pair, leaving the second slot untouched. Copy importArrowfrom'crocks/Arrow' import branch from'crocks/Pair/branch' // arrToUpper :: Arrow String const arrToUpper = Arrow(x=> x.toUpperCase()) arrToUpper .runWith('burrito bounce') //=> 'BURRITO BOUNCE' // join :: Pair String -> Object constjoin=p=>({ original: p.snd(), result: p.fst() }) // flow :: Arrow String Object const flow = arrToUpper .first() .promap(branch, join) flow .runWith('taco time') //=> { original: 'taco time', result: 'TACO TIME' } runkit "},{"title":"map","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#map","content":"Copy Arrow a b ~> (b -> c) -> Arrow a c map allows a function to be lifted that will map the right side of the Arrow. Where contramap is used to map the input, map maps the result of the Arrow, allowing the result to be \"adapted\" or modified. The input type to the lifted function must match the result the Arrow. Copy importArrowfrom'crocks/Arrow' importBfrom'crocks/combinators/composeB' // arrFullScale :: Arrow Number const arrFullScale = Arrow(x=>20*Math.log10(Math.abs(x))) arrFullScale .runWith(-0.35) //=> -9.118639112994488 // round :: Number -> Number constround= x=>Math.floor(x *100)/100 // stringRep :: Number -> String conststringRep= x=>`${x} dBFS` // Arrow :: Number String const arrStringFS = arrFullScale .map(B(stringRep, round)) arrStringFS .runWith(0.35) //=> '-9.12 dbFS' runkit "},{"title":"promap","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#promap","content":"Copy Arrow a b ~> ((c -> a), (b -> d)) -> Arrow c d promap can be used to adapt BOTH ends of an Arrow allowing for existing Arrows to be reused in places in a flow where the types do not line up. It combines both map and contramap into one operation. Just pass the function for contramap as the first argument and the function map as the second. Copy importArrowfrom'crocks/Arrow' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import getProp from'crocks/Maybe/getProp' import isString from'crocks/predicates/isString' import objOf from'crocks/helpers/objOf' import option from'crocks/pointfree/option' import safe from'crocks/Maybe/safe' // upperFirst :: String -> String constupperFirst=x=> x.charAt(0) .toUpperCase() .concat(x.slice(1).toLowerCase()) // arrTitleize :: Arrow String const arrTitleize = Arrow(x=> x.split(' ').map(upperFirst).join(' ')) arrTitleize .runWith('tHis is siLLy') //=> 'This Is Silly' // stringProp :: String -> Object -> String conststringProp=key=>compose( option(''), chain(safe(isString)), getProp(key) ) // arrTitleObject :: Arrow Object const arrTitleObject = arrTitleize .promap(stringProp('title'),objOf('title')) arrTitleObject .runWith({ title:'SaY wHaT!?!'}) // { title: 'Say What!?!' } arrTitleObject .runWith({ title:true}) // { title: '' } runkit "},{"title":"runWith","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#runwith","content":"Copy Arrow a b ~> a -> b Arrows are lazy to make combining and extending them easy. Once you have your final computation built out and you are ready to execute it, all you have to do is call runWith on it, passing in the argument you what to run it with. Copy importArrowfrom'crocks/Arrow' importSumfrom'crocks/Sum' import branch from'crocks/Pair/branch' import merge from'crocks/pointfree/merge' import mreduce from'crocks/helpers/mreduce' // data :: [ Number ] const data = [35,60,22,100] // arrLength :: Arrow [ a ] Number const arrLength = Arrow(x=> x.length) arrLength .runWith(data) //=> 4 // arrSum :: Arrow [ Number ] Number const arrSum = Arrow(mreduce(Sum)) arrSum .runWith(data) //=> 217 // arrAvgList :: Arrow [ Number ] Number const arrAvgList = arrSum.first() .compose(arrLength.second()) .promap(branch,merge((x, y)=> x / y)) arrAvgList .runWith(data) //=> 54.25 runkit "},{"title":"second","type":1,"pageTitle":"Arrow","url":"docs/crocks/Arrow#second","content":"Copy Pair p => Arrow a b ~> () -> Arrow (p c a) (p c b) Used to apply a given Arrow over the second slot of a Pair, leaving the first slot untouched. The input to the Arrow must match the expected type on the second slot of the incoming Pair. Copy importArrowfrom'crocks/Arrow' import assign from'crocks/helpers/assign' import branch from'crocks/Pair/branch' import merge from'crocks/pointfree/merge' import objOf from'crocks/helpers/objOf' // names :: Object const names ={ first:'Joey', last:'Fella' } // arrFull :: Arrow Object const arrFull = Arrow(({ first, last })=>`${first}${last}`) .map(objOf('full')) //=> { full: 'Joey Fella' } // arrAddFull :: Arrow Object const arrAddFull = arrFull .second() .promap(branch,merge(assign)) arrAddFull .runWith(names) //=> { full: 'Joey Fella', first: 'Joey', last: 'Fella' } runkit "},{"title":"Reader","type":0,"sectionRef":"#","url":"docs/crocks/Reader","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#implements","content":"Functor, Apply, Chain, Applicative, Monad "},{"title":"Construction","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#construction","content":"Copy Reader :: (e -> a) -> Reader e a The constructor for a Reader type is a unary function that requires another unary function as its input. After passing the constructor a function, it will return a new Reader instance. The left type is parameterized by the input, or domain, of the wrapped function. While the right type represents the return value, or co-domain. The left type e represents a family of Readers that can be combined and must be fixed to that type for all valid combination of instances. Copy importReaderfrom'crocks/Reader' import setProp from'crocks/helpers/setProp' // Reader Object Object Reader(setProp('animal','cat')) //=> Reader (Object -> Object) // Reader a Number Reader(x=> x.length||0) //=> Reader (a -> Number) runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#constructor-methods","content":""},{"title":"ask","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#ask","content":"Copy Reader.ask :: () -> Reader e e Reader.ask :: (e -> b) -> Reader e b A construction helper that returns a Reader with the environment on the right portion of the Reader. ask can take a function, that can be used to map the environment to a different type or value. Copy importReaderfrom'crocks/Reader' const{ ask }=Reader // add :: Number -> Number -> Number constadd= x=>y=> x + y // Typical constructor Reader(add(10)) .runWith(56) //=> 66 // Using `ask` with no function // (identity on environment) ask() .runWith(56) //=> 56 // Using `ask` with a function // (map environment before deposit) ask(add(10)) .runWith(56) //=> 66 runkit "},{"title":"of","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#of","content":"Copy Reader.of :: a -> Reader e a of is used to construct a Reader with the right portion populated with it's argument. of essentially will lift a value of type a into a Reader, giving back a Reader that is \"pointed\" to the specific value provided. of makes for a wonderful starting point for some of the more complicated flows. Copy importReaderfrom'crocks/Reader' import objOf from'crocks/helpers/objOf' import thrush from'crocks/combinators/applyTo' const{ ask }=Reader // add :: Number -> Number -> Number constadd= x=>y=> x + y Reader.of(34) .map(add(6)) .runWith() //=> 40 Reader.of('Bobby') .map(objOf('name')) .runWith() //=> { name: 'Bobby' } Reader.of(57) .chain(x=>ask(add).map(thrush(x))) .runWith(43) //=> 100 runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#instance-methods","content":""},{"title":"map","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#map","content":"Copy Reader e a ~> (a -> b) -> Reader e b While the left side, or the environment, of the Reader must always be fixed to the same type, the right side, or value, of the Reader may vary. Using map allows a function to be lifted into the Reader, mapping the result into the result of the lifted function. Copy importReaderfrom'crocks/Reader' import assign from'crocks/helpers/assign' importBfrom'crocks/combinators/composeB' import getProp from'crocks/Maybe/getProp' import objOf from'crocks/helpers/objOf' import option from'crocks/pointfree/option' const{ ask }=Reader // length :: Array -> Number constlength= x=> x.length ask() .map(length) .runWith([1,2,3]) //=> 3 // propOr :: (String, a) -> b -> a constpropOr=(key, def)=> B(option(def),getProp(key)) // lengthObj :: Array -> Object const lengthObj = B(objOf('length'), length) // addLength :: Object -> Reader Array Object constaddLength=x=> ask(propOr('list',[])) .map(B(assign(x), lengthObj)) Reader.of({ num:27}) .chain(addLength) .runWith({ list:[1,2,3]}) //=> { length: 3, num: 27 } runkit "},{"title":"ap","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#ap","content":"Copy Reader e (a -> b) ~> Reader e a -> Reader e b ap allows for values wrapped in a Reader to be applied to functions also wrapped in a Reader. In order to use ap, the Reader must contain a function as its value. Under the hood, ap unwraps both the function and the value to be applied and applies the value to the function. Finally it will wrap the result of that application back into a Reader. It is required that the inner function is curried. Copy importReaderfrom'crocks/Reader' importBfrom'crocks/combinators/composeB' import assign from'crocks/helpers/assign' import liftA2 from'crocks/helpers/liftA2' import objOf from'crocks/helpers/objOf' const{ ask }=Reader // namePart :: Number -> String -> String constnamePart=indx=>x=> x.split(' ')[indx]||'' // combine :: Object -> Reader Object constcombine= x=>ask(assign(x)) // full :: Reader Object const full = ask(({ full })=> full) // first :: Reader Object const first = full .map(B(objOf('first'),namePart(0))) // last :: Reader Object const last = full .map(B(objOf('last'),namePart(1))) // fluent style Reader.of(assign) .ap(first) .ap(last) .chain(combine) .runWith({ full:'Mary Jones'}) //=> { full: 'Mary Jones', first: 'Mary', last: 'Jones' } // liftAssign :: Reader Object -> Reader Object -> Reader Object const liftAssign = liftA2(assign) // using a lift function liftAssign(first, last) .chain(combine) .runWith({ full:'Tom Jennings'}) //=> { full: 'Tom Jennings', first: 'Tom', last: 'Jennings' } runkit "},{"title":"chain","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#chain","content":"Copy Reader e a ~> (a -> Reader e b) -> Reader e b One of the ways Monads like Reader are able to be combined and have their effects applied, is by using the chain method. In the case of Reader, the effect is to read in and make available the shared environment. chain expects a function that will take any a and return a new Reader with a value of b. Copy importReaderfrom'crocks/Reader' importBfrom'crocks/combinators/composeB' import getProp from'crocks/Maybe/getProp' import option from'crocks/pointfree/option' const{ ask }=Reader // multiply :: Number -> Number -> Number constmultiply= x=>y=> x * y // add :: Number -> Number -> Number constadd= x=>y=> x + y // propOr :: (String, a) -> b -> a constpropOr=(key, def)=> B(option(def),getProp(key)) // applyScale :: Number -> Reader Object Number constapplyScale=x=> ask(propOr('scale',1)) .map(multiply(x)) // applyScale :: Number -> Reader Object Number constapplyOffset=x=> ask(propOr('offset',0)) .map(add(x)) // applyTransforms :: Number -> Reader Object Number constapplyTransform=x=> Reader.of(x) .chain(applyOffset) .chain(applyScale) applyTransform(45) .runWith({}) //=> 45 applyTransform(45) .runWith({ offset:20}) //=> 65 applyTransform(45) .runWith({ scale:2}) //=> 90 applyTransform(45) .runWith({ scale:2, offset:20}) //=> 130 runkit "},{"title":"runWith","type":1,"pageTitle":"Reader","url":"docs/crocks/Reader#runwith","content":"Copy Reader e a ~> e -> a As Reader is a lazy datatype that requires a shared environment to run, it's instance provides a runWith method that takes in an environment and returns the result of the computation. Copy importReaderfrom'crocks/Reader' importPairfrom'crocks/Pair' import fst from'crocks/Pair/fst' import liftA2 from'crocks/helpers/liftA2' import snd from'crocks/Pair/snd' const{ ask }=Reader // data :: Pair Number Number const data = Pair(20,45) // getCorrect :: Reader (Pair Number Number) Number const getCorrect = ask(fst) // getTotal :: Reader (Pair Number Number) Number const getTotal = ask(snd) // divide :: Number -> Number -> Number constdivide= x=>y=> x / y // formatPercent :: Number -> String constformatPercent= x=>`${Math.floor(x *1000)/10}%` // calcPercent :: Reader (Pair Number Number) String const calcPercent = liftA2(divide, getCorrect, getTotal) .map(formatPercent) calcPercent .runWith(data) //=. '44.4%' runkit "},{"title":"ReaderT","type":0,"sectionRef":"#","url":"docs/crocks/ReaderT","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#implements","content":"Functor, Apply, Chain, Applicative, Monad "},{"title":"Construction","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#construction","content":"Copy ReaderT :: MonadTypeRep M, Monad m => M -> Reader(M) e (m a) ReaderT is a type constructor that defines a unary function that takes a constructor, or TypeRep, of any Monad and returns a new constructor that can be used to construct Reader instances that fix the far right portion of the Reader(M) to the provided Monad. The ReaderT constructor can be thought of as a constructor that constructs a constructor. Copy importReaderTfrom'crocks/Reader/ReaderT' importMaybefrom'crocks/Maybe' importAsyncfrom'crocks/Async' // MaybeReader :: Reader(Maybe) constMaybeReader= ReaderT(Maybe) // AsyncReader :: Reader(Async) constAsyncReader= ReaderT(Async) MaybeReader.of('nice') .runWith() //=> Just \"nice\" // AsyncReader e Boolean AsyncReader.of(true) .runWith() //=> Resolved Boolean runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#constructor-methods","content":""},{"title":"ask","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#ask","content":"Copy ReaderT.ask :: Monad m => () -> ReaderT e (m e) ReaderT.ask :: Monad m => (e -> a) -> ReaderT e (m a) A construction helper that returns a ReaderT with environment on the right portion of the Reader. ask can take a function, that can be used to map the environment to a different type or value. When using the function version, the function must return the type of the Monad the ReaderT wraps, which in turn will be wrapped in another Copy importReaderTfrom'crocks/Reader/ReaderT' importMaybefrom'crocks/Maybe' import safe from'crocks/Maybe/safe' import isNumber from'crocks/predicates/isNumber' constMaybeReader=ReaderT(Maybe) const{ ask }=MaybeReader // add :: Number -> Number -> Number constadd= x=>y=> x + y // Typical Constructor MaybeReader(safe(isNumber)) .runWith(76) //=> Just 76 MaybeReader(safe(isNumber)) .runWith('76') //=> Nothing // Using `ask` with no function // (identity on environment) ask() .runWith(76) //=> Just 76 ask() .runWith('76') //=> Just '76' // Using `ask` with a function // (map environment before deposit) ask(add(10)) .runWith(76) //=> Just 86 runkit "},{"title":"lift","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#lift","content":"Copy ReaderT.lift :: Monad m => m a -> ReaderT e (m a) Used to promote an instance of a given Monad into a ReaderT of that Monads type. This can be used to lift a pointed instance of the underlying Monad. When mixed with composition, lift can be used to promote functions that take the form of a -> m b into a function that can be chained with the ReaderT. Although, liftFn can be used to remove the composition boilerplate and promote and a -> m b function. Copy importReaderTfrom'crocks/Reader/ReaderT' importAsyncfrom'crocks/Async' import compose from'crocks/helpers/compose' import curry from'crocks/helpers/curry' import flip from'crocks/combinators/flip' import runWith from'crocks/pointfree/runWith' import tap from'crocks/helpers/tap' constAsyncReader=ReaderT(Async) const{ ask, lift }=AsyncReader const{Rejected}=Async // log :: String -> a -> () constlog=label=> console.log.bind(console, label +':') // forkLog :: Async a b -> Async a b const forkLog =tap( m=> m.fork(log('rej'),log('res')) ) // runAndLog :: e -> ReaderT e (Async a b) -> Async a b const runAndLog =curry( x=>compose(forkLog,flip(runWith, x)) ) // instance :: ReaderT e (Async String a) const instance = lift(Rejected('Always Rejected')) runAndLog(instance,'Thomas') //=> rej: Always Rejected // Using in a composition // rejectWith :: a -> ReaderT e (Async a b) const rejectWith = compose(lift,Rejected) // envReject :: ReadetT e (Async e b) const envReject = ask() .chain(rejectWith) runAndLog(envReject,'Sammy') //=> rej: Sammy runkit "},{"title":"liftFn","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#liftfn","content":"Copy ReaderT.liftFn :: Monad m => (a -> m b) -> a -> ReaderT e (m b) Used to transform a given function in the form of a -> m b into a lifted function, where m is the underlying Monad of a ReaderT. This allows for the removal of composition boilerplate that results from using thelift helper. Copy importReaderTfrom'crocks/Reader/ReaderT' importEitherfrom'crocks/Either' import ifElse from'crocks/logic/ifElse' constEitherReader=ReaderT(Either) const{ ask, liftFn }=EitherReader const{Left,Right}=Either // gte :: Number -> Number -> Either String Number constgte=x=>ifElse( n=> n >= x, Right, n=>Left(`${n} is not gte to ${x}`) ) // gte10 :: Number -> Either String Number const gte10 = gte(10) // add20 :: ReaderT Number (Either String Number) const add20 = ask() .chain(liftFn(gte10)) .map(n=> n +20) add20 .runWith(30) //=> Right 50 add20 .runWith(9) //=> Left \"9 is not gte to 10\" runkit "},{"title":"of","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#of","content":"Copy ReaderT.of :: Monad m => a -> ReaderT e (m a) Lifts a value into a ReaderT using the of method of the underlying Monad.of will disregard the environment and points the right portion to the provided value. Copy importReaderTfrom'crocks/Reader/ReaderT' importMaybefrom'crocks/Maybe' importEitherfrom'crocks/Either' importStatefrom'crocks/State' constMaybeReader=ReaderT(Maybe) constEitherReader=ReaderT(Either) constStateReader=ReaderT(State) MaybeReader.of('yep') .map(x=> x.toUpperCase()) .runWith(23) //=> Just \"YEP\" EitherReader.of(43) .runWith(23) //=> Right 43 StateReader.of(0) .runWith(23) .runWith(42) //=> Pair(0, 42) runkit "},{"title":"Instance Methods","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#instance-methods","content":""},{"title":"map","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#map","content":"Copy Monad m => ReaderT e (m a) ~> (a -> b) -> ReaderT e (m b) Provides a means for lifting a normal javascript function into the underlying Monad, allowing the innermost value of the underlying Monad to be mapped. This method will ignore the outer ReaderT, and be applied directly to the underlying Monad. Copy importReaderTfrom'crocks/Reader/ReaderT' importMaybefrom'crocks/Maybe' import isString from'crocks/predicates/isString' import safe from'crocks/Maybe/safe' constMaybeReader= ReaderT(Maybe) const{ ask, liftFn }=MaybeReader // maybeString :: a -> Maybe String const maybeString = safe(isString) // toUpper :: String -> String consttoUpper= x=> x.toUpperCase() // envToUpper :: ReaderT e (Maybe String) const envToUpper = ask() .chain(liftFn(maybeString)) .map(toUpper) envToUpper .runWith(4) //=> Nothing envToUpper .runWith('hola') //=> Just \"HOLA\" runkit "},{"title":"ap","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#ap","content":"Copy Monad m => ReaderT e (m (a -> b)) ~> ReaderT e (m a) -> ReaderT e (m b) Applies wrapped functions to the provided value, using the ap of the underlying Monad. A ReaderT of the underlying Monad must be provided, which allows access to the environment. Copy importPairfrom'crocks/Pair' importReaderTfrom'crocks/Reader/ReaderT' importResultfrom'crocks/Result' import fst from'crocks/Pair/fst' import snd from'crocks/Pair/snd' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import liftA2 from'crocks/helpers/liftA2' const{Err,Ok}=Result constResultReader= ReaderT(Result) const{ ask, liftFn }=ResultReader // add :: Number -> Number -> Number constadd= x=>y=> x + y // makeError :: a -> Result [ String ] b constmakeErr= x=>Err([`${x} is not a Number`]) // isValid :: a -> ReaderT e (Result [ String ] Number) const isValid =liftFn( ifElse(isNumber,Ok, makeErr) ) // first :: ReaderT (Pair a b) (Result [ String ] Number) const first = ask(fst) .chain(isValid) // second :: ReaderT (Pair a b) (Result [ String ] Number) const second = ask(snd) .chain(isValid) // Using a fluent style with of ResultReader.of(add) .ap(first) .ap(second) .runWith(Pair(34,21)) //=> Ok 55 // Using a fluent style with map first .map(add) .ap(second) .runWith(Pair(true,21)) //=> Err [ \"true is not a Number\" ] // Using liftA2 liftA2(add, first, second) .runWith(Pair('Bob','Jones')) //=> Err [ 'Bob is not a Number', 'Jones is not a Number' ] runkit "},{"title":"chain","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#chain","content":"Copy Monad m => ReaderT e (m a) ~> Reader e (a -> ReaderT e (m b)) -> ReaderT e (m b) Can be used to apply the effects of the underlying Monad with the benefit of being able to read from the environment. This method only accepts functions of the form Monad m => a -> ReaderT e (m b). Copy importReaderTfrom'crocks/Reader/ReaderT' importMaybefrom'crocks/Maybe' import getProp from'crocks/Maybe/getProp' constMaybeReader= ReaderT(Maybe) const{ ask, liftFn }=MaybeReader // readProp :: String -> b -> ReaderT e (Maybe a) constreadProp=key=> liftFn(getProp(key)) // getName :: ReaderT e (Maybe a) const getName = ask() .chain(readProp('name')) // getFirstName :: ReaderT e (Maybe a) const getFirstName = getName .chain(readProp('first')) // getLastName :: ReaderT e (Maybe a) const getLastName = getName .chain(readProp('last')) // person :: Object const person ={ name:{ first:'Hazel', middle:'Anne' } } getFirstName .runWith(person) //=> Just \"Hazel\" getLastName .runWith(person) //=> Nothing getLastName .runWith(10) //=> Nothing runkit "},{"title":"runWith","type":1,"pageTitle":"ReaderT","url":"docs/crocks/ReaderT#runwith","content":"Copy Monad m => ReaderT e (m a) ~> e -> m a In order to unwrap the underlying Monad, ReaderT needs to be ran with a given environment. A ReaderT instance comes equipped with a runWith method that accepts an environment and returns the resulting Monad. Copy importReaderTfrom'crocks/Reader/ReaderT' importMaybefrom'crocks/Maybe' import getProp from'crocks/Maybe/getProp' constMaybeReader=ReaderT(Maybe) const{ ask, liftFn }=MaybeReader // data :: Object const data ={ animals:[ 'tiger','muskrat','mouse' ] } // length :: Array -> Number constlength= x=> x.length // prop :: String -> ReaderT Object (Maybe []) constprop=key=> ask() .chain(liftFn(getProp(key))) prop('animals') .map(length) .runWith(data) //=> Just 3 runkit "},{"title":"Pred","type":0,"sectionRef":"#","url":"docs/crocks/Pred","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#implements","content":"Semigroup, Monoid, Contravariant "},{"title":"Construction","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#construction","content":"Copy Pred :: (a -> Boolean) -> Pred a The Pred constructor is a unary function that requires a unary predicate function as its sole argument. Once provided with its predicate function, the constructor will return a new Pred instance wrapping the predicate. If the function provided is not a predicate, then the resulting value will be coerced to a Boolean. Copy importPredfrom'crocks/Pred' import and from'crocks/logic/and' import isArray from'crocks/predicates/isArray' // isEmpty :: a -> Boolean constisEmpty= x=>!x.length // isEmptyArray :: a -> Boolean const isEmptyArray = and(isArray, isEmpty) Pred(isEmptyArray) //=> Pred a runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#empty","content":"Copy Pred.empty :: () -> Pred a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Pred the result of empty is a Pred that will always return true. empty is available on both the Constructor and the Instance for convenience. Copy importPredfrom'crocks/Pred' import isEmpty from'crocks/predicates/isEmpty' import not from'crocks/logic/not' // empty :: Pred a const empty = Pred.empty() // notEmpty :: Pred a const notEmpty = Pred(not(isEmpty)) empty .runWith('') //=> true notEmpty .concat(empty) .runWith([]) //=> false notEmpty .concat(empty) .runWith([1,2,3]) //=> true empty .concat(notEmpty) .runWith('') //=> false empty .concat(notEmpty) .runWith('123') //=> true runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#instance-methods","content":""},{"title":"concat","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#concat","content":"Copy Pred a ~> Pred a -> Pred a concat is used to combine two Semigroups of the same type under an operation specified by the Semigroup. In the case of Pred, the results of both Predss are combined under logical conjunction. Copy importPredfrom'crocks/Pred' import or from'crocks/logic/or' import not from'crocks/logic/not' import filter from'crocks/pointfree/filter' constisEven= x=>!(x %2) // isOdd :: Pred Number const isOdd = Pred(not(isEven)) // lt20 :: Pred Number const lt20 = Pred(x=> x <20) // gt5 :: Pred Number const gt5 = Pred(x=> x >5) // inRange :: Pred Number const inRange = lt20.concat(gt5) // isOddInRange :: Pred Number const isOddInRange = isOdd.concat(inRange) // isValid :: Pred Number const isValid = Pred(or(isEven, isOddInRange)) // data :: [ Number ] const data = [1,4,12,19,32,99,76,7] isOdd .runWith(5) //=> true isOdd .runWith(8) //=> false filter(isOdd, data) //=> [ 1, 19, 99, 7 ] filter(lt20, data) //=> [ 1, 4, 12, 19, 7 ] filter(gt5, data) //=> [ 12, 19, 32, 99, 76, 7 ] filter(inRange, data) //=> [ 12, 19, 7 ] filter(isOddInRange, data) //=> [ 19, 7 ] filter(isEven, data) // [ 4, 12, 32, 76 ] filter(isValid, data) //=> [ 4, 12, 19, 32, 76, 7 ] runkit "},{"title":"contramap","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#contramap","content":"Copy Pred a ~> (b -> a) -> Pred b While the output of a Pred is fixed to Boolean, the input can vary type and value. This allows a given Pred to be adapted by mapping on the input, before it hits the wrapped predicate function. Using contramap, functions are lifted, mapping the input to now accept the type of the input of the given function. Copy importPredfrom'crocks/Pred' import contramap from'crocks/pointfree/contramap' import getPropOr from'crocks/helpers/getPropOr' // Length :: String | Function | Array // length :: Length -> Number const length = getPropOr(0,'length') // gt5 :: Pred Number const gt5 = Pred(x=> x >5) // lengthGt5 :: Pred Length const validLength = contramap(length, gt5) // validItemLength :: Pred Object const validItemLength = contramap(getPropOr(null,'item'), validLength) gt5 .runWith(5) //=> false gt5 .runWith(10) //=> true validLength .runWith([1,2,3,4,5,6]) //=> true validLength .runWith(null) //=> false validLength .runWith('1234') //=> false validItemLength .runWith({ item:'this is an item'}) //=> true runkit "},{"title":"valueOf","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#valueof","content":"Copy Pred a ~> () -> a -> Boolean valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Pred instance will result in the underlying predicate function. Most of the time this will not be required when working with crocks because all crocks functions that take a predicate function can also take a Pred instance. Copy importPredfrom'crocks/Pred' import equals from'crocks/pointfree/equals' import isArray from'crocks/predicates/isArray' import isString from'crocks/predicates/isString' import or from'crocks/logic/or' // lengthIsThree :: Pred a const lengthIsThree = Pred(equals(3)) .contramap(x=> x.length) // pred :: Pred a const pred = Pred(or(isArray, isString)) .concat(lengthIsThree) // fn :: a -> Boolean const fn = pred.valueOf() pred .runWith(null) //=> false pred .runWith([1,2,3]) //=> true pred .runWith('This is fun') //=> true fn(null)// false fn([1,2,3])// true fn('This is fun')// true fn([])// false fn('')// false runkit "},{"title":"runWith","type":1,"pageTitle":"Pred","url":"docs/crocks/Pred#runwith","content":"Copy Pred a ~> a -> Boolean As Pred wraps a predicate function, it needs a mean to run it with some value to test against the predicate. Pred instances provide a method called runWith that will accept the value to be tested and then runs it through the predicate returning the result. Most of the time this function is not used while working with other predicate functions in crocks, as all functions that take a predicate function also take a Pred instance. It does come in handy though when supplying predicates to other libraries. Copy importPredfrom'crocks/Pred' import hasProp from'crocks/predicates/hasProp' import equals from'crocks/pointfree/equals' import flip from'crocks/combinators/flip' import runWith from'crocks/pointfree/runWith' // trueBlue :: Pred Object const trueBlue = Pred(equals(true)) .contramap(({ blue })=> blue) // isValid :: Pred a const isValid = Pred(hasProp('blue')) .concat(trueBlue) // checkValid :: a -> Boolean const checkValid = flip(runWith, isValid) checkValid(null)//=> false checkValid([1,2,3])//=> false checkValid({ blue:32})//=> false checkValid({ blue:true})//=> true runkit "},{"title":"Functions","type":0,"sectionRef":"#","url":"docs/functions/","content":"","keywords":""},{"title":"Combinators","type":1,"pageTitle":"Functions","url":"docs/functions/#combinators","content":"Function\tSignature\tLocationapplyTo\ta -> (a -> b) -> b\tcrocks/combinators/applyTo composeB\t(b -> c) -> (a -> b) -> a -> c\tcrocks/combinators/composeB constant\ta -> () -> a\tcrocks/combinators/constant converge\t(b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\tcrocks/combinators/converge flip\t(a -> b -> c) -> b -> a -> c\tcrocks/combinators/flip identity\ta -> a\tcrocks/combinators/identity psi\t(b -> b -> c) -> (a -> b) -> a -> a -> c\tcrocks/combinators/psi substitution\t(a -> b -> c) -> (a -> b) -> a -> c\tcrocks/combinators/substitution "},{"title":"Helpers","type":1,"pageTitle":"Functions","url":"docs/functions/#helpers","content":"Function\tSignature\tLocationassign\tObject -> Object -> Object\tcrocks/helpers/assign assoc (deprecated)\t(String | Integer) -> a -> (Object | Array) -> (Object | Array)\tcrocks/helpers/assoc binary\t((*) -> c) -> a -> b -> c\tcrocks/helpers/binary branch\ta -> Pair a a\tcrocks/Pair/branch compose\t((y -> z), ..., (a -> b)) -> a -> z\tcrocks/helpers/compose composeK\tChain m => ((y -> m z), ..., (a -> m b)) -> a -> m z\tcrocks/helpers/composeK composeP\tPromise p => ((y -> p z c), ..., (a -> p b c)) -> a -> p z c\tcrocks/helpers/composeP composeS\tSemigroupoid s => (s y z, ..., s a b) -> s a z\tcrocks/helpers/composeS curry\t((a, b, ...) -> z) -> a -> b -> ... -> z\tcrocks/helpers/curry defaultProps\tObject -> Object -> Object\tcrocks/helpers/defaultProps defaultTo\ta -> b -> a\tcrocks/helpers/defaultTo dissoc (deprecated)\t(String | Integer) -> a -> a\tcrocks/helpers/dissoc fanout\t(a -> b) -> (a -> c) -> (a -> Pair b c)\tcrocks/Pair/fanout find\tFoldable f => ((a -> Boolean) | Pred) -> f a -> Maybe a\tcrocks/Maybe/find fromPairs\tFoldable f => f (Pair String a) -> Object\tcrocks/helpers/fromPairs getPath\t[ (String | Integer) ] -> a -> Maybe b\tcrocks/Maybe/getPath getPathOr\ta -> f [ (String | Integer) ] -> b -> a\tcrocks/helpers/getPathOr getProp\t(String | Integer) -> a -> Maybe b\tcrocks/Maybe/getProp getPropOr\ta -> (String | Integer) -> b -> c\tcrocks/helpers/getPropOr liftA2\tApplicative m => (a -> b -> c) -> m a -> m b -> m c\tcrocks/helpers/liftA2 liftA3\tApplicative m => (a -> b -> c -> d) -> m a -> m b -> m c -> m d\tcrocks/helpers/liftA3 liftN\tApplicative m => Number -> ((*) -> a) -> (*m) -> m a\tcrocks/helpers/liftN mapProps\tObject -> Object -> Object\tcrocks/helpers/mapProps mapReduce\tFoldable f => (a -> b) -> (c -> b -> c) -> c -> f a -> c\tcrocks/helpers/mapReduce mconcat\tMonoid m, Foldable f => m -> f a -> m a\tcrocks/helpers/mconcat mconcatMap\tMonoid m, Foldable f => m -> (b -> a) -> f b -> m a\tcrocks/helpers/mconcatMap mreduce\tMonoid m, Foldable f => m -> f a -> a\tcrocks/helpers/mreduce mreduceMap\tMonoid m, Foldable f => m -> (b -> a) -> f b -> a\tcrocks/helpers/mreduceMap nAry\tNumber -> ((*) -> a) -> (*) -> a\tcrocks/helpers/nAry objOf\tString -> a -> Object\tcrocks/helpers/objOf omit\t[ String ] -> Object -> Object\tcrocks/helpers/omit once\t((*) -> a) -> ((*) -> a)\tcrocks/helpers/once partial\t(((*) -> c), *) -> (*) -> c\tcrocks/helpers/partial pick\tFoldable f => f String -> Object -> Object\tcrocks/helpers/pick pipe\t((a -> b), ..., (y -> z)) -> a -> z\tcrocks/helpers/pipe pipeK\tChain m => ((a -> m b), ..., (y -> m z)) -> a -> m z\tcrocks/helpers/pipeK pipeP\tPromise p => ((a -> p b d), ..., (y -> p z d)) -> a -> p z d\tcrocks/helpers/pipeP pipeS\tSemigroupoid s => (s a b, ..., s y z) -> s a z\tcrocks/helpers/pipeS prop (deprecated)\t(String | Integer) -> a -> Maybe b\tcrocks/Maybe/prop propOr (deprecated)\ta -> (String | Integer) -> b -> c\tcrocks/helpers/propOr propPath (deprecated)\t[ (String | Integer) ] -> a -> Maybe b\tcrocks/Maybe/propPath propPathOr (deprecated)\ta -> [ (String | Integer) ] -> b -> a\tcrocks/helpers/propPathOr safe\t((a -> Boolean) | Pred) -> a -> Maybe a\tcrocks/Maybe/safe safeAfter\tsafeAfter :: ((b -> Boolean) | Pred) -> (a -> b) -> a -> Maybe b\tcrocks/Maybe/safeAfter safeLift\t((a -> Boolean) | Pred) -> (a -> b) -> a -> Maybe b\tcrocks/Maybe/safeLift setPath\t[ (String | Integer) ] -> a -> (Object | Array) -> (Object | Array)\tcrocks/helpers/setPath setProp\t(String | Integer) -> a -> (Object | Array) -> (Object | Array)\tcrocks/helpers/setProp tap\t(a -> b) -> a -> a\tcrocks/helpers/tap toPairs\tObject -> List (Pair String a)\tcrocks/Pair/toPairs tryCatch\t((*) -> b) -> (*) -> Result e b\tcrocks/Result/tryCatch unary\t((*) -> b) -> a -> b\tcrocks/helpers/unary unit\t() -> undefined\tcrocks/helpers/unit unsetPath\t[ (String | Integer) ] -> a -> a\tcrocks/helpers/unsetPath unsetProp\t(String | Integer) -> a -> a\tcrocks/helpers/unsetProp "},{"title":"Logic","type":1,"pageTitle":"Functions","url":"docs/functions/#logic","content":"Every function in crocks, that takes a predicate function of the form a -> Boolean, can be replaced with a Pred instance of the type: Pred a and vice-versa Function\tSignature\tLocationand\t(a -> Boolean) -> (a -> Boolean) -> a -> Boolean\tcrocks/logic/and ifElse\t(a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b\tcrocks/logic/ifElse implies\t(a -> Boolean) -> (a -> Boolean) -> a -> Boolean\tcrocks/logic/implies not\t(a -> Boolean) -> a -> Boolean\tcrocks/logic/not or\t(a -> Boolean) -> (a -> Boolean) -> a -> Boolean\tcrocks/logic/or unless\t(a -> Boolean) -> (a -> a) -> a -> a\tcrocks/logic/unless when\t(a -> Boolean) -> (a -> a) -> a -> a\tcrocks/logic/when "},{"title":"Either","type":0,"sectionRef":"#","url":"docs/crocks/Either","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Either","url":"docs/crocks/Either#implements","content":"Setoid, Semigroup, Functor, Alt, Apply, Traversable, Chain, Applicative, Monad "},{"title":"Construction","type":1,"pageTitle":"Either","url":"docs/crocks/Either#construction","content":"Copy Either :: a -> Either c a An Either is typically constructed by using one of the instance constructors provided on the TypeRep: Left or Right. For consistency, an Either can be constructed using its TypeRep as a constructor. The constructor is a unary function that accepts any type a and will return aRight instance, wrapping the value it was passed. Copy importEitherfrom'crocks/Either' import equals from'crocks/pointfree/equals' Either(90) //=> Right 90 Either.of(90) //=> Right 90 Either.Right(90) //=> Right 90 equals( Either.Right([1,2,3]), Either.of([1,2,3]) ) //=> true equals( Either.of({ a:100}), Either({ a:100}) ) //=> true runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Either","url":"docs/crocks/Either#constructor-methods","content":""},{"title":"Left","type":1,"pageTitle":"Either","url":"docs/crocks/Either#left","content":"Copy Either.Left :: c -> Either c a Used to construct a Left instance of an Either that represents the false portion of a disjunction. The Left constructor takes a value of any type and returns a Left instance wrapping the value passed to the constructor. When an instance is a Left, most Either returning methods on the instance will do nothing to the wrapped value and return another Left with the same initial value the Left instance was constructed with. Copy importEitherfrom'crocks/Either' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import isString from'crocks/predicates/isString' import ifElse from'crocks/logic/ifElse' const{Left,Right}=Either // yell :: String -> String constyell= x=>`${x.toUpperCase()}!` // safeYell :: a -> Either a String const safeYell =ifElse( isString, compose(Right, yell), Left ) Right('excite') .map(yell) //=> Right \"EXCITE!\" Left('whisper') .map(yell) //=> Left \"whisper\" chain(safeYell,Right('outside voice')) //=> Right \"OUTSIDE VOICE!\" chain(safeYell,Left({ level:'inside voice'})) //=> Left { level: 'inside voice' } runkit "},{"title":"Right","type":1,"pageTitle":"Either","url":"docs/crocks/Either#right","content":"Copy Either.Right :: a -> Either c a Used to construct a Right instance of the an Either that represents the true portion of a disjunction. The Right constructor takes any value and will return a new Right instance wrapping the value provided. Copy importEitherfrom'crocks/Either' import compose from'crocks/helpers/compose' import composeK from'crocks/helpers/composeK' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' const{Left,Right}=Either // validate :: (b -> Boolean) -> Either c a constvalidate=pred=> ifElse(pred,Right,Left) // add10 :: Number -> Number constadd10= x=> x +10 Right(10) .map(add10) //=> Right 20 Left('Not A Number') .map(add10) //=> Left \"Not A Number\" // validNumber :: b -> Either c Number const validNumber = validate(isNumber) validNumber('60') //=> Left \"60\" validNumber(null) //=> Left null validNumber(60) //=> Right 60 // safeAdd10 :: b -> Either c Number const safeAdd10 =composeK( compose(Right, add10), validNumber ) safeAdd10([7]) //=> Left [ 7 ] safeAdd10(null) //=> Left null safeAdd10(5) //=> Right 15 // isLarge :: Number -> Either Number Number const isLarge = validate(x=> x >=10) // isLargeNumber :: b -> Either c Number const isLargeNumber = composeK(isLarge, validNumber) // add10ToLarge :: b -> Either c Number const add10ToLarge = composeK(safeAdd10, isLargeNumber) add10ToLarge() //=> Left undefined add10ToLarge('40') //=> Left \"40\" add10ToLarge(5) //=> Left 5 add10ToLarge(10) //=> Right 20 runkit "},{"title":"of","type":1,"pageTitle":"Either","url":"docs/crocks/Either#of","content":"Copy Either.of :: a -> Either c a Used to lift any value into an Either as a Right, of is used mostly by helper functions that work \"generically\" with instances of either Applicative or Monad. When working specifically with the Either type, the Right constructor should be used. Reach for of when working with functions that will work with ANY Applicative/Monad. Copy importEitherfrom'crocks/Either' const{Right}=Either Either.of('some string') //=> Right \"some string\" Either.of(undefined) //=> Right undefined Either('some string') //=> Right \"some string\" Either(undefined) //=> Right undefined Right('some string') //=> Right \"some string\" Right(undefined) //=> Right undefined runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Either","url":"docs/crocks/Either#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Either","url":"docs/crocks/Either#equals","content":"Copy Either c a ~> b -> Boolean Used to compare the underlying values of two Either instances for equality by value, equals takes any given argument and returns true if the passed arguments is a Either of the same instance with an underlying value equal to the underlying value of the Either the method is being called on. If the passed argument is not an Either of the same instance or the underlying values are not equal, equals will return false. Copy importEitherfrom'crocks/Either' import equals from'crocks/pointfree/equals' const{Left,Right}=Either Right(null) .equals(Right(null)) //=> true Left('happy') .equals(Left('happy')) //=> true Left('sad') .equals(Right('sad')) //=> false // by value, not reference for most types Right([1,{ a:2},'string']) .equals(Right([1,{ a:2},'string'])) //=> true equals(Right('sad'),'sad') //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Either","url":"docs/crocks/Either#concat","content":"Copy Semigroup s => Either c s ~> Either c s -> Either c s When an underlying Right value of a given Either is fixed to a Semigroup, concat can be used to concatenate another Right instance with an underlying Semigroup of the same type. Expecting an Either wrapping a Semigroup of the same type, concat will give back a new Either instance wrapping the result of combining the two underlying Semigroups. When called on a Left instance, concat will return a Left containing the initial value. Copy importEitherfrom'crocks/Either' importAssignfrom'crocks/Assign' import compose from'crocks/helpers/compose' import concat from'crocks/pointfree/concat' import flip from'crocks/combinators/flip' import ifElse from'crocks/logic/ifElse' import isObject from'crocks/predicates/isObject' import mapReduce from'crocks/helpers/mapReduce' const{Left,Right}=Either Right([1,2]) .concat(Right([4,5])) //=> Right [ 1, 2, 3, 4 ] Right([1,2]) .concat(Left('Error')) //=> Left \"Error\" // lift :: Object -> Either c Assign const lift = compose(Right,Assign) // liftObject :: b -> Either c Assign const liftObject = ifElse(isObject, lift,Left) // Foldable f => fold :: f * -> Either * Assign const fold =mapReduce( liftObject, flip(concat), Either(Assign.empty()) ) fold([{ a:'a'},{ b:'b'}]) //=> Right Assign { a: \"a\", b: \"b\" } fold([ { a:'a'},null,{ c:'c'} ]) //=> Left null runkit "},{"title":"map","type":1,"pageTitle":"Either","url":"docs/crocks/Either#map","content":"Copy Either c a ~> (a -> b) -> Either c b Used to apply transformations to values Right instances of Either, map takes a function that it will lift into the context of the Either and apply to it the wrapped value. When ran on a Right instance, map will apply the wrapped value to the provided function and return the result in a new Right instance. Copy importEitherfrom'crocks/Either' import compose from'crocks/helpers/compose' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import map from'crocks/pointfree/map' import objOf from'crocks/helpers/objOf' const{Left,Right}=Either // add :: Number -> Number -> Number constadd= x=>y=> x + y Right(25) .map(add(10)) //=> Right 35 Left('Some String') .map(add(10)) //=> Left \"Some String\" // numberOr :: a -> Either b Number const numberOr =ifElse( isNumber,Right,Left ) // add10 -> a -> Either b Number const add10 =compose( map(add(10)), numberOr ) add10(45) //=> Right 55 add10('some string') //=> Left \"some string\" const processResult =compose( map(compose(objOf('result'),add(20))), numberOr ) processResult({ a:57}) //=> Left { a: 57 } processResult(57) //=> Right{ result: 77 } runkit "},{"title":"alt","type":1,"pageTitle":"Either","url":"docs/crocks/Either#alt","content":"Copy Either c a ~> Either c a -> Either c a Providing a means for a fallback or alternative value, alt combines two Either instances and will return the first Right it encounters or the last Left if it does not encounter a Right. Copy importEitherfrom'crocks/Either' const{Left,Right}=Either Right(45) .alt(Right(97)) .alt(Left(false)) //=> Right 45 Left('String') .alt(Left('Another String')) .alt(Left('Final String')) //=> Left \"Final String\" Left('error') .alt(Right({ passed:true})) //=> Right { passed: true } runkit "},{"title":"bimap","type":1,"pageTitle":"Either","url":"docs/crocks/Either#bimap","content":"Copy Either c a ~> ((c -> d), (a -> b)) -> Either d b The types and values that make up an Either can vary independently in both the Left and Right instances of the Either. While map can be used to apply a transformation to a Right instance, bimap allows transformations for either. bimap takes two mapping functions as its arguments. The first function is used to map a Left instance, while the second maps a Right. Either only provides a means to map a Right instance exclusively using map. If the need arises to map a Left instance exclusively, then bimap can be used, passing the mapping function to the first argument and an identity to the second. Copy importEitherfrom'crocks/Either' import bimap from'crocks/pointfree/bimap' import compose from'crocks/helpers/compose' import ifElse from'crocks/logic/ifElse' import objOf from'crocks/helpers/objOf' const{Left,Right}=Either // lte :: Number -> Number -> Boolean constlte= x=>y=> y <= x // gt10 :: Number -> Either Number Number const gt10 = ifElse(lte(10),Left,Right) // offsetBy :: Number -> Number -> Number constoffsetBy= x=>y=> x + y // scaleBy :: Number -> Number -> Number constscaleBy= x=>y=> x * y // compute :: Number -> Either Number Number const compute =compose( bimap(scaleBy(10),offsetBy(10)), gt10 ) compute(10) //=> Left 100 compute(20) //=> Right 30 // arrayOf :: a -> [ a ] constarrayOf= x=>[ x ] // resultOf :: a -> { result: a } const resultOf = objOf('result') // format :: Either c a -> Either [ c ] { result: a } const format = bimap(arrayOf, resultOf) format(Left(100)) //=> Left [ 100 ] format(Right(30)) //=> Right { result: 30 } // processAndFormat :: Either Number Number -> Either [ Number ] { result: Number } const processAndFormat =bimap( compose(arrayOf,scaleBy(10)), compose(resultOf,offsetBy(10)) ) // flow :: Number -> Either [ Number ] const flow =compose( processAndFormat, gt10 ) flow(10) //=> Left [ 100 ] flow(20) //=> Right { result: 30 } runkit "},{"title":"ap","type":1,"pageTitle":"Either","url":"docs/crocks/Either#ap","content":"Copy Either c (a -> b) ~> Either c a -> Either c b Short for apply, ap is used to apply an Either instance containing a value to another Either instance that contains a function, resulting in new Either instance containing the result of the application. ap requires that it is called on either a Left containing anything or a Right that wraps a curried polyadic function. When either instance is a Left, ap will return a Left containing the original value. This can be used to safely combine multiple values under a given combination function. If any of the inputs results in a Left than they will never be applied to the function and not provide exceptions or undesired results. Copy importEitherfrom'crocks/Either' import assign from'crocks/helpers/assign' import setProp from'crocks/helpers/setProp' import compose from'crocks/helpers/compose' import identity from'crocks/combinators/identity' import ifElse from'crocks/logic/ifElse' import isObject from'crocks/predicates/isObject' import objOf from'crocks/helpers/objOf' const{Left,Right}=Either // objectOr :: a -> Either c Object const objectOr = ifElse(isObject,Right,Left) // Error :: { error: a, passed: Boolean } // error :: a -> Error const error =compose( setProp('passed',false), objOf('error') ) // setPassed :: Either c Object -> Either Error Object constsetPassed=m=> Either.of(setProp('passed',true)) .ap(m) .bimap(error, identity) setPassed(Right({ a:'awesome'})) //=> Right { a: \"awesome\", passed: true } setPassed(Left({ a:'not so much'})) //=> Left { error: { a: \"not so much\" }, passed: false } // process :: a -> Either Object Object const process = compose(setPassed, objectOr) process({ a:'awesome'}) //=> Right { a: \"awesome\", passed: true } process('I am string') //=> Left { error: \"I am string\", passed: false } // assignOr :: (Either c Object, Either c Object) -> Either c Object constassignOr=(x, y)=> x.map(assign).ap(y) assignOr(Right({ b:'also awesome'}),Right({ a:'awesome'})) //=> Right { a: \"awesome\", b: \"also awesome\" } assignOr(Right({ b:'also awesome'}),Left('not so awesome')) //=> Left \"not so awesome\" assignOr(Left({ b:'first'}),Left({ b:'second'})) //=> Left { b: \"first\" } runkit "},{"title":"sequence","type":1,"pageTitle":"Either","url":"docs/crocks/Either#sequence","content":"Copy Apply f => Either c (f a) ~> (b -> f b) -> f (Either c a) Applicative f => Either c (f a) ~> TypeRep f -> f (Either c a) When an instance of Either wraps an Apply instance, sequence can be used to swap the type sequence. sequence requires either an Applicative TypeRep or an Apply returning function is provided for its argument. This will be used in the case that the Either instance is a Left. sequence can be derived from traverse by passing it an identity function. Copy importEitherfrom'crocks/Either' importIdentityfrom'crocks/Identity' const{Left,Right}=Either // arrayOf :: a -> [ a ] constarrayOf= x=>[ x ] Right([1,2,3]) .sequence(arrayOf) //=> [ Right 1, Right 2, Right 3 ] Left('no array here') .sequence(arrayOf) //=> [ Left \"no array here\" ] Right(Identity.of(42)) .sequence(Identity) //=> Identity (Right 42) Left(0) .sequence(Identity) //=> Identity (Left 0) runkit "},{"title":"traverse","type":1,"pageTitle":"Either","url":"docs/crocks/Either#traverse","content":"Copy Apply f => Either c a ~> (d -> f d), (a -> f b)) -> f Either c b Applicative f => Either c a ~> (TypeRep f, (a -> f b)) -> f Either c b Used to apply the \"effect\" of an Apply to a value inside of an Either,traverse combines both the \"effects\" of the Apply and the Either by returning a new instance of the Apply, wrapping the result of the Applys \"effect\" on the value in the supplied Either. traverse requires either an Applicative TypeRep or an Apply returning function as its first argument and a function that is used to apply the \"effect\" of the target Apply to the value inside of the Either. This will be used in the case that the Either instance is a Left. Both arguments must provide an instance of the target Apply. Copy importEitherfrom'crocks/Either' importPairfrom'crocks/Pair' importStatefrom'crocks/State' importSumfrom'crocks/Sum' import constant from'crocks/combinators/constant' import ifElse from'crocks/logic/ifElse' import traverse from'crocks/pointfree/traverse' const{Left,Right}=Either const{get}=State // tallyOf :: Number -> Pair Sum Number consttallyOf= x=>Pair(Sum.empty(), x) // incBy :: Number -> Pair Sum Number constincBy= x=>Pair(Sum(x), x) Right(12) .traverse(tallyOf, incBy) //=> Pair( Sum 12, Right 12 ) Left(true) .traverse(tallyOf, incBy) //=> Pair( Sum 0, Left true ) // lte10 :: Number -> Either Number Number const lte10 = ifElse(x=> x <=10,Right,Left) // update :: Number -> State Number Number constupdate=x=> State.modify(state=> x + state) .chain(constant(get())) // updateSmall :: () => State Number Number constupdateSmall=()=> get(lte10) .chain(traverse(State, update)) updateSmall() .runWith(3) //=> Pair( Right 6, 6 ) updateSmall() .chain(updateSmall) .runWith(3) //=> Pair( Left 12, 12 ) updateSmall() .chain(updateSmall) .chain(updateSmall) .runWith(3) //=> Pair( Left 12, 12 ) updateSmall() .chain(updateSmall) .chain(updateSmall) .runWith(30) //=> Pair( Left 30, 30 ) runkit "},{"title":"chain","type":1,"pageTitle":"Either","url":"docs/crocks/Either#chain","content":"Copy Either c a ~> (a -> Either c b) -> Either c b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. chain expects a unary, Either returning function as its argument. When invoked on a Left, chain will not run the function, but will instead return another Left wrapping the original value. When called on a Right however, the inner value will be passed to the provided function, returning the result as the new instance. Copy importEitherfrom'crocks/Either' import getProp from'crocks/Maybe/getProp' import ifElse from'crocks/logic/ifElse' import isString from'crocks/predicates/isString' import maybeToEither from'crocks/Either/maybeToEither' import propEq from'crocks/predicates/propEq' const{Left,Right}=Either // lift :: (b -> Boolean) -> b -> Either c a constlift=pred=> ifElse(pred,Right,Left) // isPassed :: b -> Either c Object const isPassed = lift(propEq('passed',true)) isPassed({ value:'Nope'}) // Left { value: \"Nope\" } isPassed({ value:'yes', passed:true}) // Right { value: \"yes\", passed: true } // stringOr :: b -> Either c String const stringOr = lift(isString) // valueOr :: b -> Either c a constvalueOr=x=> maybeToEither(x,getProp('value'), x) // getStringValue :: b -> Either c String constgetStringValue=x=> isPassed(x) .chain(valueOr) .chain(stringOr) getStringValue({ value:'So good', passed:true }) //=> Right \"So Good\" getStringValue({ value:'Not passed' }) //=> Left { value: \"Not passed\" } getStringValue({ value:33, passed:true }) //=> Right \"So Good\" getStringValue({ value:33, passed:true }) //=> Left 33 runkit "},{"title":"coalesce","type":1,"pageTitle":"Either","url":"docs/crocks/Either#coalesce","content":"Copy Either c a ~> ((c -> b), (a -> b)) -> Either c b Used to take a Left instance and not only map its internal value, but also to \"promote\" it to a Right instance. coalesce takes two unary functions as its arguments and will return a new Right instance. The first function is used when invoked on a Left and will return a Right instance, wrapping the result of the function. The second function is used when coalesce is invoked on a Right and is used to map the original value, returning a new Right instance wrapping the result of the second function. Copy importEitherfrom'crocks/Either' import setProp from'crocks/helpers/setProp' import coalesce from'crocks/pointfree/coalesce' import compose from'crocks/helpers/compose' import identity from'crocks/combinators/identity' import hasProp from'crocks/predicates/hasProp' import ifElse from'crocks/logic/ifElse' import map from'crocks/pointfree/map' import mapProps from'crocks/helpers/mapProps' const{Left,Right}=Either // inc :: Number -> Number -> Number constinc= x=> x +1 Right(45) .coalesce(identity, inc) //=> Right 46 Left(45) .coalesce(identity, inc) //=> Right 45 // Record :: { value: Number } // hasValue :: Object -> Either Object Record const hasValue = ifElse(hasProp('value'),Right,Left) hasValue({ a:45}) // Left { a: 45 } hasValue({ value:45}) // Right { value: 45 } // defaultValue :: Either Object Record -> Either Object Record const defaultValue = coalesce(setProp('value',0), identity) // incValue :: Either Object Record -> Either c Record const incValue =compose( map(mapProps({ value: inc })), defaultValue, hasValue ) incValue({ value:45}) //=> Right { value: 46 } incValue({ a:44}) //=> Right { a: 44, value: 1 } runkit "},{"title":"bichain","type":1,"pageTitle":"Either","url":"docs/crocks/Either#bichain","content":"Copy Either c a ~> ((c -> Either d b), (a -> Either d b)) -> Either d b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. Along the same lines, bichain allows you to do this from both Left and Right. bichain expects two unary, Either returning functions as its arguments. When invoked on a Left instance, bichain will use the left, or first, function that can return either a Left or a Right instance. When called on a Right instance, it will behave exactly as chain would with the right, or second, function. Copy importEitherfrom'crocks/Either' import bichain from'crocks/pointfree/bichain' import compose from'crocks/helpers/compose' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import isString from'crocks/predicates/isString' import map from'crocks/pointfree/map' const{Left,Right}=Either // swapEither :: Either a b -> Either b a const swapEither = bichain(Right,Left) swapEither(Left('left')) //=> Right \"left\" swapEither(Right('right')) //=> Left \"right\" // length :: String -> Number constlength=x=> x.length // add10 :: Number -> Number constadd10=x=> x +10 // safe :: (a -> Boolean) -> a -> Either c b constsafe=pred=> ifElse(pred,Right,Left) // stringLength :: a -> Either e Number const stringLength =compose( map(length), safe(isString) ) // nested :: a -> Either c Number const nested =compose( map(add10), bichain(stringLength,Right), safe(isNumber) ) nested('cool') //=> Right 14 nested(true) //=> Left true nested(13) //=> Right 23 runkit "},{"title":"swap","type":1,"pageTitle":"Either","url":"docs/crocks/Either#swap","content":"Copy Either c a ~> ((c -> d), (a -> b)) -> Either b d Used to map the value of an Either instance and transform a Left into aRight or a Right into a Left, swap takes two functions as its arguments. The first function is used to map and transform a Left into a Right, while the second maps and transforms a Right into a Left. If no mapping of the contained values is required for either instance, then identity functions can be used in one or both arguments. Copy importEitherfrom'crocks/Either' import identity from'crocks/combinators/identity' import swap from'crocks/pointfree/swap' const{Left,Right}=Either // swapTypes :: Either c a -> Either a c const swapTypes = swap(identity, identity) swapTypes(Left(45)) //=> Right 45 swapTypes(Right(23)) //=> Left 23 // toString :: Number -> String consttoString= x=> x.toString() // toNumber :: String -> Number consttoNumber= x=>parseInt(x) // swapValues :: Either Number String -> Either Number String const swapValues = swap(toString, toNumber) swapValues(Left(23)) //=> Right \"23\" swapValues(Right('23')) //=> Left 23 runkit "},{"title":"either","type":1,"pageTitle":"Either","url":"docs/crocks/Either#either","content":"Copy Either c a ~> ((c -> b), (a -> b)) -> b Used as a means to map and extract a value from an Either based on the context, either takes two functions as its arguments. The first will map anyLeft value in a left instance. While the second is used to map any Rightinstance value. The function will return the result of whichever function is used to map. Copy importEitherfrom'crocks/Either' import curry from'crocks/helpers/curry' import either from'crocks/pointfree/either' import identity from'crocks/combinators/identity' import objOf from'crocks/helpers/objOf' const{Left,Right}=Either // toObject :: String -> Either a Object -> Object const toObject =curry( key=>either(objOf(key), identity) ) toObject('num',Left(44)) //=> { num: 44 } toObject('num',Right({ string:'a string'})) //=> { string: 'a string' } runkit "},{"title":"Transformation Functions","type":1,"pageTitle":"Either","url":"docs/crocks/Either#transformation-functions","content":""},{"title":"firstToEither","type":1,"pageTitle":"Either","url":"docs/crocks/Either#firsttoeither","content":"crocks/Either/firstToEither Copy firstToEither :: c -> First a -> Either c a firstToEither :: c -> (a -> First b) -> a -> Either c a Used to transform a given First instance to an Either instance or flatten an Either of First into an Either when chained, firstToEither will turn a non-empty instance into a Right wrapping the original value contained within the First. The First datatype is based on a Maybe and as such its is fixed to a () (unit) type. As a means to allow for convenient transformation, firstToEither takes a default Left value as the first argument. This value will be wrapped in a resulting Left instance in the case of empty. Like all crocks transformation functions, firstToEither has two possible signatures and will behave differently when passed either a First instance or a function that returns an instance of First. When passed the instance, a transformed Either is returned. When passed a First returning function, a function will be returned that takes a given value and returns a Either. Copy importEitherfrom'crocks/Either' importFirstfrom'crocks/First' import and from'crocks/logic/and' import firstToEither from'crocks/Either/firstToEither' import isNumber from'crocks/predicates/isNumber' import map from'crocks/pointfree/map' import mconcatMap from'crocks/helpers/mconcatMap' import safe from'crocks/Maybe/safe' const{Right}=Either // sorry :: First a -> Either String a const sorry = firstToEither('Sorry Charlie') sorry(First.empty()) //=> Left \"Sorry Charlie\" sorry(First('So Good')) //=> Right \"So Good\" // gte :: Number -> Number -> Boolean constgte= y=>x=> x >= y // isValid :: a -> Boolean const isValid = and(isNumber,gte(30)) // firstValid :: a -> First Number const firstValid = mconcatMap(First,safe(isValid)) // data :: [ * ] const data = [1,'200',60,300] Right(data) .chain(sorry(firstValid)) //=> Right 60 Right(data) .map(map(x=> x.toString())) .chain(sorry(firstValid)) //=> Left \"Sorry Charlie\" Right(First.empty()) .chain(firstToEither('Port')) //=> Left \"Port\" Right(First('Ship')) .chain(firstToEither('Port')) //=> Right \"Ship\" runkit "},{"title":"lastToEither","type":1,"pageTitle":"Either","url":"docs/crocks/Either#lasttoeither","content":"crocks/Either/lastToEither Copy lastToEither :: c -> Last a -> Either c a lastToEither :: c -> (a -> Last b) -> a -> Either c a Used to transform a given Last instance to an Either or flatten an Either of Last into an Either when chained, lastToEither will turn a non-empty Last instance into a Right instance wrapping the original value contained in the original non-empty. The Last datatype is based on a Maybe and as such its left or empty value is fixed to a () (unit) type. As a means to allow for convenient transformation, lastToEither takes a default Left value as the first argument. This value will be wrapped in a resulting Left instance, in the case of empty. Like all crocks transformation functions, lastToEither has two possible signatures and will behave differently when passed either a Last instance or a function that returns an instance of Last. When passed the instance, a transformed Either is returned. When passed a Last returning function, a function will be returned that takes a given value and returns an Either. Copy importEitherfrom'crocks/Either' importLastfrom'crocks/Last' import and from'crocks/logic/and' import compose from'crocks/helpers/compose' import concat from'crocks/pointfree/concat' import lastToEither from'crocks/Either/lastToEither' import isString from'crocks/predicates/isString' import map from'crocks/pointfree/map' import mconcatMap from'crocks/helpers/mconcatMap' import safe from'crocks/Maybe/safe' import when from'crocks/logic/when' const{Right}=Either // sorry :: Last a -> Either String a const sorry = lastToEither('Sorry Charlie') sorry(Last.empty()) //=> Left \"Sorry Charlie\" sorry(Last('So Good')) //=> Right \"So Good\" // lte :: Number -> Number -> Boolean constlte= y=>x=> x <= y // length :: String -> Number constlength= x=> x.length // isValid :: a -> Boolean const isValid = and(isString,compose(lte(3), length)) // lastValid :: a -> Last Number const lastValid = mconcatMap(Last,safe(isValid)) // data :: [ * ] const data = [1,'200',60,300] Right(data) .chain(sorry(lastValid)) //=> Right \"200\" Right(data) .map(map(when(isString,concat('!')))) .chain(sorry(lastValid)) //=> Left \"Sorry Charlie\" Right(Last.empty()) .chain(lastToEither('Port')) //=> Left \"Port\" Right(Last('Ship')) .chain(lastToEither('Port')) //=> Right \"Ship\" runkit "},{"title":"maybeToEither","type":1,"pageTitle":"Either","url":"docs/crocks/Either#maybetoeither","content":"crocks/Either/maybeToEither Copy maybeToEither :: c -> Maybe a -> Either c a maybeToEither :: c -> (a -> Maybe b) -> a -> Either c a Used to transform a given Maybe instance to an Either instance or flatten an Either of Maybe into an Either when chained, maybeToEither will turn a Just instance into a Right instance wrapping the original value contained in the original Just. A Nothing instance is fixed to a () type and as such can only ever contain a value of undefined. As a means to allow for convenient transformation, maybeToEither takes a default Left value as the first argument. This value will be wrapped in a resulting Left instance, in the case of Nothing. Like all crocks transformation functions, maybeToEither has two possible signatures and will behave differently when passed either a Maybe instance or a function that returns an instance of Maybe. When passed the instance, a transformed Either is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns an Either. Copy importEitherfrom'crocks/Either' importMaybefrom'crocks/Maybe' import compose from'crocks/helpers/compose' import fanout from'crocks/Pair/fanout' import identity from'crocks/combinators/identity' import isObject from'crocks/predicates/isObject' import maybeToEither from'crocks/Either/maybeToEither' import merge from'crocks/pointfree/merge' import safe from'crocks/Maybe/safe' const{Nothing,Just}=Maybe const{Right}=Either maybeToEither(false,Nothing()) //=> Left false maybeToEither(false,Just(true)) //=> Right true // isValid :: a -> Either b Object const isValid =compose( merge(maybeToEither), fanout(identity,safe(isObject)) ) Right('I am String') .chain(isValid) //=> Left \"I am String\" Right({ key:'value'}) .chain(isValid) //=> Right { key: \"value\" } Right(Nothing()) .chain(maybeToEither('Left')) //=> Left \"Left\" Right(Just('42')) .chain(maybeToEither('Left')) //=> Right \"42\" runkit "},{"title":"resultToEither","type":1,"pageTitle":"Either","url":"docs/crocks/Either#resulttoeither","content":"crocks/Either/resultToEither Copy resultToEither :: Result e a -> Either e a resultToEither :: (a -> Result e b) -> a -> Either e a Used to transform a given Result instance to an Either instance or flatten an Either of Result into an Either when chained, resultToEither will turn an Ok instance into a Right instance wrapping the value contained in the original Ok. If an Err is provided, then resultToEither will return a Left instance, wrapping the original Err value. Like all crocks transformation functions, resultToEither has two possible signatures and will behave differently when passed either a Result instance or a function that returns an instance of Result. When passed the instance, a transformed Either is returned. When passed a Result returning function, a function will be returned that takes a given value and returns an Either. Copy importEitherfrom'crocks/Either' importResultfrom'crocks/Result' import assign from'crocks/helpers/assign' import compose from'crocks/helpers/compose' import composeK from'crocks/helpers/composeK' import fanout from'crocks/Pair/fanout' import getProp from'crocks/Maybe/getProp' import isNumber from'crocks/predicates/isNumber' import liftA2 from'crocks/helpers/liftA2' import map from'crocks/pointfree/map' import maybeToResult from'crocks/Result/maybeToResult' import merge from'crocks/pointfree/merge' import objOf from'crocks/helpers/objOf' import resultToEither from'crocks/Either/resultToEither' import safeLift from'crocks/Maybe/safeLift' const{Right}=Either const{Err,Ok}=Result resultToEither(Err('no good')) //=> Left \"no good\" resultToEither(Ok('so good')) //=> Right \"so good\" // safeInc :: a -> Maybe Number const safeInc = safeLift(isNumber,x=> x +1) // incProp :: String -> a -> Maybe Number constincProp=key=> composeK(safeInc,getProp(key)) // incResult :: String -> a -> Result [ String ] Object constincResult=key=>maybeToResult( [`${key} is not valid`], compose(map(objOf(key)),incProp(key)) ) // incThem :: a -> Result [ String ] Object const incThem =compose( merge(liftA2(assign)), fanout(incResult('b'),incResult('a')) ) Either.of({}) .chain(resultToEither(incThem)) //=> Left [ \"b is not valid\", \"a is not valid\" ] Either.of({ a:33}) .chain(resultToEither(incThem)) //=> Left [ \"b is not valid\" ] Either.of({ a:99, b:'41'}) .chain(resultToEither(incThem)) //=> Left [ \"b is not valid\" ] Either.of({ a:99, b:41}) .chain(resultToEither(incThem)) //=> Right { a: 100, b: 42 } Right(Err('Left')) .chain(resultToEither) //=> Left \"Left\" Right(Ok('42')) .chain(resultToEither) //=> Right \"42\" runkit "},{"title":"Tuple","type":0,"sectionRef":"#","url":"docs/crocks/Tuple","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#implements","content":"Setoid, Semigroup, Functor "},{"title":"Construction","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#construction","content":"Copy Tuple :: Number -> n-Tuple *...n Tuple is a type constructor that takes a non-zero, positive Integer as its argument. Instead of an instance, it will return a constructor that is used to construct an n sized Tuple, where n is the number of independent values that can be represented. The resulting n-Tuple constructor is parameterized as an n-Functor, where each parameter can vary from instance to instance. Copy importTuplefrom'crocks/Tuple' // Triple :: 3-Tuple constTriple= Tuple(3) // Quad :: 4-Tuple constQuad= Tuple(4) Triple(false,true,45) //=> 3-Tuple (false, true, 45) Quad({ a:true},[1,2,3],60,'string') //=> 4-Tuple ({ a: true }, [ 1, 2, 3 ], 60, \"string\") runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#equals","content":"Copy n-Tuple *...n ~> a -> Boolean Used to compare the values of two n-Tuple instances by value.equals takes any given argument and will return a true if passed an n-Tuple of the same size with match values in the same positions as the n-Tupleequals was run on. If the provided argument is not an n-Tuple of the same type or the underlying values are not equal, then equals will return false. Copy importTuplefrom'crocks/Tuple' // Pair :: 2-Tuple constPair= Tuple(2) // Triple :: 3-Tuple constTriple= Tuple(3) Pair(1,false) .equals(Pair(1,false)) //=> true Triple(1,false,[1,2]) .equals(Triple(1,false,[1,2])) //=> true Triple(1,false,[1,2]) .equals(Triple(1,true,[3,4])) //=> false Pair(1,false) .equals(Triple(1,false,[1,2])) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#concat","content":"Copy Semigroup s1 => 1-Tuple s1 ~> 1-Tuple s1 -> 1-Tuple s1 Semigroup s1, s2 => 2-Tuple s1 s2 ~> 2-Tuple s1 s2 -> 2-Tuple s1 s2 ... Two instances of the same n-Tuple can be combined using concatenation, as long as both have instances of the same Semigroups in the same position. concat will be called on each contained Semigroup instance with the instance corresponding to the other n-Tuple instance. The result of each concatenation will be provided in a new n-Tuple instance. Copy importTuplefrom'crocks/Tuple' importSumfrom'crocks/Sum' // Triple :: 3-Tuple constTriple= Tuple(3) // Unary :: 1-Tuple constUnary= Tuple(1) Triple([1,3],Sum(10),Sum(1)) .concat(Triple([4],Sum.empty(),Sum(9))) //=> 3-Tuple( [ 1, 3, 4 ], Sum 10, Sum, 10 ) Unary([10]) .concat(Unary([10])) //=> 1-Tuple( [ 10, 10 ] ) runkit "},{"title":"map","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#map","content":"Copy 1-Tuple a ~> (a -> b) -> 1-Tuple b 2-Tuple a b ~> (b -> c) -> 2-Tuple a c ... Used to lift a single function into a given n-Tuple to map the rightmost value. map takes a function (a -> b) and will return a new n-Tuple instance with the result of mapping the rightmost value from its original a type to the resulting b. This method will only apply to the rightmost value. mapAll can be used to map over all values in a given n-Tuple. Copy importTuplefrom'crocks/Tuple' importMaybefrom'crocks/Maybe' import chain from'crocks/pointfree/chain' import getProp from'crocks/Maybe/getProp' const{Just}=Maybe // Pair :: 2-Tuple constPair= Tuple(2) Pair(false,Just({ a:'this is a'})) .map(chain(getProp('a'))) //=> 2-Tuple( false, Just \"this is a\" ) runkit "},{"title":"mapAll","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#mapall","content":"Copy 1-Tuple a ~> (a -> b) -> 1-Tuple b 2-Tuple a b ~> (a -> c) -> (b -> d) -> 2-Tuple c d ... While map allows for the rightmost portion of a given n-Tuple to be mapped, mapAll provides a means to map all values at once, independently of each other. A Tuple of n size requires n number of functions in the same left to right order as their respective values. mapAll returns a new n-Tuple of the same size containing the results of the provided mapping functions. Copy importTuplefrom'crocks/Tuple' import objOf from'crocks/helpers/objOf' // Triple :: 3-Tuple constTriple= Tuple(3) // toUpper :: String -> String consttoUpper= x=> x.toUpperCase() // negate :: a -> Boolean constnegate= x=>!x Triple('little',false,94) .mapAll(toUpper, negate,objOf('a')) //=> 3-Tuple( \"LITTLE\", true, { a: 94 } ) runkit "},{"title":"project","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#project","content":"Copy 1-Tuple a ~> Integer -> a 2-Tuple a b ~> Integer -> (a | b) 3-tuple a b c ~> Integer -> (a | b | c) ... Used to extract a specific value from a given n-Tuple. project takes a positive, non-zero Integer as its input and will return the extracted value residing in the provided 1 based index. Copy importTuplefrom'crocks/Tuple' // Pair :: 2-Tuple constPair= Tuple(2) // Triple :: 3-Tuple constTriple= Tuple(3) Triple('one','two','three') .project(1) //=> \"one\" Pair('one','two') .project(2) //=> \"two\" runkit "},{"title":"merge","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#merge","content":"Copy 1-Tuple a ~> (a -> b) -> b 2-Tuple a b ~> ((a, b) -> c) -> c 3-Tuple a b c ~> ((a, b, c) -> d) -> d ... Used to fold a given n-Tuple into a single value, merge accepts a function of any arity and will apply each value in the n-Tuple, in order, to the provided function. merge returns the result of the application. When using an n-Tuple to manage parallel processing, merge is used to combine the separate branches into a single result. Copy importTuplefrom'crocks/Tuple' import curry from'crocks/helpers/curry' // Triple :: 3-Tuple constTriple= Tuple(3) // buildObj :: (a, b, c) -> Object const buildObj =curry( (first, second, third)=> ({ first, second, third }) ) Triple(99,'name',[1,5,7]) .merge(buildObj) //=> { first: 99, second: \"name\", third: [ 1, 5, 7 ] } runkit "},{"title":"toArray","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#toarray","content":"Copy 1-Tuple a ~> () -> [ a ] 2-Tuple a b ~> () -> [ a + b ] 3-Tuple a b c ~> () -> [ a + b + c ] ... toArray is a Natural Transformation from a given n-Tuple to a JavaScript Array. Any arguments applied to toArray will be ignored and will return an Array of n size, where n corresponds to the size of the n-Tuple. Each value will be in the same left to right position as the order defined by the n-Tuple Copy importTuplefrom'crocks/Tuple' // Pair :: 2-Tuple constPair= Tuple(2) // Quad :: 4-Tuple constQuad= Tuple(4) Pair(false,{ a:false}) .toArray() //=> [ false, { a: false } ] Quad([1,3],[2,4],'name','Joe') .toArray() //=> [ [ 1, 3 ], [ 2, 4 ], \"name\", \"Joe\" ] runkit "},{"title":"Pointfree Functions","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#pointfree-functions","content":""},{"title":"nmap","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#nmap","content":"crocks/Tuple/nmap Copy nmap :: Integer -> ...(* -> *) -> m ...* -> m ...* nmap takes a non-zero, positive Integer as its argument and will return another function that takes the same number of unary functions as the provided Integer. After all functions are provided, the last argument needs to be an n-Tuple of the same size as the provided Integer. Copy importTuplefrom'crocks/Tuple' import nmap from'crocks/Tuple/nmap' // toUpper :: String -> String consttoUpper= x=> x.toUpperCase() // add :: Number -> Number -> Number constadd= x=>y=> x + y // Pair :: 2-Tuple a b constPair= Tuple(2) // Triple :: 3-Tuple a b c constTriple= Tuple(3) // bimap :: (a -> c) -> (b -> d) -> Pair a b -> Pair c d const bimap = nmap(2) // trimap :: (a -> d) -> (b -> e) -> (c -> f) -> Triple a b c -> Triple d e f const trimap = nmap(3) // pair :: Pair String Number const pair = Pair('jordan',13) bimap(toUpper,add(10), pair) //=> 2-Tuple( \"JORDAN\", 23 ) const triple = Triple(32,'string',0) trimap(add(10), toUpper,add(10), triple) //=> 3-Tuple( 42, \"STRING\", 10 ) runkit "},{"title":"project","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#project-1","content":"crocks/Tuple/project Copy project :: Integer -> m ...* -> a project takes a positive, non-zero Integer as its input and returns another function that accepts an n-Tuple. It then returns the value from the n-Tuple that resides at the provided Integer index. Copy importTuplefrom'crocks/Tuple' import project from'crocks/Tuple/project' // Triple :: 3-Tuple constTriple=Tuple(3)('one','two','three') // getFirst :: Number -> a const getFirst =project(1) // getSecond :: Number -> a const getSecond =project(2) getFirst(Triple) //=> \"one\" getSecond(Triple) //=> \"two\" runkit "},{"title":"Transformation Functions","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#transformation-functions","content":""},{"title":"tupleToArray","type":1,"pageTitle":"Tuple","url":"docs/crocks/Tuple#tupletoarray","content":"crocks/Tuple/tupleToArray Copy tupleToArray :: Tuple a -> [ a ] tupleToArray :: (a -> Tuple b) -> a -> [ b ] Used to transform a given Tuple instance to an Array instance. Like all crocks transformation functions, tupleToArray has two possible signatures and will behave differently when passed either a Tuple instance or a function that returns an instance of Tuple. When passed the instance, a transformed Array is returned. When passed a Tuple returning function, a function will be returned that takes a given value and returns an Array. Copy importTuplefrom'crocks/Tuple' import tupleToArray from'crocks/Tuple/tupleToArray' import constant from'crocks/combinators/constant' constTriple=Tuple(3) const triple =Triple(1,{ key:'value'},'string') tupleToArray(triple) //=> [ 1, { key: 'value' }, 'string' ] tupleToArray(constant(triple))() //=> [ 1, { key: 'value' }, 'string' ] runkit "},{"title":"Pair","type":0,"sectionRef":"#","url":"docs/crocks/Pair","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#implements","content":"Setoid, Semigroup, Functor, Bifunctor, Apply, Chain,Traversable, Extend "},{"title":"Construction","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#construction","content":"Copy Pair :: (a, b) -> Pair a b In order to construct a Pair, two values of any type are required by the constructor. The types of the arguments can, and often do, vary. None of the constructors in crocks are curried by default, so both arguments must be provided at the same time in order to construct the Pair. Once both arguments are provided, the constructor will return a new Pair instance with the first argument in the left portion and the second argument in the right position. Copy importPairfrom'crocks/Pair' Pair(34,false) //=> Pair Number Boolean Pair(34,Pair(true,'string')) //=> Pair Number (Pair Boolean String) runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#equals","content":"Copy Pair a b ~> c -> Boolean Used to compare the underlying values of two Pair instances for equality by value. equals takes any given argument and returns true if the passed arguments is a Pair with an underlying values both in the first and second are equal to the underlying values in the first and second of the Maybe the method is being called on. If the passed argument is not a Maybe or the underlying values are not equal, equals will return false. Copy importPairfrom'crocks/Pair' import equals from'crocks/pointfree/equals' Pair({ num:33},'string') .equals(Pair({ num:33},'string')) //=> true Pair({ num:33},'string') .equals(Pair({ num:10},'string')) //=> false Pair({ num:33},'string') .equals(Pair({ num:33},'different')) //=> false equals(Pair([1,2],''),[1,2]) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#concat","content":"Copy Semigroup s, t => Pair s t ~> Pair s t -> Pair s t When both underlying values of a given Pair are fixed to a Semigroup, concat can be used to concatenate another Pair instance with underlying Semigroups of the same type and structure. Expecting a Maybe wrapping a Semigroup of the same type, concat will give back a new Pair instancewrapping the result of combining the underlying Semigroup instances. Copy importPairfrom'crocks/Pair' importMaybefrom'crocks/Maybe' importSumfrom'crocks/Sum' import compose from'crocks/helpers/compose' import concat from'crocks/pointfree/concat' import fanout from'crocks/Pair/fanout' import flip from'crocks/combinators/flip' import getProp from'crocks/Maybe/getProp' import map from'crocks/pointfree/map' import mapReduce from'crocks/helpers/mapReduce' import option from'crocks/pointfree/option' Pair(Sum(3),[3]) .concat(Pair(Sum(10),[10])) //=> Pair( Sum 13, [ 3, 10 ] ) // Person :: { name: String, age: Number } // peeps :: [ Person ] const peeps =[ { name:'Haskell', age:82}, { name:'Heinrich', age:81}, { name:'Maria', age:93} ] // mapProp :: (String, (a -> b)) -> Object -> Maybe b constmapProp=(key, fn)=> compose(map(fn),getProp(key)) // Combined :: Pair (Maybe [ String ]) (Maybe Sum) // splitPerson :: Person -> Combined const splitPerson =fanout( mapProp('name',x=>[ x ]), mapProp('age',Sum) ) // empty :: Combined const empty = Pair(Maybe([]),Maybe(Sum.empty())) // combine :: [ Person ] -> Combined const combine =mapReduce( splitPerson, flip(concat), empty ) combine(peeps) .bimap(option([]),option(Sum(0))) //=> Pair( [ \"Haskell\", \"Heinrich\", \"Maria\" ], Sum 256 ) runkit "},{"title":"map","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#map","content":"Copy Pair c a ~> (a -> b) -> Pair c b Used to apply transformations to values to the second portion of a given Pair instance. map takes a function that it will lift into the context of the Pair and apply to it second value in the Pair, returning a new Pair instance. The new instance will contain the result of mapping in the second, leaving the value in the first untouched. If you need to map the first value, bimap can be used instead. Copy importPairfrom'crocks/Pair' import compose from'crocks/helpers/compose' import map from'crocks/pointfree/map' import merge from'crocks/pointfree/merge' import objOf from'crocks/helpers/objOf' // length :: String -> Number constlength= x=> x.length // add10 :: Number -> Number constadd10= x=> x +10 // keyedLength :: Pair String String -> Object const keyedLength = compose(merge(objOf),map(length)) Pair('number',32) .map(add10) //=> Pair(\"number\", 42) keyedLength( Pair('text','This is some text') ) //=> { text: 17 } runkit "},{"title":"bimap","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#bimap","content":"Copy Pair a b ~> ((a -> c), (b -> d)) -> Pair c d The types and values that make up a Pair can vary independently in both the first and second portions of the Pair. While map can be used to apply these transformations, bimap allows for independent transformations on both sides, in parallel. bimap takes two mapping functions as its arguments. The first function is used to map the first, while the second maps the second. Pair only provides a means to map the second's value exclusively using map. If the need arises to map the first portion exclusively, use bimap passing the mapping function to the first argument and an identity to the second. Copy importPairfrom'crocks/Pair' importSumfrom'crocks/Sum' import compose from'crocks/helpers/compose' import bimap from'crocks/pointfree/bimap' import branch from'crocks/Pair/branch' import identity from'crocks/combinators/identity' import merge from'crocks/pointfree/merge' import mreduce from'crocks/helpers/mreduce' // add10 :: Number -> Number constadd10= x=> x +10 // divide :: (Number, Number) -> Number constdivide= (x, y)=> x / y // length :: [ Number ] -> Number constlength= x=> x.length // average :: [ Number ] -> Number const average =compose( merge(divide), bimap(mreduce(Sum), length), branch ) Pair(35,'number') .bimap(add10, identity) //=> Pair( 45, 'number' ) average([2,3,4]) //=> 3 runkit "},{"title":"ap","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#ap","content":"Copy Semigroup s => Pair s (a -> b) ~> Pair s a -> Pair s b Short for apply, ap is used to apply a Pair instance containing a value on its second portion to another Pair instance that contains a function in its second portion. The result of this application provides a new Pair instance containing the result in the second portion. ap requires that it is called on an instance that wraps a curried polyadic function in the second. An additional constraint when using ap is that the Pair must contain a Semigroup instance in its first. This is required for both the Pair with the function and the Pair with the value to be applied. With both Semigroups being of the same type. Copy importPairfrom'crocks/Pair' import liftA2 from'crocks/helpers/liftA2' // add :: Number -> Number -> Number constadd= x=>y=> x + y // NumberRec :: Pair [ Number ] Number // twentyThree :: NumberRec const twentyThree = Pair([23],23) // seventySeven :: NumberRec const seventySeven = Pair([77],77) // combine :: NumberRec -> NumberRec -> NumberRec const combine = liftA2(add) twentyThree .map(add) .ap(seventySeven) // Pair( [ 23, 77 ], 100 ) combine(twentyThree, seventySeven) // Pair( [ 23, 77 ], 100 ) runkit "},{"title":"chain","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#chain","content":"Copy Semigroup s => Pair s a ~> (a -> Pair s b) -> Pair s b Combining a sequential series of transformations that allows for custom accumulation in addition to transforming a value. chain requires a Pair returning function that contains a Semigroup in its first position. As anadditional requirement, is that instances of the same Semigroup must occupy the first position of the source Pair and the Pair returned by the function. Copy constPair=require('crocks/Pair') const setProp =require('crocks/helpers/setProp') const omit =require('crocks/helpers/omit') // addTmp :: (String, a, Object) -> Pair [ String ] Object constaddTmp=(key, value, x)=> Pair([ key ],setProp(key, value, x)) // add :: Object -> Pair [ String ] Object constadd=data=>{ const{ a, b }= data returnaddTmp('sum', a + b, data) } // multiply :: Object -> Pair [ String ] Object constmultiply=data=>{ const{ a, b }= data returnaddTmp('product', a * b, data) } // calc :: Object -> Object constcalc=data=>{ const{ product, sum }= data returnsetProp('result', product - sum, data) } // flow :: Object -> Object constflow=x=> Pair([], x) .chain(add) .chain(multiply) .map(calc) .merge(omit) flow({ a:34, b:76}) //=> { a: 34, b: 76, result: 2474 } flow({ a:10, b:5}) //=> { a: 10, b: 5, result: 35 } runkit "},{"title":"sequence","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#sequence","content":"Copy Apply f => Pair a (f b) ~> (c -> f c) -> f (Pair a b) Applicative f => Pair a (f b) ~> TypeRep f -> f (Pair a b) When an instance of Pair wraps an Apply instance in its second position, sequence can be used to swap the type sequence. sequence requires either an Applicative TypeRep or an Apply returning function is provided for its argument. While it is not a requirement that the first position be occupied by a Semigroup, in having an instance there sequencing back on a data structure with multiple items can allow for accumulation then sequencing back. sequence can be derived from traverse by passing it anidentity function (x => x). Copy importPairfrom'crocks/Pair' importSumfrom'crocks/Sum' import bimap from'crocks/pointfree/bimap' import compose from'crocks/helpers/compose' import concat from'crocks/pointfree/concat' import flip from'crocks/combinators/flip' import mapReduce from'crocks/helpers/mapReduce' import sequence from'crocks/pointfree/sequence' // pair :: Pair Number [ String ] const pair = Pair(1,['a','b','c']) // empty :: () -> Pair Sum String constempty= ()=>Pair(Sum.empty(),'') // seqArray :: Traversable t => t [ a ] -> [ t a ] const seqArray = sequence(Array) // toUpper :: String -> String consttoUpper= x=> x.toUpperCase() // combine :: [ Pair Number String ] -> Pair Sum String const combine =mapReduce( bimap(Sum, toUpper), flip(concat), empty() ) // flow :: Pair Number [ String ] -> Pair Sum String const flow = compose(combine, seqArray) seqArray(pair) //=> [ Pair(1, \"a\"), Pair(1, \"b\"), Pair(1, \"c\") ] flow(pair) //=> Pair(Sum 3, \"ABC\") runkit "},{"title":"traverse","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#traverse","content":"Copy Apply f => Pair a b ~> ((d -> f d), (b -> f c)) -> f (Pair a c) Applicative f => Pair a b ~> (TypeRep f, (b -> f c)) -> f (Pair a c) Used to apply the \"effect\" of an Apply to a value in the second position of a Pair, traverse combines both the \"effects\" of the Apply and the Pair by returning a new instance of the Apply, wrapping the result of the Applys \"effect\" on the value in the second position of the Pair. The traverse method requires either an Applicative TypeRep or an Apply returning function as its first argument and a function that is used to apply the \"effect\" of the target Apply to the value in the second position of the Pair. The \"effect\" will only be applied to second value and leaves the first value untouched. Both arguments must return an instance of the target Apply. Copy importMaybefrom'crocks/Maybe' importPairfrom'crocks/Pair' import identity from'crocks/combinators/identity' import safe from'crocks/Maybe/safe' import traverse from'crocks/pointfree/traverse' const{Just,Nothing}=Maybe // isOdd :: Integer -> Boolean constisOdd= x=>!!(x %2) // safeOdd :: Traversable t => t Integer -> Maybe (t Integer) const safeOdd = traverse(Maybe,safe(isOdd)) // seqMaybe :: Traversable t => t (Maybe a) -> Maybe (t a) const seqMaybe = traverse(Maybe.of, identity) // odd :: Pair [ Number ] Integer const odd = Pair([10],23) // even :: Pair String Integer const even = Pair('nope',42) safeOdd(odd) //=> Just Pair( [ 10 ], 23 ) safeOdd(even) //=> Nothing seqMaybe(Pair(true,Just('good'))) //=> Just Pair( true, \"good\" ) seqMaybe(Pair(false,Nothing())) //=> Nothing runkit "},{"title":"extend","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#extend","content":"Copy Pair a b ~> (Pair a b -> c) -> Pair a c Used map the second position of a given Pair instance by taking the entire Pair into consideration. extend takes a function the receives a Pair as its input and returns a new Pair with the result of that function in the second position, while leaving the value in the first position untouched. Copy importPairfrom'crocks/Pair' import extend from'crocks/pointfree/extend' import merge from'crocks/pointfree/merge' import objOf from'crocks/helpers/objOf' // name :: Pair String String const name = Pair('name','Thomas') // mergeObj :: Pair String a -> Object const mergeObj = merge(objOf) // makeObj :: Pair String a -> Pair String Object const makeObj = extend(mergeObj) makeObj(name) //=> Pair(\"name\", { name: \"Thomas\" }) runkit "},{"title":"swap","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#swap","content":"Copy Pair a b ~> ((a -> c), (b -> d)) -> Pair d c Used to map the value of a Pairs first position into the second position and the second position into the first, swap takes two functions as its arguments. The first function is used to map the value in the first position to the second, while the second maps the second into the first. If no mapping is required on either side, then identity functions can be used in one or both arguments. Copy importPairfrom'crocks/Pair' import identity from'crocks/combinators/identity' import swap from'crocks/pointfree/swap' // toString :: a -> String consttoString= x=> x.toString() // swapMap :: Pair a String -> Pair Number String const swapMap = swap(toString, parseInt) // m :: Pair Number String const m = Pair(76,'105') m.swap(identity, identity) //=> Pair(\"105\", 76) swapMap(m) //=> Pair(105, \"76\") runkit "},{"title":"fst","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#fst","content":"Copy Pair a b ~> () -> a fst is one of two projection methods used to extract the values contained in a given Pair instance. fst takes nothing as its input and will unwrap and provide the value in the first position, throwing away the value in the second.snd is the other projection function provided and is used to extract the value in the second position. Copy importPairfrom'crocks/Pair' Pair('left','right') .fst() //=> \"left\" runkit "},{"title":"snd","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#snd","content":"Copy Pair a b ~> () -> b snd is one of two projection methods used to extract the values contained in a given Pair instance. snd takes nothing as its input and will unwrap and provide the value in the second position, throwing away the value in the first.fst is the other projection function provided and is used to extract the value in the first position. Copy importPairfrom'crocks/Pair' Pair('left','right') .snd() //=> \"right\" runkit "},{"title":"toArray","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#toarray","content":"Copy Pair a b ~> () -> [ a, b ] While both fst and snd can be used to extract specific values out of the structure of Pair, toArray extracts values but maintains the structure. Taking nothing as its input, toArray will return an Array of two values. The first value in the Pair will occupy the [0] index, while the [1] index will house the second. Copy importPairfrom'crocks/Pair' import compose from'crocks/helpers/compose' // toArray :: Pair a b -> [ a, b ] consttoArray= x=> x.toArray() // toObject :: [ a, b ] -> Object consttoObject= ([ left, right ])=>({ left, right }) // pairToObject :: Pair a b -> Object const pairToObject = compose(toObject, toArray) // m :: Pair String Number const m = Pair('a',1) m.toArray() //=> [ 'a', 1 ] pairToObject(m) //=> { left: 'a', right: 1 } runkit "},{"title":"merge","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#merge","content":"Copy Pair a b ~> ((a, b) -> c) -> c Acting as a means to fold a given Pair over a binary operation, merge takes a binary function as its sole argument. Using the function, merge will unwrap each of its values and apply them to the function in order from first to second. The result of the provided function is then provided as the overall result for merge. This method comes in handy when using a Pair as a means to run parallel computations and combine their results into a final answer. Typically this method works hand in hand with the either the branch or [fanout][fanout] helper functions. Copy importSumfrom'crocks/Sum' import compose from'crocks/helpers/compose' import fanout from'crocks/Pair/fanout' import merge from'crocks/pointfree/merge' import mreduce from'crocks/helpers/mreduce' // length :: [ a ] -> Integer constlength= x=> x.length // divide :: (Number, Number) -> Number constdivide= (x, y)=> x / y // average :: [ Number ] -> Number const average =compose( merge(divide), fanout(mreduce(Sum), length) ) // nums :: [ Number ] const nums = [23,96,90,4,21] average(nums) // 46.8 runkit "},{"title":"Helper Functions","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#helper-functions","content":""},{"title":"branch","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#branch","content":"crocks/Pair/branch Copy branch :: a -> Pair a a Typically the starting point for handling parallel computations on a single value, branch takes a single value of any type as its only argument. branch then returns a Pair with the reference or value in both the first and second positions. Using branch can simplify how computations that depend on the same value are constructed and encoded by removing the need to keep the original value in some state that needs to be passed from function to function. Copy import assign from'crocks/helpers/assign' import bimap from'crocks/pointfree/bimap' import branch from'crocks/Pair/branch' import compose from'crocks/helpers/compose' import curry from'crocks/helpers/curry' import objOf from'crocks/helpers/objOf' import merge from'crocks/pointfree/merge' // add10 :: Number -> Number constadd10= x=> x +10 // applyChange :: (a -> b) -> a -> Object constapplyChange=fn=> compose(objOf('current'), fn) // createUndo :: (a -> b) -> a -> Object const createUndo =curry(fn=> compose( merge(assign), bimap(objOf('orig'),applyChange(fn)), branch ) ) // applyAdd10 :: Number -> Object const applyAdd10 = createUndo(add10) applyAdd10(5) // { current: 15, orig: 5 } runkit "},{"title":"fanout","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#fanout","content":"crocks/Pair/fanout Copy fanout :: (a -> b) -> (a -> c) -> (a -> Pair b c) fanout :: Arrow a b -> Arrow a c -> Arrow a (Pair b c) fanout :: Monad m => Star a (m b) -> Star a (m c) -> Star a (m (Pair b c)) There are may times that you need to keep some running or persistent state while performing a given computation. A common way to do this is to take the input to the computation and branch it into a Pair and perform different operations on each version of the input. This is such a common pattern that it warrants the fanout function to take care of the initial split and mapping. Just provide a pair of either simple functions or a pair of one of the computation types (Arrow or Star). You will get back something of the same type that is configured to split it's input into a pair and than apply the first Function/ADT to the first portion of the underlying Pair and the second on the second. Copy import compose from'crocks/helpers/compose' import fanout from'crocks/Pair/fanout' import getProp from'crocks/Maybe/getProp' import liftA2 from'crocks/helpers/liftA2' import map from'crocks/pointfree/map' importMaybefrom'crocks/Maybe' import merge from'crocks/pointfree/merge' import sequence from'crocks/pointfree/sequence' // Person :: { first: String, last: String } // people :: [Person] const people =[ { first:'Ziggy', last:'Stardust'}, { first:'Lizard', last:'King'} ] // concat :: String -> String -> String constconcat=a=>b=>`${a}${b}` // join :: String -> [a] -> String constjoin=sep=>arr=> arr.join(sep) // getName :: Person -> String const getName =compose( merge(liftA2(concat)), fanout(getProp('first'),getProp('last')) ) // getPersons :: [Person] -> String const getPersons =compose( map(join(', ')), sequence(Maybe), map(getName) ) getPersons(people) //=> Just \"Ziggy Stardust, Lizard King\" runkit "},{"title":"toPairs","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#topairs","content":"crocks/Pair/toPairs Copy toPairs :: Object -> List (Pair String a) When dealing with Objects, sometimes it makes more sense to work in a Foldable structure like a List of key-value Pairs. toPairs provides a means to take an object and give you back a List of Pairs that have a String that represents the key in the fst and the value for that key in the snd. The primitive values are copied, while non-primitive values are references. Like most of the Object functions in crocks, any keys with undefined values will be omitted from the result. crocks provides an inverse to this function named fromPairs. Copy import compose from'crocks/helpers/compose' import map from'crocks/pointfree/map' import merge from'crocks/pointfree/merge' import toPairs from'crocks/Pair/toPairs' // record :: Object const record ={ firstName:'Joey', lastName:'Fella', age:34 } // joinField :: (String, a) -> String constjoinField=(key, value)=> `${key}:${value}` // joinRecord :: List String -> String constjoinRecord=list=> list.toArray() .join('|') // buildRecord :: Object -> String const buildRecord =compose( joinRecord, map(merge(joinField)), toPairs ) buildRecord(record) //=> \"firstName:Joey|lastName:Fella|age:34\" runkit "},{"title":"Pointfree Functions","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#pointfree-functions","content":""},{"title":"fst (pointfree)","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#fst-pointfree","content":"crocks/Pair/fst Copy fst :: Pair a b -> a The fst pointfree function is used extract the leftmost value of a Pair by invoking the fst method on a given instance, returning the result.fst takes a Pair as its only argument and returns the value wrapped in the leftmost portion of the provided Pair. Copy importPairfrom'crocks/Pair' import flip from'crocks/combinators/flip' import fst from'crocks/Pair/fst' import ifElse from'crocks/logic/ifElse' import merge from'crocks/pointfree/merge' import snd from'crocks/Pair/snd' // lte :: (Number, Number) -> Boolean constlte= (y, x)=> x <= y // min :: Pair Number Number -> Number const min =ifElse( merge(flip(lte)), fst, snd ) min(Pair(1,2)) //=> 1 min(Pair(45,22)) //=> 22 min(Pair(100,100)) //=> 100 runkit "},{"title":"snd (pointfree)","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#snd-pointfree","content":"crocks/Pair/snd Copy snd :: Pair a b -> b The snd pointfree function is used extract the rightmost value of a Pair by invoking the snd method on a given instance, returning the result.snd takes a Pair as its only argument and returns the value wrapped in the rightmost portion of the provided Pair. Copy importPairfrom'crocks/Pair' importUnitfrom'crocks/Unit' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import map from'crocks/pointfree/map' import snd from'crocks/Pair/snd' // Box :: a -> Pair () a constBox= x=>Pair(Unit(), x) // unbox :: Pair a b -> b const unbox = snd // add :: Number -> Number -> Number constadd= x=>y=> x + y // doubleBoxed :: Number -> Pair () Number constdoubleBoxed= m=>Box(m *2) // flow :: Number -> Number const flow =compose( unbox, chain(doubleBoxed), map(add(10)), Box ) flow(10) //=> 40 runkit "},{"title":"Transformation Functions","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#transformation-functions","content":""},{"title":"writerToPair","type":1,"pageTitle":"Pair","url":"docs/crocks/Pair#writertopair","content":"crocks/Pair/writerToPair Copy writerToPair :: Monoid m => Writer m a -> Pair m a writerToPair :: Monoid m => (a -> Writer m b) -> a -> Pair m b Used to transform a Writer instance to a Pair instance or flatten a Pair of Writer into an Pair when chained, writerToPair will take a given Writer and provide a new Pair with the log portion of the Writer in the first position and the resultant in the second. Like all crocks transformation functions, writerToPair has two possible signatures and will behave differently when passed either a Writer instance or a function that returns an instance of Writer. When passed the instance, a Pair instance is returned. When passed a Writer returning function, a function will be returned that takes a given value and returns an Pair. Copy importPairfrom'crocks/Pair' importSumfrom'crocks/Sum' importWriterfrom'crocks/Writer' import fanout from'crocks/helpers/fanout' import writerToPair from'crocks/Pair/writerToPair' // SumWriter :: Writer Sum a constSumWriter= Writer(Sum) // appendItem :: a -> [ a ] -> SumWriter [ a ] constappendItem=item=>xs=> SumWriter(1, xs.concat([ item ])) SumWriter(0,[]) .chain(appendItem('one')) .chain(appendItem('two')) .chain(appendItem('three')) //=> Writer (Sum 3) [ \"one\", \"two\", \"three\" ] writerToPair(SumWriter(2,'result')) //=> Pair(Sum 2, 'result') Pair(Sum.empty(),[]) .chain(writerToPair(appendItem('one'))) .chain(writerToPair(appendItem('two'))) .chain(writerToPair(appendItem('three'))) //=> Pair(Sum 3, [ \"one\", \"two\", \"three\"]) fanout(Sum,x=>appendItem(x)([ x ]),1) .chain(writerToPair) runkit "},{"title":"State","type":0,"sectionRef":"#","url":"docs/crocks/State","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"State","url":"docs/crocks/State#implements","content":"Functor, Apply, Chain, Applicative, Monad "},{"title":"Construction","type":1,"pageTitle":"State","url":"docs/crocks/State#construction","content":"Copy State :: (s -> Pair a s) -> State s a Typically instances of State are constructed using the provided construction helpers like get or put. While the provided helpers fit most situations, there are times where a State instance will need to be constructed \"by-hand\". An instance of State can be constructed by passing a unary function that takes some type s as its input and returns a Pair with any type a in the first position and the same type s in second. While there is nothing that prevents the type s from varying, it is recommended to fix the type to a single type for all State instances that are used in a given flow. Copy importPairfrom'crocks/Pair' importStatefrom'crocks/State' State(state=>Pair(state, state)) //=> State s s // increaseBy :: Number -> State Number Number constincreaseBy=value=> State(state=>Pair(value, state +1)) increaseBy(5) //=> State Number Number runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"State","url":"docs/crocks/State#constructor-methods","content":""},{"title":"get","type":1,"pageTitle":"State","url":"docs/crocks/State#get","content":"Copy State.get :: () -> State s s State.get :: (s -> a) -> State s a A construction helper that is used to access the state portion of a given State instance. To make the state accessible, get will place the state in the resultant portion, overwriting what was there previously. get may be called with or without a function as its argument. When nothing is provided for the argument, the state will be applied to the resultant as is. The state will be mapped over any provided function that takes the same type as the state, with the result deposited in the resultant. Copy importStatefrom'crocks/State' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import getProp from'crocks/Maybe/getProp' import isNumber from'crocks/predicates/isNumber' import option from'crocks/pointfree/option' import safe from'crocks/Maybe/safe' const{get}=State // propOr :: (String, (b -> Boolean), a) -> Object -> c constpropOr=(key, pred, def)=> compose(option(def),chain(safe(pred)),getProp(key)) // safeNumber :: Object -> Number const safeNumber = propOr('number', isNumber,0) get(safeNumber) .runWith({ number:23}) //=> Pair(23, { number: 23 }) get(safeNumber) .evalWith({ number:'23'}) //=> 0 get() .map(safeNumber) .evalWith({ number:23}) //=> 23 get() .map(safeNumber) .runWith({ string:'47'}) //=> Pair(0, { string: '47'}) runkit "},{"title":"modify","type":1,"pageTitle":"State","url":"docs/crocks/State#modify","content":"Copy State.modify :: (s -> s) -> State s () A construction helper that can be used to lift an endo-function that matches the fixed type of the state portion. The lifted function will receive the state and returns a new State instance with the result of the function in the state portion. Great care should be taken to not use functions that will change the type of the state as it may not be expected in other stateful computations and can result in hard to track down bugs. Copy importStatefrom'crocks/State' import mapProps from'crocks/helpers/mapProps' const{ modify }=State // add :: Number -> Number -> Number constadd= x=>y=> x + y // addState :: Number -> State Number () constaddState=x=> modify(add(x)) // addValue :: Number -> State Object () constaddValue=x=> modify(mapProps({ value:add(x)})) addState(5) .execWith(45) //=> 50 addValue(5) .execWith({ value:45}) //=> { value: 50 } addValue(5) .execWith({}) //=> {} runkit "},{"title":"put","type":1,"pageTitle":"State","url":"docs/crocks/State#put","content":"Copy State.put :: s -> State s () Used to replace the state portion of a given State instance,, put can be employed anytime that the state can change without having to know about it's previous value. If the previous value is required for a given stateful computation, modify can be used to lift a function that represents the change. As put updates the state, it is important to ensure that the state portion stays fixed for all related functions. Changing the type of the state portion may result in hard to debug bugs and destroys the relationship between stateful computations. Copy importStatefrom'crocks/State' import compose from'crocks/helpers/compose' import isString from'crocks/predicates/isString' import option from'crocks/pointfree/option' import safe from'crocks/Maybe/safe' const{ put }=State // safeString :: a -> String const safeString = compose(option(''),safe(isString)) // reset :: () -> State String () constreset=()=> put('') // update :: a -> State String () const update = compose(put, safeString) // heckYeah :: State String () const heckYeah = update('Oh Heck Yeah') heckYeah .execWith('Gosh') //=> 'Oh Heck Yeah' heckYeah .chain(reset) .runWith('Gosh') // Pair((), '') runkit "},{"title":"of","type":1,"pageTitle":"State","url":"docs/crocks/State#of","content":"Copy State.of :: a -> State s a Used to \"blindly\" lift any JavaScript value into a State, of will take the provided value and return back a new State instance with the value in the resultant. There are many uses for of, but mostly it is used to set the resultant in the same way put is used to replace the state. Many times of is used at the start of a given stateful computation or in conjunction with put and modify to replace the Unit the resultant is set to for those construction helpers. Copy importStatefrom'crocks/State' const{get, put }=State // updatePop :: String -> State String String constupdatePop=x=> get().chain( old=>put(x).chain( ()=>State.of(old) ) ) State.of('hotness') .chain(updatePop) .runWith('crusty') //=> Pair('crusty', 'hotness') runkit "},{"title":"Instance Methods","type":1,"pageTitle":"State","url":"docs/crocks/State#instance-methods","content":""},{"title":"map","type":1,"pageTitle":"State","url":"docs/crocks/State#map","content":"Copy State s a ~> (a -> b) -> State s b While the state portion s of State must remain fixed to a type, the resultant a can vary in it's type as needed. This allows complex stateful computations to be represented with State. The map method provides a means to lift a function into the datatype that will be applied to the resultant and return a new instance of State with the result of the function as the new resultant. While this is similar to the modify construction helper, which lifts an endo-function that acts upon the state, map does not require an endo-function as it can move to any type. Due to the composition law associated with map, successive maps can be composed together using function composition. This will give the same results but will only map the value once, instead of once for every mapping. Copy importStatefrom'crocks/State' import compose from'crocks/helpers/compose' import objOf from'crocks/helpers/objOf' import getPropOr from'crocks/helpers/getPropOr' const{get}=State // add :: Number -> Number -> Number constadd= x=>y=> x + y // getNum :: State Object Number const getNum = get(getPropOr(0,'num')) getNum .map(add(10)) .evalWith({ num:32}) //=> 42 getNum .map(add(10)) .map(objOf('result')) .evalWith({ val:32}) //=> { result: 10 } // comp :: Number -> Object const comp =compose( objOf('result'), add(10) ) getNum .map(comp) .evalWith({ num:32}) //=> { result: 42 } runkit "},{"title":"ap","type":1,"pageTitle":"State","url":"docs/crocks/State#ap","content":"Copy State s (a -> b) ~> State s a -> State s b Short for apply, the ap method is used to apply the resultant of a given State instance to a function wrapped in another instance. On a State instance that wraps a function, calling ap, providing it another State instance, will return a new State instance with the result of the function in the resultant portion. When used with curried, polyadic functions, multiple stateful computations can be combined using the lifted function as a means to combine each of the instances' resultants. Copy importStatefrom'crocks/State' import setProp from'crocks/helpers/setProp' import getPropOr from'crocks/helpers/getPropOr' const{get, modify }=State const data ={ tax:.084, sub:34.97 } // add :: Number -> Number -> Number constadd= x=>y=> x + y // multiply :: Number -> Number -> Number constmultiply= x=>y=> x * y // round :: Number -> Number constround= x=>Math.round(x *100)/100 // getKey :: String -> State Object Number constgetKey=key=> get(getPropOr(0, key)) // updateKey :: String -> a -> State Object () constupdateKey=key=>val=> modify(setProp(key, val)) // addToSub :: Number -> String Object Number constaddToSub=x=> getKey('sub') .map(add(x)) const calcTax = getKey('tax') .map(multiply) .ap(getKey('sub')) // applyTax :: State Object () const applyTax = calcTax .chain(addToSub) .map(round) .chain(updateKey('total')) applyTax .execWith(data) //=> { tax: 0.084, sub: 34.07, total: 37.91 } runkit "},{"title":"chain","type":1,"pageTitle":"State","url":"docs/crocks/State#chain","content":"Copy State s a ~> (a -> State s b) -> State s b As a means to combine stateful computations, chain is used to sequence state transactions that either read from or write to the state. chain takes a unary function that must return a new State instance. chain returns a new State instance that will apply the computation when run. Copy importStatefrom'crocks/State' const{get, modify }=State // add :: Number -> State Number () constadd=x=> modify(y=> x + y) // multiply :: Number -> State Number () constmultiply=x=> modify(y=> x * y) // double :: () -> State Number () constdouble=()=> get() .chain(add) // square :: () -> State Number () constsquare=()=> get() .chain(multiply) add(10) .execWith(10) //=> 20 add(10) .chain(double) .execWith(10) //=> 40 add(10) .chain(square) .execWith(10) //=> 400 add(10) .chain(double) .chain(square) .execWith(10) //=> 1600 runkit "},{"title":"runWith","type":1,"pageTitle":"State","url":"docs/crocks/State#runwith","content":"Copy State s a ~> s -> Pair a s State is a lazy datatype that requires a value for it's state portion to be run. A given State instance provides a runWith method that accepts a value to run the instance with. The value must be a member of the type that the given State instance is fixed to in it's state portion, s. When called, runWith will run the state transition with the given value as the initial state and will return the resulting Pair with the resultant in the fst (first) and the state in the snd (second). Copy importStatefrom'crocks/State' importKfrom'crocks/combinators/constant' const{get, put }=State // swap :: s -> s -> State s s constswap=x=>old=> put(x) .chain(K(State.of(old))) //update :: s -> State s s constupdate=x=> get() .chain(swap(x)) update(45) .runWith(100) //=> Pair(100, 45) runkit "},{"title":"evalWith","type":1,"pageTitle":"State","url":"docs/crocks/State#evalwith","content":"Copy State s a ~> s -> a State is a lazy datatype that requires a value for it's state portion to be run. A given State instance provides an evalWith method that accepts a value to run the instance with. The value must be a member of the type that the given State instance is fixed to in its state portion, s. When called, evalWith will run the state transition with the given value as the initial state and will return the resulting resultant discarding the state portion. Copy importStatefrom'crocks/State' import concat from'crocks/pointfree/concat' import flip from'crocks/combinators/flip' import liftA2 from'crocks/helpers/liftA2' import map from'crocks/pointfree/map' import getPropOr from'crocks/helpers/getPropOr' const{get}=State const name ={ first:'Franklin', last:'Jennings' } // getLast :: State Object String const getFirst = get(getPropOr('','first')) // getLast :: State Object String const getLast = get(getPropOr('','last')) // inner :: Functor f => f a -> f [ a ] const inner = map(Array.of) // combineNames :: State Object [ String ] const combineNames =liftA2( flip(concat), inner(getFirst), inner(getLast) ) combineNames .evalWith(name) //=> [ 'Franklin', 'Jennings' ] runkit "},{"title":"execWith","type":1,"pageTitle":"State","url":"docs/crocks/State#execwith","content":"Copy State s a ~> s -> s State is a lazy datatype that requires a value for it's state portion to be run. A given State instance provides an execWith method that accepts a value to run the instance with. The value must be a member of the type that the given State instance is fixed to in it's state portion, s. When called, execWith will run the state transition with the given value as the initial state and will return the resulting state, discarding the resultant portion. Copy importStatefrom'crocks/State' import compose from'crocks/helpers/compose' import concat from'crocks/pointfree/concat' const{ modify }=State // toUpper :: String -> String consttoUpper= x=> x.toUpperCase() // exclaim :: String -> String const exclaim = concat('!!!') // yell :: State String () const yell =modify( compose(exclaim, toUpper) ) yell .execWith('nice') //=> 'NICE!!!' runkit "},{"title":"Pointfree Functions","type":1,"pageTitle":"State","url":"docs/crocks/State#pointfree-functions","content":""},{"title":"evalWith (pointfree)","type":1,"pageTitle":"State","url":"docs/crocks/State#evalwith-pointfree","content":"crocks/State/evalWith Copy evalWith :: s -> State s a -> a The evalWith pointfree function can be employed to execute theevalWith method on a given State instance. This function is typically used at the edge of a program where all the side-effects typically reside. As all this function does is return the result of applying a given initial state to the evalWith method to the provided State instance, it will also return the resulting resultant, throwing away the resulting state. Copy importStatefrom'crocks/State' import evalWith from'crocks/State/evalWith' import compose from'crocks/helpers/compose' import curry from'crocks/helpers/curry' import flip from'crocks/combinators/flip' const{get}=State // addToState :: Number -> State Number Number constaddToState= x=>get(y=> x + y) // add :: Number -> Number -> Number const add =curry( compose(flip(evalWith), addToState) ) // add10 :: Number -> Number const add10 = add(10) add10(32) //=> 42 add(1295,42) // 1337 runkit "},{"title":"execWith (pointfree)","type":1,"pageTitle":"State","url":"docs/crocks/State#execwith-pointfree","content":"crocks/State/execWith Copy execWith :: s -> State s a -> s The execWith pointfree function can be employed to execute theexecWith method on a given State instance. This function is typically used at the edge of a program where all the side-effects typically reside. As all this function does is return the result of applying a given initial state to the execWith method to the provided State instance, it will also return the resulting state, throwing away the resulting resultant. Copy importStatefrom'crocks/State' import execWith from'crocks/State/execWith' import curry from'crocks/helpers/curry' import isSameType from'crocks/predicates/isSameType' import mapProps from'crocks/helpers/mapProps' import when from'crocks/logic/when' const{ modify }=State // middleware :: Object -> State Object | Object -> Object const middleware =curry( s=>when(isSameType(State),execWith(s)) ) // incValue :: State Object () const incValue = modify(mapProps({value:x=> x +1})) middleware({ value:10}, incValue) //=> { value: 11 } middleware({ value:10},{ value:32}) //=> { value: 32 } runkit "},{"title":"Predicate Functions","type":0,"sectionRef":"#","url":"docs/functions/predicate-functions","content":"All functions in this group have a signature of * -> Boolean and are used with the many predicate based functions that ship with crocks, like safe, ifElse and filter to name a few. They also fit naturally with the Pred ADT. All predicate functions can be referenced from crocks/predicates. Below is a list of all the current predicates that are included with a description of their truth: hasProp :: (String | Integer) -> a -> Boolean: an Array or Object that contains the provided index or keyhasProps :: Foldable f => f (String | Integer) -> a -> Boolean: an Array or Object that contains the provided indexs or keyshasPropPath :: [ String | Integer ] -> a -> Boolean: an Array or Object that contains the provided index pathisAlt :: a -> Boolean: an ADT that provides map and alt methodsisAlternative :: a -> Boolean: an ADT that provides alt, zero, map, ap, chain and ofmethodsisApplicative :: a -> Boolean: an ADT that provides map, ap and of methodsisApply :: a -> Boolean: an ADT that provides map and ap methodsisArray :: a -> Boolean: ArrayisBifunctor :: a -> Boolean: an ADT that provides map and bimap methodsisBoolean :: a -> Boolean: BooleanisCategory :: a -> Boolean: an ADT that provides id and compose methodsisChain :: a -> Boolean: an ADT that provides map, ap and chain methodsisContravariant :: a -> Boolean: an ADT that provides contramap methodisDate :: a -> Boolean: DateisDefined :: a -> Boolean: Every value that is not undefined, null includedisEmpty :: a -> Boolean: Empty Monoid, Object, Array, String, undefined, null, all Numbers and Boolean valuesisExtend :: a -> Boolean: an ADT that provides map and extend methodsisFalse :: a -> Boolean: a value that is strictly equal to falseisFalsy :: a -> Boolean: a value that is considered to be falsyisFoldable :: a -> Boolean: Array, List or any structure with a reduce methodisFunction :: a -> Boolean: FunctionisFunctor :: a -> Boolean: an ADT that provides a map methodisInteger :: a -> Boolean: IntegerisIterable :: a -> Boolean: an Object with an iterator methodisMap :: a -> Boolean: MapisMonad :: a -> Boolean: an ADT that provides map, ap, chain and of methodsisMonoid :: a -> Boolean: an ADT that provides concat and empty methodsisNil :: a -> Boolean: undefined or null or NaNisNumber :: a -> Boolean: Number that is not a NaN value, Infinity includedisObject :: a -> Boolean: Plain Old JavaScript Object (POJO)isPlus :: a -> Boolean: an ADT that provides map, alt and zero methodsisProfunctor :: a -> Boolean: an ADT that provides map, contramap and promap methodsisPromise :: a -> Boolean: an object implementing then and catchisSame :: a -> b -> Boolean: same value or reference, use equals for value equalityisSameType :: a -> b -> Boolean: Constructor matches a values type, or two values types matchisSemigroup :: a -> Boolean: an ADT that provides a concat methodisSemigroupoid :: a -> Boolean: an ADT that provides a compose methodisSetoid :: a -> Boolean: an ADT that provides an equals methodisString :: a -> Boolean: StringisSymbol :: a -> Boolean: SymbolisTraversable :: a -> Boolean: an ADT that provides map and traverse methodsisTrue :: a -> Boolean: a value that is strictly equal to trueisTruthy :: a -> Boolean: a value that is considered to be truthypathEq :: [ String | Integer ] -> a -> Object -> Boolean: an Object that contains the provided key in the traversal path, with a value equal to the provided value. (equality by value)pathSatisfies :: [ String | Integer ] -> ((a -> Boolean) | Pred) -> Object -> Boolean: an Object that contains the provided key in the traversal path with a value that passes the provided predicate.propEq :: (String | Integer) -> a -> Object -> Boolean: an Object that contains the provided key with a value equal to the provided value. (equality by value)propSatisfies :: (String | Integer) -> ((a -> Boolean) | Pred) -> Object -> Boolean: an Object that contains the provided key with a value that passes the provided predicate.","keywords":""},{"title":"Combinators","type":0,"sectionRef":"#","url":"docs/functions/combinators","content":"","keywords":""},{"title":"applyTo","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#applyto","content":"crocks/combinators/applyTo Copy applyTo :: a -> (a -> b) -> b Ever run into a situation where you have a value but do not have a function to apply it to? Well this little bird, named Thrush, is there to help out. Just give it a value and it will give you back a function ready to take a function. Once that function is provided, it will return the result of applying your value to that function. Copy import applyTo from'crocks/combinators/applyTo' importFirstfrom'crocks/First' importPairfrom'crocks/Pair' import compose from'crocks/helpers/compose' import flip from'crocks/combinators/flip' import isArray from'crocks/predicates/isArray' import isNumber from'crocks/predicates/isNumber' import isString from'crocks/predicates/isString' import map from'crocks/pointfree/map' import merge from'crocks/pointfree/merge' import mreduceMap from'crocks/helpers/mreduceMap' import safeLift from'crocks/Maybe/safeLift' // prices :: [ Number ] const prices =[4.99,29.99,15.99] // getPrices :: (a -> b) -> [ Number ] const getPrices =compose( applyTo(prices), map ) // discount :: Number -> Number -> Number constdiscount=percent=>price=> Number((price - percent /100* price).toFixed(2)) getPrices(discount(10)) //=> [ 4.49, 26.99, 14.39 ] getPrices(discount(80)) //=> [ 1, 6, 3.2 ] // add :: Number -> Number -> Number constadd=x=>y=> x + y // runAll :: [ (a -> b) ] -> a -> [ b ] const runAll = flip(compose(map, applyTo)) runAll([add(10),add(20)],3) //=> [ 13, 23 ] // length :: [ a ] -> Number constlength=x=> x.length // yell :: String -> String constyell=x=> x.toUpperCase() // Strategy :: Pair (a -> Boolean) (* -> *) // strategies :: [ Strategy ] const strategies =[ Pair(isNumber,add(10)), Pair(isArray, length), Pair(isString, yell) ] // options :: [ Strategy ] -> a -> b const options =flip( x=>mreduceMap( First, compose(applyTo(x),merge(safeLift)) ) ) options(strategies,'hello') //=> Just \"HELLO\" options(strategies,[1,9,39]) //=> Just 3 options(strategies,13) //=> Just 23 options(strategies,null) //=> Nothing runkit "},{"title":"compose2","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#compose2","content":"crocks/combinators/compose2 Copy compose2 :: (c -> d -> e) -> (a -> c) -> (b -> d) -> a -> b -> e compose2 allows for composition between a binary function and two unary functions. compose2 takes a binary function followed by two unary functions and returns a binary function that maps the first argument with the first unary and the second with the second, passing the results to the given binary and returning the result. Copy import compose2 from'crocks/combinators/compose2' import and from'crocks/logic/and' import applyTo from'crocks/combinators/applyTo' import flip from'crocks/combinators/flip' import hasProp from'crocks/predicates/hasProp' import isNumber from'crocks/predicates/isNumber' import liftA2 from'crocks/helpers/liftA2' import map from'crocks/pointfree/map' import prop from'crocks/Maybe/prop' import safe from'crocks/Maybe/safe' import safeLift from'crocks/Maybe/safeLift' // isNonZero :: Number -> Boolean constisNonZero=x=> x !==0 // isValidDivisor :: Number -> Boolean const isValidDivisor = and(isNumber, isNonZero) // divideBy :: Number -> Number -> Number constdivideBy=x=>y=> y / x // safeDivide :: Number -> Number -> Maybe Number const safeDivide =compose2( liftA2(divideBy), safe(isValidDivisor), safe(isNumber) ) safeDivide(0.5,21) //=> Just 42 safeDivide('0.5',21) //=> Nothing safeDivide(0.5,'21') //=> Nothing safeDivide(29,0) //=> Just 0 safeDivide(0,29) //=> Nothing // Item :: { id: Integer } // Items :: Array Item const items = [{ id:2},{ id:1}] // pluck :: String -> Array Object -> Maybe a const pluck = compose2(applyTo, prop,flip(map)) pluck('id', items) //=> [ Just 2, Just 1 ] // summarize :: String -> String -> String constsummarize=name=>count=> `${name} purchased ${count} items` // getLength :: a -> Maybe Number const getLength =safeLift( hasProp('length'), x=> x.length ) // createSummary :: Person -> Array Item -> String const createSummary =compose2( liftA2(summarize), prop('name'), getLength ) createSummary({ name:'Sam Smith' }, items) //=> Just \"Sam Smith purchased 2 items\" // capitalize :: String -> String constcapitalize=str=> `${str.charAt(0).toUpperCase()}${str.slice(1)}` // join :: String -> String -> String -> String constjoin=delim=>right=>left=> `${left}${delim}${right}` // toUpper :: String -> String consttoUpper=x=> x.toUpperCase() // createName :: String -> String -> String const createName = compose2(join(', '), capitalize, toUpper) createName('Jon','doe') //=> DOE, Jon createName('sara','smith') //=> SMITH, Sara runkit "},{"title":"composeB","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#composeb","content":"crocks/combinators/composeB Copy composeB :: (b -> c) -> (a -> b) -> a -> c Provides a means to describe a composition between two functions. it takes two functions and a value. Given composeB(f, g), which is read f after g, it will return a function that will take value a and apply it to g, passing the result as an argument to f, and will finally return the result of f. This allows only two functions, if you want to avoid things like:composeB(composeB(f, g), composeB(h, i)) then check out compose. Copy import composeB from'crocks/combinators/composeB' importEitherfrom'crocks/Either' import ifElse from'crocks/logic/ifElse' import isString from'crocks/predicates/isString' const{Left,Right}=Either // yell :: String -> String constyell=x=> `${x.toUpperCase()}!` // safeYell :: a -> Either a String const safeYell =ifElse( isString, composeB(Right, yell), Left ) safeYell('quite') //=> Right \"QUITE!\" safeYell(42) //=> Left 42 runkit "},{"title":"constant","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#constant","content":"crocks/combinators/constant Copy constant :: a -> () -> a This is a very handy dandy function, used a lot. Pass it any value and it will give you back a function that will return that same value no matter what you pass it.constant is perfect for those moments where you need to pass a function but do not care about the input. constant will swallow any value given to it and always return the initial value it was given. It is important to note that any function that is passed into constant will get the added benefit of having curry applied to it. Copy import constant from'crocks/combinators/constant' importResultfrom'crocks/Result' import bimap from'crocks/pointfree/bimap' import composeB from'crocks/combinators/composeB' import ifElse from'crocks/logic/ifElse' import isString from'crocks/predicates/isString' import getPropOr from'crocks/helpers/getPropOr' const{Ok,Err}=Result // whatsTheAnswer :: () -> Number const whatsTheAnswer = constant(42) whatsTheAnswer('to life?') //=> 42 whatsTheAnswer('to the universe?') //=> 42 whatsTheAnswer('to everything?') //=> 42 // ensure :: (a -> Boolean) -> a -> Result a constensure=pred=> ifElse(pred,Ok,Err) // getLength :: Result a String -> Result Number const getLength =bimap( constant(0),getPropOr(0,'length') ) // getLengthOfString :: a -> Result a String const getLengthOfString =composeB( getLength, ensure(isString) ) getLengthOfString('testing') //=> Ok 7 getLengthOfString(42) //=> Err 0 getLengthOfString([1,2,3,4]) //=> Err 0 runkit "},{"title":"converge","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#converge","content":"crocks/combinators/converge Copy converge :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d Provides a means of passing an acculumating function and two branching functions. A value can be applied to the resulting function which will then be applied to each branching function, the results of which will be applied to the accumulating function. Copy import converge from'crocks/combinators/converge' import alt from'crocks/pointfree/alt' import getProp from'crocks/Maybe/getProp' import liftA2 from'crocks/helpers/liftA2' import getPropOr from'crocks/helpers/getPropOr' // data :: [ Number ] const data =[1,2,3,4,5] // divide :: Number -> Number -> Number constdivide=x=>y=> y / x // add :: (Number, Number) -> Number constadd=(a, b)=> b + a // sum :: [ Number ] -> Number constsum=xs=> xs.reduce(add,0) // length :: [ a ] -> Number const length = getPropOr(0,'length') // average :: [ Number ] -> Number const average = converge(divide, length, sum) average(data) //=> 3 // maybeGetDisplay :: a -> Maybe b const maybeGetDisplay = getProp('display') // maybeGetFirst :: a -> Maybe b const maybeGetFirst = getProp('first') // maybeGetLast :: a -> Maybe b const maybeGetLast = getProp('last') // buildFullName :: String -> String -> String constbuildFullName=surname=>firstname=> `${firstname}${surname}` // maybeConcatStrings :: Maybe String -> Maybe String -> Maybe String constmaybeBuildFullName=a=>b=> liftA2(buildFullName, a, b) .alt(a) .alt(b) // maybeMakeDisplay :: a -> Maybe String const maybeMakeDisplay =converge( maybeBuildFullName, maybeGetLast, maybeGetFirst ) // maybeGetName :: a -> Maybe b const maybeGetName = converge(alt, maybeMakeDisplay, maybeGetDisplay) maybeGetName({ display:'Jack Sparrow'}) //=> Just \"Jack Sparrow\" maybeGetName({ first:'J', last:'S'}) //=> Just \"J S\" maybeGetName({ display:'Jack Sparrow', first:'J', last:'S'}) //=> Just \"Jack Sparrow\" maybeGetName({ first:'J'}) //=> Just \"J\" maybeGetName({ first:'S'}) //=> Just \"S\" runkit "},{"title":"flip","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#flip","content":"crocks/combinators/flip Copy flip :: (a -> b -> c) -> b -> a -> c This little function just takes a function and returns a function that takes the first two parameters in reverse. flip is perfectly suited for those moments where you have the context of your function but not the data. Applying flip to the function will allow you to pass in your context and will return a function waiting for the data. This will happen often when you're using composition. When required, one can compose flip calls down the line to flip all, or some of the other parameters if there are more than two. Mix and match to your heart's desire. Copy import flip from'crocks/combinators/flip' importPredfrom'crocks/Pred' import composeB from'crocks/combinators/composeB' import concat from'crocks/pointfree/concat' import isNumber from'crocks/predicates/isNumber' import mconcat from'crocks/helpers/mconcat' import runWith from'crocks/pointfree/runWith' concat('first param. ','second param. ') //=> \"second param. first param. \"\" flip(concat,'first param. ','second param. ') //=> \"first param. second param. \"\" // checkAll :: [ a -> Boolean ] -> a -> Boolean const checkAll = composeB(flip(runWith),mconcat(Pred)) // lte :: Number -> Number -> Boolean constlte=a=>b=> b <= a // gte :: Number -> Number -> Boolean constgte=a=>b=> b >= a // between2and10 :: a -> Boolean const between2and10 =checkAll([ isNumber, gte(2), lte(10) ]) between2and10(8) //=> true between2and10(11) //=> false between2and10(1) //=> false between2and10('not a number') //=> false runkit "},{"title":"identity","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#identity","content":"crocks/combinators/identity Copy identity :: a -> a This function and constant are the workhorses of writing code with this library. It quite simply is just a function that when you pass it something, it returns that thing right back to you. So simple, I will leave it as an exercise to reason about why this is so powerful and important. "},{"title":"psi","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#psi","content":"crocks/combinators/psi Copy psi :: (b -> b -> c) -> (a -> b) -> a -> a -> c psi is a function that can be considered the sister of converge. Where converge takes one argument and maps it through two unary functions, merging the resulting values with a binary function, psi takes two arguments and runs them each through the same unary function before merging them with the given binary function. psi is often used to compose equality checking functions or when needing to validate two arguments of the same type. Copy import psi from'crocks/combinators/psi' import and from'crocks/logic/and' import equals from'crocks/pointfree/equals' import isNumber from'crocks/predicates/isNumber' import liftA2 from'crocks/helpers/liftA2' import safe from'crocks/Maybe/safe' // isNonZero :: Number -> Boolean constisNonZero=x=> x !==0 // isValidDivisor :: Number -> Boolean const isValidDivisor = and(isNumber, isNonZero) // divideBy :: Number -> Number -> Number constdivideBy=x=>y=> y / x // safeDivide :: Number -> Number -> Maybe Number const safeDivide = psi(liftA2(divideBy),safe(isValidDivisor)) safeDivide(0.5,21) //=> Just 42 safeDivide('0.5',21) //=> Nothing safeDivide(0.5,'21') //=> Nothing safeDivide(29,0) //=> Nothing // capitalize :: String -> String constcapitalize=str=> `${str.charAt(0).toUpperCase()}${str.slice(1)}` // join :: String -> String -> String -> String constjoin=delim=>right=>left=> `${left}${delim}${right}` // createName :: String -> String -> String const createName = psi(join(', '), capitalize) createName('Jon','doe') //=> Doe, Jon createName('sara','smith') //=> Smith, Sara // toLowerCase :: String -> String consttoLowerCase=str=> str.toLowerCase() // equalsIgnoreCase :: String -> String -> Boolean const equalsIgnoreCase = psi(equals, toLowerCase) equalsIgnoreCase('test','TEst') //=> true equalsIgnoreCase('test','not-test') //=> false runkit "},{"title":"substitution","type":1,"pageTitle":"Combinators","url":"docs/functions/combinators#substitution","content":"crocks/combinators/substitution Copy substitution :: (a -> b -> c) -> (a -> b) -> a -> c While it may seem like a complicated little bugger, substitution can come in very handy from time to time. substitution is used when you have a binary function and you can supply the first argument and can use that value to create the second argument. It first takes a binary function followed by a unary function for it's first two arguments. This will return a function that is ready to take some context, a. Once supplied the fun starts, it will pass the given a to the binary and unary functions, and will then apply the result of the unary function as the second parameter of the binary function. Finally after all that juggling, it will return the result of that binary function. When used with partial application on that first parameter, a whole new world of combinatory madness is presented! Copy import substitution from'crocks/combinators/substitution' import composeB from'crocks/combinators/composeB' import curry from'crocks/core/curry' // getDetails :: String -> Number -> String const getDetails =curry((text, length)=> `The given text \"${text}\" has a length of ${length}` ) // getLength :: a -> Number constgetLength=s=> s.length substitution(getDetails, getLength,'testing') //=> \"The given text \\\"testing\\\" has a length of 7\" // getLastIndex :: a -> Number const getLastIndex =composeB( x=> x -1, getLength ) // slice :: Array -> Number -> Array const slice =curry((arr, index)=> arr.slice(index)) substitution(slice, getLastIndex,[1,2,3,4,5]) //=> [ 5 ] runkit "},{"title":"Point-free Functions","type":0,"sectionRef":"#","url":"docs/functions/pointfree-functions","content":"While it can seem natural to work with all these containers in a fluent fashion, it can get cumbersome and hard to get a lot of reuse out of. A way to really get the most out of re-usability in JavaScript is to take what is called a point-free approach. Below is a small code same to contrast the difference between the two calling styles: Copy import map from'crocks/pointfree/map' import compose from'crocks/helpers/compose' import isInteger from'crocks/predicates/isInteger' import safe from'crocks/Maybe/safe' // isEven :: Integer -> Boolean constisEven=x=> x %2===0 // maybeInt :: a -> Maybe Integer const maybeInt = safe(isInteger) // fluentIsEven :: a -> Maybe Boolean constfluentIsEven=data=> maybeInt(data) .map(isEven) // pointfreeIsEven :: a -> Maybe Boolean const pointfreeIsEven = compose(map(isEven), maybeInt) fluentIsEven(5) //=> Just false fluentIsEven('number') //=> Nothing fluentIsEven(6) //=> Just true pointfreeIsEven(5) //=> Just false pointfreeIsEven('not even') //=> Nothing pointfreeIsEven(6) //=> Just true runkit These functions provide a very clean way to build out very simple functions and compose them all together to compose a more complicated flow. Each point-free function provided in crocks is \"auto-curried\" and follows a \"data-last\" pattern in the order of how it receives it's arguments. Typically the most stable of the arguments comes first, moving all the way to the least stable argument (which usually is the data flowing through your composition). Below lists the provided functions and the data types they work with (m refers to an accepted Datatype): Signatures# Function\tSignature\tLocationalt\tm a -> m a -> m a\tcrocks/pointfree ap\tm a -> m (a -> b) -> m b\tcrocks/pointfree bichain\t(a -> m c d) -> (b -> m c d) -> m a b -> m c d\tcrocks/pointfree bimap\t(a -> c) -> (b -> d) -> m a b -> m c d\tcrocks/pointfree both\tm (a -> b) -> m (Pair a a -> Pair b b)\tcrocks/pointfree chain\t(a -> m b) -> m a -> m b\tcrocks/pointfree coalesce\t(a -> c) -> (b -> c) -> m a b -> m _ c\tcrocks/pointfree compareWith\ta -> a -> m a -> b\tcrocks/pointfree concat\tm a -> m a -> m a\tcrocks/pointfree cons\ta -> m a -> m a\tcrocks/pointfree contramap\t(b -> a) -> m a -> m b\tcrocks/pointfree either\t(a -> c) -> (b -> c) -> m a b -> c\tcrocks/pointfree empty\tm -> m\tcrocks/pointfree equals\tm -> m -> Boolean\tcrocks/pointfree evalWith\ts -> m -> a\tcrocks/State execWith\ts -> m -> s\tcrocks/State extend\t(m a -> b) -> m a -> m b\tcrocks/pointfree filter\t((a -> Boolean) | Pred a) -> m a -> m a\tcrocks/pointfree first\tm (a -> b) -> m (Pair a c -> Pair b c)\tcrocks/pointfree fold\tSemigroup s => m s -> s\tcrocks/pointfree foldMap\tSemigroup s => (a -> s) -> m a -> s\tcrocks/pointfree fst\tm a b -> a\tcrocks/Pair head\tm a -> Maybe a\tcrocks/pointfree init\tm a -> Maybe (m a)\tcrocks/pointfree last\tm a -> Maybe a\tcrocks/pointfree log\tm a b -> a\tcrocks/Writer map\t(a -> b) -> m a -> m b\tcrocks/pointfree merge\t(a -> b -> c) -> m a b -> c\tcrocks/pointfree nmap\tInteger -> ...(* -> *) m ...* -> m ...*\tcrocks/Tuple option\ta -> m a -> a\tcrocks/pointfree project\tInteger -> m ...* -> a\tcrocks/Tuple promap\t(c -> a) -> (b -> d) -> m a b -> m c d\tcrocks/pointfree race\tm e a -> m e a -> m e a\tcrocks/Async read\tm a b -> Pair a b\tcrocks/Writer reduce\t(b -> a -> b) -> b -> m a -> b\tcrocks/pointfree reduceRight\t(b -> a -> b) -> b -> m a -> b\tcrocks/pointfree reject\t((a -> Boolean) | Pred a) -> m a -> m a\tcrocks/pointfree run\tm a -> b\tcrocks/pointfree runWith\ta -> m -> b\tcrocks/pointfree second\tm (a -> b) -> m (Pair c a -> Pair c b)\tcrocks/pointfree sequence\tApplicative TypeRep t, Apply f => (t | (b -> f b)) -> m (f a) -> f (m a)\tcrocks/pointfree snd\tm a b -> b\tcrocks/Pair swap\t(c -> d) -> (a -> b) -> m c a -> m b d\tcrocks/pointfree tail\tm a -> Maybe (m a)\tcrocks/pointfree traverse\tApplicative TypeRep t, Apply f => (t | (c -> f c)) -> (a -> f b) -> m (f a) -> f (m b)\tcrocks/pointfree valueOf\tm a -> a\tcrocks/pointfree Datatypes# Function\tDatatypesalt\tAsync, Either, Maybe, Result ap\tArray, Async, Const, Either, Identity, IO, List, Maybe, Pair, Reader, Result, State, Unit, Writer bichain\tAsync, Either, Maybe, Result bimap\tAsync, Either, Pair, Result both\tArrow, Function, Star chain\tArray, Async, Const, Either, Identity, IO, List, Maybe, Pair, Reader, Result, State, Unit, Writer coalesce\tAsync, Either, Maybe, Result compareWith\tEquiv concat\tAll, Any, Array, Assign, Const, Either, Endo, Equiv, First, Identity, Last, List, Max, Maybe, Min, Pair, Pred, Prod, Result, String, Sum, Tuple, Unit cons\tArray, List contramap\tArrow, Equiv, Pred, Star either\tEither, Maybe, Result empty\tAll, Any, Array, Assign, Endo, Equiv, First, Last, List, Max, Min, Object, Pred, Prod, String, Sum, Unit equals\tAll, Any, Array, Assign, Boolean, Const, Either, First, Last, List, Max, Maybe, Min, Number, Object, Pair, Prod, Result, String, Sum, Tuple, Unit, Writer evalWith\tState execWith\tState extend\tPair filter\tArray, List, Object first\tArrow, Function, Star fold\tArray, List foldMap\tArray, List fst\tPair head\tArray, List, String init\tArray, List, String last\tArray, List, String log\tWriter map\tAsync, Array, Arrow, Const, Either, Function, Identity, IO, List, Maybe, Object, Pair, Reader, Result, Star, State, Tuple, Unit, Writer merge\tPair, Tuple option\tFirst, Last, Maybe promap\tArrow, Star race\tAsync read\tWriter reduce\tArray, List reduceRight\tArray, List reject\tArray, List, Object run\tIO runWith\tArrow, Endo, Pred, Reader, Star, State second\tArrow, Function, Star sequence\tArray, Either, Identity, List, Maybe, Pair, Result snd\tPair swap\tAsync, Either, Pair, Result tail\tArray, List, String traverse\tArray, Either, Identity, List, Maybe, Pair, Result valueOf\tAll, Any, Assign, Const, Endo, Equiv, First, Identity, Last, Max, Min, Pred, Prod, Sum, Unit, Writer","keywords":""},{"title":"Monoids","type":0,"sectionRef":"#","url":"docs/monoids/","content":"Each Monoid provides a means to represent a binary operation and is usually locked down to a specific type. These are great when you need to combine a list of values down to one value. In this library, any ADT that provides both an empty and a concat function can be used as a Monoid. There are a few of the crocks that are also monoidial, so be on the look out for those as well. All Monoids work with the following helper functionsmconcat, mreduce, mconcatMap and mreduceMap. All Monoids provide empty functions on their Constructors as well as the following Instance Functions: valueOf, empty and concat. Monoid\tType\tOperation\tEmpty (Identity)All\tBoolean\tLogical AND\ttrue Any\tBoolean\tLogical OR\tfalse Assign\tObject\tObject.assign\t{lb}{rb} Endo\tFunction\tcompose\tidentity First\tMaybe\tFirstJust\tNothing Last\tMaybe\tLastJust\tNothing Max\tNumber\tMath.max\t-Infinity Min\tNumber\tMath.min\tInfinity Prod\tNumber\tMultiplication\t1 Sum\tNumber\tAddition\t0","keywords":""},{"title":"Transformation Functions","type":0,"sectionRef":"#","url":"docs/functions/transformation-functions","content":"","keywords":""},{"title":"Transformation Signatures","type":1,"pageTitle":"Transformation Functions","url":"docs/functions/transformation-functions#transformation-signatures","content":"Transform\tADT signature\tFunction Signature\tLocationarrayToList\t[ a ] -> List a\t(a -> [ b ]) -> a -> List b\tcrocks/List asyncToPromise\tAsync e a -> Promise a e\t(a -> Async e b) -> a -> Promise b e\tcrocks/Async eitherToAsync\tEither e a -> Async e a\t(a -> Either e b) -> a -> Async e b\tcrocks/Async eitherToFirst\tEither b a -> First a\t(a -> Either c b) -> a -> First b\tcrocks/First eitherToLast\tEither b a -> Last a\t(a -> Either c b) -> a -> Last b\tcrocks/Last eitherToMaybe\tEither b a -> Maybe a\t(a -> Either c b) -> a -> Maybe b\tcrocks/Maybe eitherToResult\tEither e a -> Result e a\t(a -> Either e b) -> a -> Result e b\tcrocks/Result firstToAsync\te -> First a -> Async e a\te -> (a -> First b) -> a -> Async e b\tcrocks/Async firstToEither\tc -> First a -> Either c a\tc -> (a -> First b) -> a -> Either c b\tcrocks/Either firstToLast\tFirst a -> Last a\t(a -> First b) -> a -> Last b\tcrocks/Last firstToMaybe\tFirst a -> Maybe a\t(a -> First b) -> a -> Maybe b\tcrocks/Maybe firstToResult\tc -> First a -> Result c a\tc -> (a -> First b) -> a -> Result c b\tcrocks/Result lastToAsync\te -> Last a -> Async e a\te -> (a -> Last b) -> a -> Async e b\tcrocks/Async lastToEither\tc -> Last a -> Either c a\tc -> (a -> Last b) -> a -> Either c b\tcrocks/Either lastToFirst\tLast a -> First a\t(a -> Last b) -> a -> First b\tcrocks/First lastToMaybe\tLast a -> Maybe a\t(a -> Last b) -> a -> Maybe b\tcrocks/Maybe lastToResult\tc -> Last a -> Result c a\tc -> (a -> Last b) -> a -> Result c b\tcrocks/Result listToArray\tList a -> [ a ]\t(a -> List b) -> a -> [ b ]\tcrocks/List maybeToArray\tMaybe a -> [ a ]\t(a -> Maybe b) -> a -> [ b ]\tcrocks/Maybe maybeToAsync\te -> Maybe a -> Async e a\te -> (a -> Maybe b) -> a -> Async e b\tcrocks/Async maybeToEither\tc -> Maybe a -> Either c a\tc -> (a -> Maybe b) -> a -> Either c b\tcrocks/Either maybeToFirst\tMaybe a -> First a\t(a -> Maybe b) -> a -> First b\tcrocks/First maybeToLast\tMaybe a -> Last a\t(a -> Maybe b) -> a -> Last b\tcrocks/Last maybeToList\tMaybe a -> List a\t(a -> Maybe b) -> a -> List b\tcrocks/List maybeToResult\tc -> Maybe a -> Result c a\tc -> (a -> Maybe b) -> a -> Result c b\tcrocks/Result resultToAsync\tResult e a -> Async e a\t(a -> Result e b) -> a -> Async e b\tcrocks/Async resultToEither\tResult e a -> Either e a\t(a -> Result e b) -> a -> Either e b\tcrocks/Either resultToFirst\tResult e a -> First a\t(a -> Result e b) -> a -> First b\tcrocks/First resultToLast\tResult e a -> Last a\t(a -> Result e b) -> a -> Last b\tcrocks/Last resultToMaybe\tResult e a -> Maybe a\t(a -> Result e b) -> a -> Maybe b\tcrocks/Maybe tupleToArray\tTuple a -> [ a ]\t(a -> Tuple b) -> a -> [ b ]\tcrocks/Tuple writerToPair\tWriter m a -> Pair m a\t(a -> Writer m b) -> a -> Pair m b\tcrocks/Pair "},{"title":"Maybe","type":0,"sectionRef":"#","url":"docs/crocks/Maybe","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#implements","content":"Setoid, Semigroup, Functor, Alt, Plus, Apply, Traversable,Chain, Applicative, Alternative, Monad "},{"title":"Construction","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#construction","content":"Copy Maybe :: a -> Maybe a Most of the time, Maybe is constructed using helper functions like safe or by employing one of the instance constructors, Just or Nothing. This is due to the nature of Maybe and most other Sum Types. As a matter of consistency and completion, a Maybe instance can also be constructed using its TypeRep like any other type. The Maybe constructor is a unary function that accepts any type a and returns a Just instance, wrapping the value passed to its argument. Copy importMaybefrom'crocks/Maybe' import equals from'crocks/pointfree/equals' Maybe('some string') //=> Just \"some string\" Maybe(null) //=> Just null Maybe(undefined) //=> Just undefined Maybe.of('some string') //=> Just \"some string\" Maybe.of(null) //=> Just null Maybe.of(undefined) //=> Just undefined Maybe.Just('some string') //=> Just \"some string\" Maybe.Just(null) //=> Just null Maybe.Just(undefined) //=> Just undefined equals( Maybe.Just([1,2,3]), Maybe.of([1,2,3]) ) //=> true equals( Maybe.of({ a:100}), Maybe({ a:100}) ) //=> true runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#constructor-methods","content":""},{"title":"Nothing","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#nothing","content":"Copy Maybe.Nothing :: () -> Maybe a Used to construct a Nothing instance that represents the \"false\" portion of a disjunction. When an instance is a Nothing, most Maybe returning methods will just return another Nothing. Anything passed to the constructor will be thrown out and mapped to (). Copy importMaybefrom'crocks/Maybe' import chain from'crocks/pointfree/chain' import isNumber from'crocks/predicates/isNumber' import safeLift from'crocks/Maybe/safeLift' const{Just,Nothing}=Maybe // add10 :: Number -> Number constadd10= x=> x +10 // safeAdd10 :: a -> Maybe Number const safeAdd10 = safeLift(isNumber, add10) Just(23) .map(add10) //=> Just 33 Nothing(23) .map(add10) //=> Nothing chain(safeAdd10,Just(10)) //=> Just 20 chain(safeAdd10,Nothing()) //=> Nothing runkit "},{"title":"Just","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#just","content":"Copy Maybe.Just :: a -> Maybe a Used to construct a Just instance that represents the \"true\" portion of a disjunction or a valid value. Just will wrap any given value in a Just, signaling the validity of the wrapped value. Copy importMaybefrom'crocks/Maybe' import compose from'crocks/helpers/compose' import ifElse from'crocks/logic/ifElse' import isString from'crocks/predicates/isString' import map from'crocks/pointfree/map' const{Just,Nothing}=Maybe // toUpper :: String -> String consttoUpper= x=> x.toUpperCase() // safe :: (a -> Boolean) -> a -> Maybe a constsafe= pred=>ifElse(pred,Just,Nothing) // safeShout :: a -> Maybe String const safeShout =compose( map(toUpper), safe(isString) ) safeShout(45) //=> Nothing safeShout('Hey there!') //=> Just \"HEY THERE!\" runkit "},{"title":"of","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#of","content":"Copy Maybe.of :: a -> Maybe a Used to wrap any value into a Maybe as a Just, of is used mostly by helper functions that work \"generically\" with instances of either Applicative or Monad. When working specifically with the Maybe type, the Just constructor should be used. Reach for of when working with functions that will work with ANY Applicative/Monad. Copy importMaybefrom'crocks/Maybe' import curry from'crocks/helpers/curry' import isString from'crocks/predicates/isString' import safe from'crocks/Maybe/safe' const{Just}=Maybe Maybe(35) //=> Just 35 Just(35) //=> Just 35 Maybe.of(35) //=> Just 35 const safeString = safe(isString) // lift2 :: Applicative m => (a -> b -> c) -> m a -> m b -> m c const lift2 =curry( (fn, x, y)=> x.of(fn).ap(x).ap(y) ) // join :: Applicative m => m String -> m String -> m String const join = lift2(a=>b=>`${a}${b}`) join(safeString('Brad'),safeString('Pitt')) //=> Just \"Brad Pitt\" join(safeString(34),safeString('Pitt')) //=> Nothing runkit "},{"title":"zero","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#zero","content":"Copy Maybe.zero :: () -> Maybe a When working with Alts, zero provides a sort of empty or identity for Maybe when used with alt. zero takes no arguments and returns a Nothing instance. Just like an empty method on a given Monoid, zero can be used to fold a collection of Alts under alt. Copy importMaybefrom'crocks/Maybe' import alt from'crocks/pointfree/alt' import flip from'crocks/combinators/flip' import isNumber from'crocks/predicates/isNumber' import mapReduce from'crocks/helpers/mapReduce' import safe from'crocks/Maybe/safe' const{Nothing,Just, zero }=Maybe // firstValid :: [ * ] -> Maybe Number const firstValid = mapReduce(safe(isNumber),flip(alt),zero()) Just(33) .alt(zero()) //=> Just 33 zero() .alt(Just(33)) //=> Just 33 Nothing() .alt(zero()) //=> Nothing zero() .alt(Nothing()) //=> Nothing firstValid([null,'nope',10,45]) //=> Just 10 firstValid([75,null,'nope']) //=> Just 75 firstValid([null,undefined,'wrong']) //=> Nothing runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#equals","content":"Copy Maybe a ~> b -> Boolean Used to compare the underlying values of two Maybe instances for equality by value, equals takes any given argument and returns true if the passed arguments is a Maybe with an underlying value equal to the underlying value of the Maybe the method is being called on. If the passed argument is not a Maybe or the underlying values are not equal, equals will return false. Copy importMaybefrom'crocks/Maybe' import equals from'crocks/pointfree/equals' const{Nothing,Just}=Maybe Just(33) .equals(Just(33)) //=> true Nothing() .equals(Nothing()) //=> true Nothing() .equals(Just(33)) //=> false // by value, not reference for most types Just({ a:86, b:true}) .equals(Just({ a:86, b:true})) //=> true equals(Just(95),95) //=> false equals(undefined,Nothing()) //=> false equals(Just([2,3]),Just([2,3])) //=> true runkit "},{"title":"concat","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#concat","content":"Copy Semigroup s => Maybe s ~> Maybe s -> Maybe s When an underlying value of a given Maybe is fixed to a Semigroup, concat can be used to concat another Maybe instance with an underlying Semigroup of the same type. Expecting a Maybe wrapping a Semigroup of the same type, concat will give back a new Maybe instance wrapping the result of combining the two underlying Semigroups. When called on a Nothing instance, concat will return a Nothing. Copy importMaybefrom'crocks/Maybe' importSumfrom'crocks/Sum' import compose from'crocks/helpers/compose' import concat from'crocks/pointfree/concat' import flip from'crocks/combinators/flip' import isNumber from'crocks/predicates/isNumber' import map from'crocks/pointfree/map' import mapReduce from'crocks/helpers/mapReduce' import safeLift from'crocks/Maybe/safeLift' import valueOf from'crocks/pointfree/valueOf' const{Nothing,Just}=Maybe // safeSum :: a -> Maybe Sum const safeSum = safeLift(isNumber,Sum) // empty :: Maybe Sum const empty = Just(Sum.empty()) // sumList :: [ * ] -> Maybe Number const sumList =compose( map(valueOf), mapReduce(safeSum,flip(concat), empty) ) Just([34]) .concat(Just([92])) //=> Just [ 34, 92 ] Just([34]) .concat(Nothing()) //=> Nothing sumList([3,4,5]) //=> Just 12 sumList(['three',4,'five']) //=> Nothing runkit "},{"title":"map","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#map","content":"Copy Maybe a ~> (a -> b) -> Maybe b Used to apply transformations to values in the safety of a Maybe, map takes a function that it will lift into the context of the Maybe and apply to it the wrapped value. When ran on a Just instance, map will apply the wrapped value to the provided function and return the result in a new Just instance. Copy importMaybefrom'crocks/Maybe' import assign from'crocks/helpers/assign' import compose from'crocks/helpers/compose' import isObject from'crocks/predicates/isObject' import isString from'crocks/predicates/isString' import map from'crocks/pointfree/map' import safe from'crocks/Maybe/safe' const{Nothing,Just}=Maybe // add10 :: Number -> Number constadd10= x=> x +10 // toUpper :: String -> String consttoUpper=x=> x.toUpperCase() // safeObj :: a -> Maybe Object const safeObj = safe(isObject) // shout :: a -> Maybe String constshout=x=> safe(isString, x) .map(toUpper) // setProcessed :: a -> Maybe Object const setProcessed =compose( map(assign({ processed:true})), safeObj ) Just(0) .map(add10) //=> Just 10 Nothing() .map(add10) //=> Nothing shout('good news') //=> Just \"GOOD NEWS\" shout(33) //=> Nothing setProcessed({ cheese:true}) //=> Just { cheese: true, processed: true } setProcessed(null) //=> Nothing runkit "},{"title":"alt","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#alt","content":"Copy Maybe a ~> Maybe a -> Maybe a Providing a means for a fallback or alternative value, alt combines two Maybe instances and will return the first Just it encounters or Nothing if it does not have a Just. This can be used in conjunction with zero to return the first valid value in contained in a Foldable structure. Copy importMaybefrom'crocks/Maybe' import alt from'crocks/pointfree/alt' import isArray from'crocks/predicates/isArray' import flip from'crocks/combinators/flip' import mapReduce from'crocks/helpers/mapReduce' import safe from'crocks/Maybe/safe' const{ zero,Nothing,Just}=Maybe // firstArray :: Foldable f => f * -> Maybe Array const firstArray = mapReduce(safe(isArray),flip(alt),zero()) Nothing() .alt(Just(33)) //=> Just 33 Just(42) .alt(Nothing()) .alt(Just(99)) //=> Just 42 firstArray(['Not Array',null,[2,3,4],[1,2]]) //=> Just [ 2, 3, 4 ] firstArray([null,5,'76']) //=> Nothing runkit "},{"title":"ap","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#ap","content":"Copy Maybe (a -> b) ~> Maybe a -> Maybe b Short for apply, ap is used to apply a Maybe instance containing a value to another Maybe instance that contains a function, resulting in new Maybe instance with the result. ap requires that it is called on an instance that is either a Nothing or a Just that wraps a curried polyadic function. When either Maybe is a Nothing, ap will return a Nothing. This can be used to safely combine multiple values under a given combination function. If any of the inputs results in a Nothing than they will never be applied to the function and not provide exceptions or unexpected results. Copy importMaybefrom'crocks/Maybe' import compose from'crocks/helpers/compose' import chain from'crocks/pointfree/chain' import curry from'crocks/helpers/curry' import fanout from'crocks/Pair/fanout' import getProp from'crocks/Maybe/getProp' import isString from'crocks/predicates/isString' import liftA2 from'crocks/helpers/liftA2' import merge from'crocks/pointfree/merge' import safe from'crocks/Maybe/safe' const{Nothing,Just}=Maybe // add :: Number -> Number -> Number constadd= x=>y=> x + y // joinWith :: String -> String -> String -> String const joinWith =curry( (del, x, y)=> x + del + y ) // stringProp :: String -> a -> Maybe String conststringProp=key=>compose( chain(safe(isString)), getProp(key) ) // getNames :: a -> Pair (Maybe String) (Maybe String) const getNames =fanout( stringProp('first'), stringProp('last') ) // joinNames :: Pair (Maybe String) (Maybe String) -> Maybe String const joinNames = merge(liftA2(joinWith(' '))) // fullName :: a -> Maybe String const fullName = compose(joinNames, getNames) Maybe.of(add) .ap(Just(5)) .ap(Just(27)) //=> Just 32 Just('hello') .map(joinWith(' -- ')) .ap(Just('friend')) //=> Just \"hello -- friend\" Maybe.of(add) .ap(Just(29)) .ap(Nothing()) //=> Nothing fullName({ first:'Joey', last:'Fella'}) //=> Just \"Joey Fella\" fullName(null) //=> Nothing fullName({ first:'Lizzy'}) //=> Nothing runkit "},{"title":"sequence","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#sequence","content":"Copy Apply f => Maybe (f a) ~> (b -> f b) -> f (Maybe a) Applicative f => Maybe (f a) ~> TypeRep f -> f (Maybe a) When an instance of Maybe wraps an Apply instance, sequence can be used to swap the type sequence. sequence requires either an Applicative TypeRep or an Apply returning function is provided for its argument. This will be used in the case that the Maybe instance is a Nothing. sequence can be derived from traverse by passing it an identity function (x => x). Copy importMaybefrom'crocks/Maybe' importIdentityfrom'crocks/Identity' import sequence from'crocks/pointfree/sequence' const{Nothing,Just}=Maybe // seqId :: Maybe Identity a -> Identity Maybe a const seqId = sequence(Identity) seqId(Just(Identity(34))) //=> Identity Just 34 seqId(Nothing()) //=> Identity Nothing runkit "},{"title":"traverse","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#traverse","content":"Copy Apply f => Maybe a ~> (c -> f c), (a -> f b)) -> f Maybe b Applicative f => Maybe a ~> (TypeRep f, (a -> f b)) -> f Maybe b Used to apply the \"effect\" of an Apply to a value inside of a Maybe,traverse combines both the \"effects\" of the Apply and the Maybe by returning a new instance of the Apply, wrapping the result of the Applys \"effect\" on the value in the Maybe. traverse requires either an Applicative TypeRep or an Apply returning function as its first argument and a function that is used to apply the \"effect\" of the target Apply to the value inside of the Maybe. This will be used in the case that the Maybe instance is a Nothing. Both arguments must provide an instance of the target Apply. Copy importIOfrom'crocks/IO' import compose from'crocks/helpers/compose' import isNumber from'crocks/predicates/isNumber' import safe from'crocks/Maybe/safe' import traverse from'crocks/pointfree/traverse' // someGlobal :: Number let someGlobal =10 // addToGlobal :: Number -> IO Number constaddToGlobal=x=>IO(function(){ someGlobal = someGlobal + x return someGlobal }) // safeAddToGlobal :: a -> IO (Maybe Number) const safeAddToGlobal =compose( traverse(IO, addToGlobal), safe(isNumber) ) safeAddToGlobal(32) .run() //=> Just 42 //someGlobal => 42 safeAddToGlobal(undefined) .run() //=> Nothing runkit "},{"title":"chain","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#chain","content":"Copy Maybe a ~> (a -> Maybe b) -> Maybe b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. chain expects a unary, Maybe returning function as its argument. When invoked on a Nothing, chain will not run the function, but will instead return another Nothing. When called on a Just however, the inner value will be passed to provided function, returning the result as the new instance. Copy importMaybefrom'crocks/Maybe' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import getProp from'crocks/Maybe/getProp' import isNumber from'crocks/predicates/isNumber' import isString from'crocks/predicates/isString' import safe from'crocks/Maybe/safe' import safeLift from'crocks/Maybe/safeLift' const{Nothing,Just}=Maybe // double :: Number -> Number constdouble= x=> x + x // chainNumber :: Maybe a -> Maybe Number const chainNumber = chain(safe(isNumber)) // doubleValue :: a -> Maybe Number const doubleValue =compose( chain(safeLift(isNumber, double)), getProp('value') ) chainNumber(Just(45)) //=> Just 45 chainNumber(Nothing()) //=> Nothing Just(45) .chain(safe(isString)) //=> Nothing doubleValue(undefined) //=> Nothing doubleValue({ value:'45'}) //=> Nothing doubleValue({ number:45}) //=> Nothing doubleValue({ value:45}) //=> Just 90 runkit "},{"title":"coalesce","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#coalesce","content":"Copy Maybe a ~> ((() -> b), (a -> b))) -> Maybe b When one would like to option a Maybe but would like to remain within a Maybe type, coalesce can be used. coalesce expects two functions for its inputs. The first function is used when invoked on a Nothing and will return a Just instance wrapping the result of the function. The second function is used when coalesce is invoked on a Just and is used to map the original value, returning a new Just instance wrapping the result of the second function. Copy importMaybefrom'crocks/Maybe' import compose from'crocks/helpers/compose' import composeK from'crocks/helpers/composeK' import coalesce from'crocks/pointfree/coalesce' import constant from'crocks/combinators/constant' import getProp from'crocks/Maybe/getProp' import identity from'crocks/combinators/identity' import isString from'crocks/predicates/isString' import map from'crocks/pointfree/map' import objOf from'crocks/helpers/objOf' import safe from'crocks/Maybe/safe' const{Nothing,Just}=Maybe // shout :: String -> String constshout= x=> x.toUpperCase() // defaultString :: Maybe String -> Maybe String const defaultString = coalesce(constant(''), identity) // shoutOut :: String -> Object const shoutOut =compose( objOf('shout'), shout ) // stringValue :: a -> Maybe String const stringValue =composeK( safe(isString), getProp('value') ) // shoutValue :: a -> Maybe Object const shoutValue =compose( map(shoutOut), defaultString, stringValue ) Just(76) .coalesce(constant(0), identity) //=> Just 76 Nothing() .coalesce(constant(0), identity) //=> Just 0 shoutValue({ value:'hello'}) //=> Just { shout: 'HELLO' } shoutValue(undefined) //=> Just { shout: '' } shoutValue({ value:49}) //=> Just { shout: '' } shoutValue({}) //=> Just { shout: '' } runkit "},{"title":"bichain","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#bichain","content":"Copy Maybe a ~> ((() -> Maybe b), (a -> Maybe b)) -> Maybe b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. Along the same lines, bichain allows you to do this from both Nothing and Just. bichain expects two unary, Either returning functions as its arguments. When invoked on a Nothing instance, bichain will use the left, or first, function that can return either a Nothing or a Just instance. When called on a Just instance, it will behave exactly as chain would with the right, or second, function. Copy importMaybefrom'crocks/Maybe' import bichain from'crocks/pointfree/bichain' import constant from'crocks/combinators/constant' const{Nothing,Just}=Maybe // swapMaybe :: Maybe a -> Maybe b const swapMaybe =bichain( constant(Just('nothing')), Nothing ) swapMaybe(Nothing()) //=> Just Nothing swapMaybe(Just('just')) //=> Nothing runkit "},{"title":"option","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#option","content":"Copy Maybe a ~> a -> a Used as the primary way to \"fold\" a value out of a Maybe, option expects a default value. The default value provided will be returned when option is invoked on a Nothing instance. When invoked on a Just, the underlying value is returned, discarding the provided default value. option is typically ran at the \"edge\" of a flow, to provide default values for complicated representations of disjunction. When the need to immediately map the result of optioning a Maybe arises, then either may be employed to combine it in one operation. Copy importMaybefrom'crocks/Maybe' const{Nothing,Just}=Maybe Nothing() .option(0) //=> 0 Just(99) .option(0) //=> 99 runkit "},{"title":"either","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#either","content":"Copy Maybe a ~> ((() -> b), (a -> b)) -> b Used to provide a means to map a given Maybe instance while optioning out the wrapped value. option can handle most cases for optioning Maybe, but does not provide a means to map a given value at the time of optioning. either expects two functions as its arguments. The first is a pointed function that will be used when invoked on a Nothing. While the second will map the value wrapped in a given Just and return the result of that mapping. Copy importMaybefrom'crocks/Maybe' import either from'crocks/pointfree/either' const{Nothing,Just}=Maybe // wrap :: a -> [ a ] constwrap= x=>[ x ] // empty :: () -> [ a ] constempty= ()=>[] // toArray :: Maybe a -> [ a ] const toArray = either(empty, wrap) toArray(Just(56)) //=> [ 56 ] toArray(Nothing()) //=> [] runkit "},{"title":"Helper Functions","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#helper-functions","content":""},{"title":"find","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#find","content":"crocks/Maybe/find Copy find :: Foldable f => ((a -> Boolean) | Pred) -> f a -> Maybe a Using a provided predicate function or a Pred datatype, find takes a Foldable instance and executes for every value in the Foldable, skipping empty indexes. find then returns the first value it finds that passes the predicate. If found, find returns the value in a Just, otherwise a Nothing is returned. Copy import find from'crocks/Maybe/find' importPredfrom'crocks/Pred' import isNumber from'crocks/predicates/isNumber' // isEven :: Number -> Boolean constisEven= x=> x %2===0 // largeNumber :: Pred a const largeNumber = Pred(isNumber) .concat(Pred(x=> x >100)) find(largeNumber,[10,'12',150,200,2000]) //=> Just 150 find(largeNumber,[1,2,3,4,5]) //=> Nothing find(isEven,[1,2,3,4,5]) //=> Just 2 runkit "},{"title":"getPath","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#getpath","content":"crocks/Maybe/getPath Copy getPath :: [ (String | Integer) ] -> a -> Maybe b While getProp is good for simple, single-level structures, there may come a time when you have to work with nested POJOs or Arrays. When you run into this situation, just pull in getPath (formally known as propPath) and pass it a left-to-right traversal path of keys, indices or a combination of both. This will kick you back a function that behaves just like getProp. You pass it some data, and it will attempt to resolve your provided path. If the path is valid, it will return the value residing there (null and NaN included!) in a Just. But, if at any point, that path \"breaks\", it will give you back a Nothing. Copy import composeK from'crocks/helpers/composeK' import isString from'crocks/predicates/isString' import getPath from'crocks/Maybe/getPath' import safe from'crocks/Maybe/safe' // getFirstValue :: a -> Maybe b const getFirstValue = getPath(['value',0]) // getStringFirst :: a -> Maybe String const getStringFirst =composeK( safe(isString), getFirstValue ) getFirstValue({ value:[]}) //=> Nothing getFirstValue({ value:84}) //=> Nothing getFirstValue(undefined) //=> Nothing getFirstValue({ value:['a','b']}) //=> Just \"a\" getStringFirst(false) //=> Nothing getStringFirst({ towel:true}) //=> Nothing getStringFirst({ value:[0,54]}) //=> Nothing getStringFirst({ value:['nice','jobb']}) //=> Just \"nice\" runkit "},{"title":"getProp","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#getprop","content":"crocks/Maybe/getProp Copy getProp :: (String | Integer) -> a -> Maybe b If you want some safety around pulling a value out of an Object or Array with a single key or index, you can always reach for getProp, previously known as prop. Well, as long as you are working with non-nested data that is. Just tell getProp either the key or index you are interested in, and you will get back a function that will take anything and return a Just with the wrapped value if the key/index is defined. If the key/index is not defined, you will get back a Nothing. Copy import composeK from'crocks/helpers/composeK' import getProp from'crocks/Maybe/getProp' // getValue :: a -> Maybe b const getValue = getProp('value') // getHead :: a -> Maybe b const getHead = getProp(0) // getFirstValue :: a -> Maybe b const getFirstValue =composeK( getHead, getValue ) getValue({ some:false}) //=> Nothing getValue(undefined) //=> Nothing getValue({ value:'correct'}) //=> Just \"correct\" getFirstValue({ value:[]}) //=> Nothing getFirstValue({ value:84}) //=> Nothing getFirstValue(null) //=> Nothing getFirstValue({ value:['a','b']}) //=> Just \"a\" runkit "},{"title":"safe","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#safe","content":"crocks/Maybe/safe Copy safe :: ((b -> Boolean) | Pred) -> b -> Maybe a When using a Maybe, it is a common practice to lift into a Just or a Nothing depending on a condition on the value to be lifted. It is so common that it warrants a function, and that function is called safe. Provide a predicate (a function that returns a Boolean) or a Pred datatype and the value to be lifted. The value will be evaluated against the predicate, and will lift it into a Just if true and a Nothing if false. Copy importPredfrom'crocks/Pred' import isArray from'crocks/predicates/isArray' import safe from'crocks/Maybe/safe' // length :: Array -> Number constlength= x=> x.length // lte2 :: Number -> Boolean constlte2= x=> x <=2 // isSmall :: Pred a const isSmall = Pred(isArray) .concat(Pred(lte2).contramap(length)) safe(lte2,87) //=> Nothing safe(lte2,1) //=> Just 1 safe(isArray,{}) //=> Nothing safe(isArray,[1,2,3]) //=> Just [ 1, 2, 3 ] safe(isSmall,[1,2,3]) //=> Nothing safe(isSmall,{ ar:[1,2,3]}) //=> Nothing safe(isSmall,null) //=> Nothing safe(isSmall,[1,2]) //=> Just [ 1, 2 ] runkit "},{"title":"safeAfter","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#safeafter","content":"crocks/Maybe/safeAfter Copy safeAfter :: ((b -> Boolean) | Pred) -> (a -> b) -> a -> Maybe b Many times, you might want to lift the result of a function into a Maybe based on some predicate. This may be because some parts of our code might return unsafe values for further computations we may like to perform. Similar to safe, you pass either aPred or a predicate function, along with a unary function. safeAfter then gives you a new function, which when invoked evaluates the predicate against the result of executing the unary function. This result is then lifted into a Just if the predicate evaluates to true, or a Nothing if it returns false Copy importPredfrom'crocks/Pred' import curry from'crocks/helpers/curry' import isDefined from'crocks/predicates/isDefined' import isNumber from'crocks/predicates/isNumber' import safeAfter from'crocks/Maybe/safeAfter' // prop :: String -> Object -> a | undefined const prop =curry( (key, x)=> x[key] ) // divide :: Number -> Number -> Number const divide =curry( (x, y)=> x / y ) // safeDivide :: Number -> Number -> Maybe FiniteNumber const safeDivide =curry( x=>safeAfter(isFinite,divide(x)) ) // isValid :: Pred a const isValid = Pred(isDefined) .concat(Pred(isNumber)) // safePropNumber :: String -> Object -> Maybe Number const validProp =curry( key=>safeAfter(isValid,prop(key)) ) divide(3,0) //=> Infinity safeDivide(3,0) //=> Nothing divide(3,1) //=> 3 safeDivide(3,1) //=> Just 3 prop('a',{ b:32}) //=> undefined prop('a',{ a:'thirty-two'}) //=> 'thirty-two' prop('a',{ a:32}) //=> 32 validProp('a',{ a:'thirty-two'}) //=> Nothing validProp('a',{ b:32}) //=> Nothing validProp('a',{ a:32}) //=> Just 32 runkit "},{"title":"safeLift","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#safelift","content":"crocks/Maybe/safeLift Copy safeLift :: ((c -> Boolean) | Pred) -> (a -> b) -> c -> Maybe b While safe is used to lift a value into a Maybe, you can reach for safeLift when you want to run a function in the safety of the Maybe context. Just like safe, you pass it either a Pred or a predicate function to determine if you get a Just or a Nothing, but then instead of a value, you pass it a unary function. safeLift will then give you back a new function that will first lift its argument into a Maybe and then maps your original function over the result. Copy importPredfrom'crocks/Pred' import isNumber from'crocks/predicates/isNumber' import safeLift from'crocks/Maybe/safeLift' // doubleOf :: Number -> Number constdoubleOf= x=> x *2 // halfOf :: Number -> Number consthalfOf= x=> x /2 // gt100 :: Number -> Boolean constgt100= x=> x >100 // safeDouble :: a -> Maybe Number const safeDouble = safeLift(isNumber, doubleOf) // isLargeNumber :: Pred a const isLargeNumber = Pred(isNumber) .concat(Pred(gt100)) // halfLarge :: a -> Maybe Number const halfLarge = safeLift(isLargeNumber, halfOf) safeDouble(null) // Nothing safeDouble('33') // Nothing safeDouble(33) // Just 66 halfLarge('1000') // Nothing halfLarge(100) // Nothing halfLarge(false) // Nothing halfLarge(786) // Just 383 halfLarge(100) // Nothing halfLarge(false) // Nothing runkit "},{"title":"Transformation Functions","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#transformation-functions","content":""},{"title":"eitherToMaybe","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#eithertomaybe","content":"crocks/Maybe/eitherToMaybe Copy eitherToMaybe :: Either b a -> Maybe a eitherToMaybe :: (a -> Either c b) -> a -> Maybe b Used to transform a given Either instance to a Maybe instance or flatten a Maybe of Either into a Maybe when chained, eitherToMaybe will turn a Right instance into a Just wrapping the original value contained in the Right. All Left instances will map to a Nothing, mapping the originally contained value to a Unit. Values on the Left will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, eitherToMaybe has two possible signatures and will behave differently when passed either an Either instance or a function that returns an instance of Either. When passed the instance, a transformed Maybe is returned. When passed an Either returning function, a function will be returned that takes a given value and returns a Maybe. Copy importMaybefrom'crocks/Maybe' importEitherfrom'crocks/Either' import eitherToMaybe from'crocks/Maybe/eitherToMaybe' import constant from'crocks/combinators/constant' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' const{Nothing,Just}=Maybe const{Left,Right}=Either // someNumber :: a -> Either String Number const someNumber =ifElse( isNumber, Right, constant(Left('Nope')) ) eitherToMaybe(Left(56)) //=> Nothing eitherToMaybe(Right('correct')) //=> Just \"correct\" Just('ten') .chain(eitherToMaybe(someNumber)) //=> Nothing Nothing() .chain(eitherToMaybe(someNumber)) //=> Nothing Just(99) .chain(eitherToMaybe(someNumber)) //=> Just 99 Just(Right(42)) .chain(eitherToMaybe) // Just 42 Just(Left(24)) .chain(eitherToMaybe) // Nothing runkit "},{"title":"firstToMaybe","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#firsttomaybe","content":"crocks/Maybe/firstToMaybe Copy firstToMaybe :: First a -> Maybe a firstToMaybe :: (a -> First b) -> a -> Maybe b Used to transform a given First instance to a Maybe instance or flatten a Maybe of First into a Maybe when chained, firstToMaybe will turn a non-empty instance into a Just wrapping the original value contained within the First. All empty instances will map to a Nothing. Like all crocks transformation functions, firstToMaybe has two possible signatures and will behave differently when passed either a First instance or a function that returns an instance of First. When passed the instance, a transformed Maybe is returned. When passed a First returning function, a function will be returned that takes a given value and returns a Maybe. Copy importMaybefrom'crocks/Maybe' importFirstfrom'crocks/First' import firstToMaybe from'crocks/Maybe/firstToMaybe' import mconcat from'crocks/helpers/mconcat' const{Nothing,Just}=Maybe // firstValue :: [ a ] -> First a const firstValue = mconcat(First) firstToMaybe(First.empty()) //=> Nothing firstToMaybe(First('winner')) //=> Just \"Winner\" Nothing() .chain(firstToMaybe(firstValue)) //=> Nothing Just([]) .chain(firstToMaybe(firstValue)) //=> Nothing Just(['first','second','third']) .chain(firstToMaybe(firstValue)) //=> Just \"first\" Just(First('first')) .chain(firstToMaybe) //=> Just \"first\" Just(First.empty()) .chain(firstToMaybe) //=> Nothing runkit "},{"title":"lastToMaybe","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#lasttomaybe","content":"crocks/Maybe/lastToMaybe Copy lastToMaybe :: Last a -> Maybe a lastToMaybe :: (a -> Last b) -> a -> Maybe b Used to transform a given Last instance to a Maybe instance or flatten a Maybe of Last into a Maybe when chained, lastToMaybe will turn a non-empty instance into a Just wrapping the original value contained within the Last. All empty instances will map to aNothing. Like all crocks transformation functions, lastToMaybe has two possible signatures and will behave differently when passed either a Last instance or a function that returns an instance of Last. When passed the instance, a transformed Maybe is returned. When passed a Last returning function, a function will be returned that takes a given value and returns a Maybe. Copy importMaybefrom'crocks/Maybe' importLastfrom'crocks/Last' import lastToMaybe from'crocks/Maybe/lastToMaybe' import mconcat from'crocks/helpers/mconcat' const{Nothing,Just}=Maybe // lastValue :: [ a ] -> Last a const lastValue = mconcat(Last) lastToMaybe(Last.empty()) //=> Nothing lastToMaybe(Last('the end')) //=> Just \"the end\" Nothing() .chain(lastToMaybe(lastValue)) //=> Nothing Just([]) .chain(lastToMaybe(lastValue)) //=> Nothing Just(['first','second','third']) .chain(lastToMaybe(lastValue)) //=> Just \"third\" Just(Last('last')) .chain(lastToMaybe) //=> Just \"last\" Just(Last.empty()) .chain(lastToMaybe) //=> Nothing runkit "},{"title":"maybeToArray","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#maybetoarray","content":"crocks/Maybe/maybeToArray Copy maybeToArray :: Maybe a -> [ a ] maybeToArray :: (a -> Maybe b) -> a -> [ b ] Used to transform a given Maybe instance to an Array or flatten an Array of Maybe into an Array when chained, maybeToArray will turn a Just instance into a single element Array, wrapping the original value contained within the Just instance. All Nothing instances will map to an empty Array. Like all crocks transformation functions, maybeToArray has two possible signatures and will behave differently when passed either a Maybe instance or a function that returns an instance of Maybe. When passed the instance, a transformed Array is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns an Array. Copy importMaybefrom'crocks/Maybe' import chain from'crocks/pointfree/chain' import composeK from'crocks/helpers/composeK' import getProp from'crocks/Maybe/getProp' import isString from'crocks/predicates/isString' import safe from'crocks/Maybe/safe' import maybeToArray from'crocks/Maybe/maybeToArray' const{Nothing,Just}=Maybe maybeToArray(Nothing()) //=> [] maybeToArray(Just(33)) //=> [ 33 ] // flatten :: [ Maybe a ] -> [ a ] const flatten = chain(maybeToArray) flatten([Just(33),Just('text')]) //=> [ 33, 'text' ] flatten([Just('left'),Nothing(),Just('right')]) //=> [ 'left', 'right' ] // getUser :: a -> Maybe String const getUser =composeK( safe(isString), getProp('user') ) // getUsers :: [ * ] -> [ String ] const getUsers = chain(maybeToArray(getUser)) // data :: [ * ] const data =[ { user:'Allison'}, 'Ben', { user:'Beth'}, null, { user:'Claire'} ] getUsers(data) //=> [ 'Allison', 'Beth', 'Claire' ] runkit "},{"title":"resultToMaybe","type":1,"pageTitle":"Maybe","url":"docs/crocks/Maybe#resulttomaybe","content":"crocks/Maybe/resultToMaybe Copy resultToMaybe :: Result e a -> Maybe a resultToMaybe :: (a -> Result e b) -> a -> Maybe b Used to transform a given Result instance to a Maybe instance or flatten a Maybe of Result into a Maybe when chained, resultToMaybe will turn an Ok instance into a Just wrapping the original value contained in the Ok. All Err instances will map to a Nothing, mapping the originally contained value to a Unit. Values on the Err will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, resultToMaybe has two possible signatures and will behave differently when passed either an Result instance or a function that returns an instance of Result. When passed the instance, a transformed Maybe is returned. When passed a Result returning function, a function will be returned that takes a given value and returns a Maybe. Copy importMaybefrom'crocks/Maybe' importResultfrom'crocks/Result' import resultToMaybe from'crocks/Maybe/resultToMaybe' import identity from'crocks/combinators/identity' import tryCatch from'crocks/Result/tryCatch' const{Nothing,Just}=Maybe const{Err,Ok}=Result functiondatErrTho(){ thrownewError('something amiss') } resultToMaybe(Err('this is bad')) //=> Nothing resultToMaybe(Ok('this is great')) //=> Just \"this is great\" Nothing() .chain(resultToMaybe(identity)) //=> Nothing Just('so good') .chain(resultToMaybe(tryCatch(datErrTho))) //=> Nothing Just('so good') .chain(resultToMaybe(Ok)) //=> Just \"so good\" Just(Result('in time!')) .chain(resultToMaybe) //=> Just \"in time!\" Just(Err('to be human')) .chain(resultToMaybe) //=> Nothing runkit "},{"title":"Async","type":0,"sectionRef":"#","url":"docs/crocks/Async","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Async","url":"docs/crocks/Async#implements","content":"Functor, Alt, Bifunctor, Apply, Chain, Applicative, Monad "},{"title":"Construction","type":1,"pageTitle":"Async","url":"docs/crocks/Async#construction","content":"Copy Async :: ((e -> (), a -> ()) -> ()) -> Async e a Async :: ((e -> (), a -> ()) -> (() -> ()) -> Async e a There are two possible ways to construct an Async, depending on the need or ability to cancel a given Async in flight. Both methods of construction require a binary function that takes two unary functions. The first function is used to signal the rejection of a given Async and will settle on a Rejected instance wrapping whatever was passed to the function. The second function is used to settle the Async to a Resolved instance, also wrapping the value passed to the functions. These functions are provided by the Async and will return undefined. The two ways to construct an Async are characterized by the return of the function you are using to construct it. If anything other than a function is returned, then the value is ignored. If however a function is returned, then the function will be run when the Async is canceled while it is \"in-flight\". This function should be used to perform any cleanup required in the event of a cancellation. This cleanup function receives no input and ignores anything that may be returned. Copy importAsyncfrom'crocks/Async' // Async e String Async((reject, resolve)=>{ const token = setTimeout(()=>resolve('fired'),1000) // stop timer on cancel return()=>{clearTimeout(token)} }) //=> Resolved \"fired\" runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Async","url":"docs/crocks/Async#constructor-methods","content":""},{"title":"Rejected","type":1,"pageTitle":"Async","url":"docs/crocks/Async#rejected","content":"Copy Async.Rejected :: e -> Async e a Used to construct a Rejected instance of Async that represents the failure or \"false\" case of the disjunction. Calling Rejected with a given value, will return a new Rejected instance, wrapping the provided value. When an instance is Rejected, most Async returning methods on the instance will return another Rejected instance. This is in contrast to a JavaScript Promise, that will continue on a Resolved path after a catch. This behavior of Promises provide challenges when constructing complicated (or even some simple) Promise chains that may fail at various steps along the chain. Even though Async is a Bifunctor, in most cases it is desired to keep the type of a Rejected fixed to a type for a given flow. Given that Async is a Bifunctor, it is easy to make sure you get the type you need at the edge by leaning on bimap to \"square things up\". Copy importAsyncfrom'crocks/Async' const{Rejected}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // m :: Async String a const m =Async( rej=>{rej('Some Error')} ) // n :: Async String a const n = Rejected('Some Error') m.fork(log('rej'),log('res')) //=> rej: \"Some Error\" n.fork(log('rej'),log('res')) //=> rej: \"Some Error\" runkit "},{"title":"Resolved","type":1,"pageTitle":"Async","url":"docs/crocks/Async#resolved","content":"Copy Async.Resolved :: a -> Async e a Used to construct a Resolved instance that represents the success or \"true\" portion of the disjunction. Resolved will wrap any given value passed to this constructor in the Resolved instance it returns, signaling the validity of the wrapped value. Copy importAsyncfrom'crocks/Async' const{Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // m :: Async e Number const m =Async( (rej, res)=>{res(97)} ) // n :: Async e Number const n = Resolved(97) m.fork(log('rej'),log('res')) //=> res: 97 n.fork(log('rej'),log('res')) //=> res: 97 runkit "},{"title":"fromPromise","type":1,"pageTitle":"Async","url":"docs/crocks/Async#frompromise","content":"Copy Async.fromPromise :: (* -> Promise a e) -> (* -> Async e a) Used to turn an \"eager\" Promise returning function into a function that takes the same arguments, but returns a \"lazy\" Async instance instead. The Promise returning function given to fromPromise is automatically curried, allowing you to partially apply the resulting function to its parameters until an Async type is returned. Copy importAsyncfrom'crocks/Async' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' const{ fromPromise }=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // safeProm :: ((a -> Boolean), a) -> Promise a a constsafeProm=(pred, x)=>newPromise( (res, rej)=>ifElse(pred, res, rej, x) ) safeProm(isNumber,34) .then(log('resProm')) //=> resProm: 34 safeProm(isNumber,'34') .catch(log('rejProm')) //=> rejProm: \"34\" // safeAsync :: (a -> Boolean) -> a -> Async a a const safeAsync = fromPromise(safeProm) // numAsync :: a -> Async a Number const numAsync = safeAsync(isNumber) numAsync(34) .fork(log('rej'),log('res')) //=> res: 34 numAsync('34') .fork(log('rej'),log('res')) //=> rej: \"34\" runkit "},{"title":"fromNode","type":1,"pageTitle":"Async","url":"docs/crocks/Async#fromnode","content":"Copy NodeCallback :: (e, a) -> () Async.fromNode :: ((*, NodeCallback) -> ()) -> (* -> Async e a) Async.fromNode :: (((*, NodeCallback) -> ()), ctx) -> (* -> Async e a) Many of the asynchronous functions that ship with Node JS provide a Continuation Passing Style, that requires the use of a callback function to be passed as the last argument. The provided callback functions are binary functions that take an err as the first argument, which is null when there is no error to be reported. The second argument is the data representing the result of the function in the case that there is no error present. This interface can create the fabled pyramid of callback doom when trying to combine multiple asynchronous calls. fromNode can be used to wrap functions of this style. Just pass the desired function to wrap and fromNode will give back a new function, that takes the same number of arguments, minus the callback function. When the provided function is called, it returns a \"lazy\" Async. When the resulting instance is forked, if the err is a non-null value then the instance will be Rejected with the err value. When the err is null, then the instance will be Resolved with the data value. There are some libraries whose functions are methods on some stateful object. As such, the need for binding may arise. fromNode provides a second, optional argument that takes the context that will be used to bind the function being wrapped. Any curried interface will not be respected and if a curried interface is needed then nAry can be used. Copy importAsyncfrom'crocks/Async' import curry from'crocks/helpers/curry' import isNumber from'crocks/predicates/isNumber' import nAry from'crocks/helpers/nAry' import partial from'crocks/helpers/partial' const{ fromNode }=Async // log :: String -> a -> a const log =curry(label=>x=> (console.log(`${label}:`, x), x) ) // NodeCallback :: (e, a) -> () // delay :: (Number, a, NodeCallback (String, Number)) -> () functiondelay(delay, val, cb){ setTimeout( ()=>isNumber(val)?cb(null, val):cb('No Number'), delay ) } // callback :: (e, a) -> () constcallback=(err, data)=>{ err ?log('err', err):log('data', data) } // wait500 :: a -> NodeCallback (String, Number) -> () const wait500 = partial(delay,500) wait500(32, callback) //=> data: 32 wait500('32', callback) //=> err: \"No Number\" // delayAsync :: Number -> a -> Async String Number const delayAsync = nAry(2,fromNode(delay)) // waitAsync :: a -> Async String Number const waitAsync = delayAsync(1000) waitAsync(32) .fork(log('rej'),log('res')) //=> res: 32 waitAsync('32') .fork(log('rej'),log('res')) //=> rej: \"No Number\" runkit "},{"title":"all","type":1,"pageTitle":"Async","url":"docs/crocks/Async#all","content":"Copy Async.all :: [ Async e a ] -> Async e [ a ] Async provides an all method that can be used when multiple, independent asynchronous operations need to be run in parallel. all takes an Array of Async instances that, when forked, will execute each instance in the provided Array in parallel. If any of the instances result in a Rejected state, the entire flow will be Rejected with value of the first Rejected instance. If all instances resolve, then the entire instance is Resolved with an Array containing all Resolved values in their provided order. Copy importAsyncfrom'crocks/Async' const{ all,Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) all([Resolved(1),Resolved(2),Resolved(3)]) .fork(log('rej'),log('res')) //=> res: [ 1, 2, 3 ] all([Resolved(1),Rejected(2),Rejected(3)]) .fork(log('rej'),log('res')) //=> rej: 2 runkit "},{"title":"resolveAfter","type":1,"pageTitle":"Async","url":"docs/crocks/Async#resolveafter","content":"Copy Async.resolveAfter :: (Integer, a) -> Async e a Used to resolve a value after a specified number of milliseconds. This function takes a positive Integer as its first argument and a value to resolve with as its second. resolveAfter returns a new Async that will resolve a value after the specified interval has elapsed. Copy importAsyncfrom'crocks/Async' import curry from'crocks/helpers/curry' // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // delay :: Integer -> a -> Async e a const delay =curry( Async.resolveAfter ) Async.of('late, but here') .chain(delay(1000)) .fork(log('rejected'),log('resolved')) //=> resolved: \"late, but here\" runkit "},{"title":"rejectAfter","type":1,"pageTitle":"Async","url":"docs/crocks/Async#rejectafter","content":"Copy Async.rejectAfter :: (Integer, e) -> Async e a Used to reject a value after a specified number of milliseconds. This function takes a positive Integer as its first argument and a value to reject with as its second. This can be used to reject and Async after a specified period of time. When used with race, the Async provided can be used to provide a time limit for a given Async task. Copy importAsyncfrom'crocks/Async' // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // resovle :: a -> Async e a constresolve=x=>Async((rej, res)=>{ setTimeout(()=>res(x),1000) }) resolve('okay') .race(Async.rejectAfter(500,'not okay')) .fork(log('reject'),log('resolve')) //=> reject: \"not okay\" runkit "},{"title":"of","type":1,"pageTitle":"Async","url":"docs/crocks/Async#of","content":"Copy Async.of :: a -> Async e a Used to wrap any value into an Async as a Resolved instance, of is used mostly by helper functions that work \"generically\" with instances of either Applicative or Monad. When working specifically with the Async type, the Resolved constructor should be used. Reach for of when working with functions that will work with ANY Applicative/Monad. Copy importAsyncfrom'crocks/Async' const{Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) Async.of('U Wut M8') .fork(log('rej'),log('res')) //=> res: \"U Wut M8\" Resolved('U Wut M8') .fork(log('rej'),log('res')) //=> res: \"U Wut M8\" Async((rej, res)=>res('U Wut M8')) .fork(log('rej'),log('res')) //=> res: \"U Wut M8\" runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Async","url":"docs/crocks/Async#instance-methods","content":""},{"title":"map","type":1,"pageTitle":"Async","url":"docs/crocks/Async#map","content":"Copy Async e a ~> (a -> b) -> Async e b Used to apply transformations to Resolved values of an Async, map takes a function that it will lift into the context of the Async and apply to it the wrapped value. When ran on a Resolved instance, map will apply the wrapped value to the provided function and return the result in a new Resolved instance. Copy importAsyncfrom'crocks/Async' import and from'crocks/logic/and' import compose from'crocks/helpers/compose' import constant from'crocks/combinators/constant' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import map from'crocks/pointfree/map' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // double :: Number -> Number constdouble= x=> x *2 // gt10 :: Number -> Boolean constgt10= x=> x >10 // isValid :: a -> Async String Number const isValid =ifElse( and(isNumber, gt10), Resolved, constant(Rejected('Not Valid')) ) // doubleValid :: a -> Async String Number const doubleValid = compose(map(double), isValid) Resolved(34) .map(double) .fork(log('rej'),log('res')) //=> res: 68 Rejected('34') .map(double) .fork(log('rej'),log('res')) //=> rej: \"34\" doubleValid(76) .fork(log('rej'),log('res')) //=> res: 152 doubleValid('Too Silly') .fork(log('rej'),log('res')) //=> rej: \"Not Valid\" runkit "},{"title":"alt","type":1,"pageTitle":"Async","url":"docs/crocks/Async#alt","content":"Copy Async e a ~> Async e a -> Async e a Providing a means for a fallback or alternative value, alt combines two Async instances and will return the first Resolved instance it encounters or the last Rejected instance if it does not encounter a Resolved instance. Copy importAsyncfrom'crocks/Async' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) Resolved(true) .alt(Rejected('Bad News')) .fork(log('rej'),log('res')) //=> res: true Rejected('First Reject') .alt(Rejected('Second Reject')) .fork(log('rej'),log('res')) //=> rej: \"Second Reject\" Rejected('First Reject') .alt(Resolved('First Resolve')) .alt(Rejected('Second Reject')) .alt(Resolved('Second Resolve')) .fork(log('rej'),log('res')) //=> rej: \"First Resolve\" runkit "},{"title":"bimap","type":1,"pageTitle":"Async","url":"docs/crocks/Async#bimap","content":"Copy Async e a ~> ((e -> b), (a -> c)) -> Async b c Both Rejected and Resolved values can vary in their type, although most of the time, focus on mapping values is placed on the Resolved portion. When the requirement or need to map the Rejected portion arises, bimap can be used. bimap takes two functions as its arguments. The first function is used to map a Rejected instance, while the second maps a Resolved instance. While bimap requires that both possible instances are to be mapped, if the desire to map only the Rejected portion, an identity function can be provided to the second argument. This will leave all Resolved instance values untouched. Copy importAsyncfrom'crocks/Async' import setProp from'crocks/helpers/setProp' import bimap from'crocks/pointfree/bimap' import compose from'crocks/helpers/compose' import objOf from'crocks/helpers/objOf' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // hasError :: Boolean -> Object -> Object const hasError = setProp('hasError') // buildError :: a -> String constbuildError= x=>`${x}: is not valid` // buildResult :: (String, Boolean) -> a -> Object constbuildResult=(key, isError)=> compose(hasError(isError),objOf(key)) // finalize :: Bifunctor m => m a b -> m Object Object const finalize =bimap( compose(buildResult('error',true), buildError), buildResult('result',false) ) finalize(Resolved('Good To Go')) .fork(log('rej'),log('res')) //=> res: { result: \"Good To Go\", hasError: false } finalize(Rejected(null)) .fork(log('rej'),log('res')) //=> rej: { error: \"null is not valid\", hasError: true } runkit "},{"title":"ap","type":1,"pageTitle":"Async","url":"docs/crocks/Async#ap","content":"Copy Async e (a -> b) ~> Async e a -> Async e b Short for apply, ap is used to apply an Async instance containing a value to another Async instance that contains a function, resulting in new Async instance with the result. ap requires that it is called on an instance that is either Rejected or Resolved that wraps a curried polyadic function. When either Async is Rejected, ap will return a Rejected instance, that wraps the value of the original Rejected instance. This can be used to safely combine multiple values under a given combination function. If any of the inputs result in a Rejected than they will never be applied to the function and will not result in undesired exceptions or results. When forked, all Asyncs chained with multiple ap invocations will be executed concurrently. Copy importAsyncfrom'crocks/Async' import liftA2 from'crocks/helpers/liftA2' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // resolveAfter :: (Integer, a) -> Async e a constresolveAfter=(delay, x)=>Async( (rej, res)=>setTimeout(()=>res(x), delay) ) // join :: String -> String -> String constjoin= a=>b=>`${a}${b}` Async.of(join) .ap(Resolved('blip')) .ap(Resolved('blop')) .fork(log('rej'),log('res')) //=> res: \"blip blop\" Async.of(join) .ap(Resolved('blip')) .ap(Rejected('Not Good')) .fork(log('rej'),log('res')) //=> rej: \"Not Good\" Resolved('splish') .map(join) .ap(Resolved('splash')) .fork(log('rej'),log('res')) //=> res: \"splish splash\" // first :: Async e String const first = resolveAfter(5000,'first') // second :: Async e String const second = resolveAfter(5000,'second') // `ap` runs all Asyncs at the same time in parallel. // This will finish running in about 5 seconds and // not 10 seconds liftA2(join, first, second) .fork(log('rej'),log('res')) //=> res: \"first second\" runkit "},{"title":"chain","type":1,"pageTitle":"Async","url":"docs/crocks/Async#chain","content":"Copy Async e a ~> (a -> Async e b) -> Async e b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. chain expects a unary, Async returning function as its argument. When invoked on a Rejected instance, chain will not run the function, but will instead return another Rejected instance wrapping the original Rejected value. When called on a Resolved instance however, the inner value will be passed to provided function, returning the result as the new instance. Copy importAsyncfrom'crocks/Async' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import composeK from'crocks/helpers/composeK' import constant from'crocks/combinators/constant' import flip from'crocks/combinators/flip' import getProp from'crocks/Maybe/getProp' import ifElse from'crocks/logic/ifElse' import isString from'crocks/predicates/isString' import maybeToAsync from'crocks/Async/maybeToAsync' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // safe :: (b -> Boolean) -> b -> Async String a constsafe=pred=> ifElse(pred,Resolved,constant(Rejected('Not Safe'))) // test :: RegExp -> String -> Boolean consttest=regex=>str=> regex.test(str) // lookup :: String -> Async String String const lookup =compose( maybeToAsync('Not Found'), flip(getProp,{'file-a':'file-b','file-b':'file-c'}) ) // fake :: String -> Async String Object const fake =compose( chain(lookup), chain(safe(test(/^file-(a|b|c)/))), safe(isString) ) fake('file-a') .fork(log('rej'),log('res')) //=> file-b // getTwo :: a -> Async String String const getTwo = composeK(fake, fake) getTwo('file-a') .fork(log('rej'),log('res')) //=> res: file-c getTwo('file-b') .fork(log('rej'),log('res')) //=> rej: \"Not Found\" getTwo(76) .fork(log('rej'),log('res')) //=> rej: \"Not Safe\" runkit "},{"title":"coalesce","type":1,"pageTitle":"Async","url":"docs/crocks/Async#coalesce","content":"Copy Async e a ~> ((e -> b), (a -> b))) -> Async e b Used as a means to apply a computation to a Resolved instance and then map any Rejected value while transforming it to a Resolved to continue computation. coalesce on an Async can be used to model the all too familiar, and more imperative if/else flow in a more declarative manner. The first function is used when invoked on a Rejected instance and will return a Resolved instance wrapping the result of the function. The second function is used when coalesce is invoked on a Resolved instance and is used to map the original value, returning a new Resolved instance wrapping the result of the second function. Copy importAsyncfrom'crocks/Async' import coalesce from'crocks/pointfree/coalesce' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // label :: String -> String -> String constlabel= lbl=>x=>`${lbl}${x}` // resolve :: Async e String -> Async e String const resolve = coalesce(label('Was'),label('Still')) resolve(Resolved('Resolved')) .fork(log('rej'),log('res')) //=> res: \"Still Resolved\" resolve(Rejected('Rejected')) .fork(log('rej'),log('res')) //=> res: \"Was Rejected\" runkit "},{"title":"bichain","type":1,"pageTitle":"Async","url":"docs/crocks/Async#bichain","content":"Copy Async e a ~> ((e -> Async b c), (a -> Async b c)) -> Async b c Combining a sequential series of transformations that capture disjunction can be accomplished with chain. Along the same lines, bichain allows you to do this from both Rejected and Resolved. bichain expects two unary, Async returning functions as its arguments. When invoked on a Rejected instance, bichain will use the left, or first, function that can return either a Rejected or Resolved instance. When called on a Resolved instance, it will behave exactly as chain would with the right, or second function. Copy import bichain from'crocks/pointfree/bichain' importAsyncfrom'crocks/Async' import equals from'crocks/pointfree/equals' import maybeToAsync from'crocks/Async/maybeToAsync' import propSatisfies from'crocks/predicates/propSatisfies' import safe from'crocks/Maybe/safe' import substitution from'crocks/combinators/substitution' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) constfork=m=> m.fork(log('rej'),log('res')) fork( bichain(Resolved,Rejected,Resolved(42)) ) //=> rej: 42 fork( bichain(Resolved,Rejected,Rejected(42)) ) //=> res: 42 // fake401 :: Async Response a const fake401 =Rejected({ status:'Unauthorized', statusCode:401 }) // fake500 :: Async Response a const fake500 =Rejected({ status:'Internal Server Error', statusCode:500 }) // fake200 :: Async e Response const fake200 =Resolved({ status:'OK', statusCode:200 }) // allow401 :: Response -> Async e a const allow401 =substitution( maybeToAsync, safe(propSatisfies('statusCode',equals(401))) ) fork(bichain(allow401,Resolved, fake500)) //=> rej: { status: 'Internal Server Error', statusCode: 500 } fork(bichain(allow401,Resolved, fake401)) //=> res: { status: 'Unauthorized', statusCode: 401 } fork(bichain(allow401,Resolved, fake200)) //=> res: { status: 'OK', statusCode: 200 } runkit "},{"title":"swap","type":1,"pageTitle":"Async","url":"docs/crocks/Async#swap","content":"Copy Async e a ~> ((e -> b), (a -> c)) -> Async c b Used to map the value of a Rejected into a Resolved or a Resolved to a Rejected, swap takes two functions as its arguments. The first function is used to map the expected Rejected value into a Resolved, while the second goes from Resolved to Rejected. If no mapping is required on either, then identity functions can be used in one or both arguments. Copy importAsyncfrom'crocks/Async' import compose from'crocks/helpers/compose' import identity from'crocks/combinators/identity' import swap from'crocks/pointfree/swap' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // length :: String -> Integer constlength= x=> x.length // repeat :: String -> Number -> String constrepeat= char=>n=> char.repeat(n) // values :: Async String Number -> Async String Number const values = swap(length,repeat('a')) // valueIso :: Async String Number -> Async String Number const valueIso = compose(values, values) // types :: Async a b -> b a const types = swap(identity, identity) // typeIso :: Async a b -> b a const typeIso = compose(types, types) values(Resolved(5)) .fork(log('rej'),log('res')) //=> rej: \"aaaaa\" values(Rejected('aaaaa')) .fork(log('rej'),log('res')) //=> res: 5 valueIso(Resolved(5)) .fork(log('rej'),log('res')) //=> res: 5 valueIso(Rejected('aaaaa')) .fork(log('rej'),log('res')) //=> rej: \"aaaaa\" types(Resolved(5)) .fork(log('rej'),log('res')) //=> rej: 5 types(Rejected('aaaaa')) .fork(log('rej'),log('res')) //=> res: \"aaaaa\" typeIso(Resolved(5)) .fork(log('rej'),log('res')) //=> res: 5 typeIso(Rejected('aaaaa')) .fork(log('rej'),log('res')) //=> rej: \"aaaaa\" runkit "},{"title":"race","type":1,"pageTitle":"Async","url":"docs/crocks/Async#race","content":"Copy Async e a ~> Async e a -> Async e a Used to provide the first settled result between two Asyncs. Just pass race another Async and it will return new Async, that when forked, will run both Asyncs in parallel, returning the first of the two to settle. The result can either be rejected or resolved, based on the instance of the first settled result. Copy importAsyncfrom'../crocks/src/Async' const{ resolveAfter, rejectAfter }=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) resolveAfter(300,'I win') .race(resolveAfter(400,'I lose')) .fork(log('rejected'),log('resolved')) //=> resolved: \"I win\" rejectAfter(500,'I lose') .race(rejectAfter(300,'I win')) .fork(log('rejected'),log('resolved')) //=> rejected: \"I win\" resolveAfter(500,'I lose') .race(rejectAfter(300,'I win')) .fork(log('rejected'),log('resolved')) //=> rejected: \"I win\" runkit "},{"title":"fork","type":1,"pageTitle":"Async","url":"docs/crocks/Async#fork","content":"Copy Async e a ~> ((e -> ()), (a -> ())) -> (() -> ()) Async e a ~> ((e -> ()), (a -> ()), (() -> ())) -> (() -> ()) The Async type is lazy and will not be executed until told to do so and fork is the primary method used for execution. fork implements two signatures depending on the need for clean up in the event of cancellation, but both return a function that can be used for cancellation of a given instance. The first and more common signature takes two functions that will have their return values ignored. The first function will be run in the event of the Async instance settling on Rejected and will receive as its single argument the value or \"cause\" of rejection. The second function provided will be executed in the case of the instance settling on Resolved and will receive as its single argument the value the Async was resolved with. The second signature is used when any cleanup needs to be performed after a given Async is canceled by having the function returned from fork called. The first two arguments to the signature are the same as the more common signature described above, but takes an addition function that can be used for \"clean up\" after cancellation. When all in-flight computations settle, the function provided will be silently executed. Copy importAsyncfrom'crocks/Async' import compose from'crocks/helpers/compose' // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // inc :: Number -> Number constinc= n=> n +1 // delay :: a -> Async e a constdelay=x=>Async( (rej, res)=>{setTimeout(()=>res(x),1000)} ).map(compose(inc,log('value'))) delay(0) .chain(delay) .chain(delay) .fork(log('rej'),log('res')) //=> value: 0 //=> value: 1 //=> value: 2 //=> res: 3 const cancel = delay(0) .chain(delay) .chain(delay) .fork(log('rej'),log('res')) //=> value: 0 //=> value: 1 setTimeout(cancel,2200) runkit "},{"title":"toPromise","type":1,"pageTitle":"Async","url":"docs/crocks/Async#topromise","content":"Copy Async e a ~> () -> Promise a e While fork is the more common method for running an Async instance, there may come time where a Promise is needed at the edge of a given program or flow. When the need to integrate into an existing Promise chain arises, Async provides the toPromise method. toPromise takes no arguments and when invoked will fork the instance internally and return a Promise that will be in-flight. This comes in handy for integration with other Promise based libraries that are utilized in a given application, program or flow. Copy importAsyncfrom'crocks/Async' const{Rejected,Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) Resolved('resolved') .toPromise() .then(log('res')) .catch(log('rej')) //=> res: resolved Rejected('rejected') .toPromise() .then(log('res')) .catch(log('rej')) //=> rej: rejected runkit "},{"title":"Pointfree Functions","type":1,"pageTitle":"Async","url":"docs/crocks/Async#pointfree-functions","content":""},{"title":"race (pointfree)","type":1,"pageTitle":"Async","url":"docs/crocks/Async#race-pointfree","content":"crocks/Async/race Copy race :: Async e a -> Async e a -> Async e a The race pointfree function accepts two Async instances and will return a new Async instance that is the result of applying the first argument to the race method on the second passed instance. Copy import race from'crocks/Async/race' importAsyncfrom'crocks/Async' const{ resolveAfter, rejectAfter }=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // timeout :: Async Error a -> Async Error a const timeout = race(rejectAfter(300,newError('Request has timed out'))) // fast :: Async e String const fast = resolveAfter(150,'All good') // slow :: Async e Boolean const slow = resolveAfter(900,true) timeout(fast) .fork(log('rejected'),log('resolved')) //=> resolved: \"All good\" timeout(slow) .fork(log('rejected'),log('resolved')) //=> rejected: \"Error: Request has timed out\" runkit "},{"title":"Transformation Functions","type":1,"pageTitle":"Async","url":"docs/crocks/Async#transformation-functions","content":""},{"title":"asyncToPromise","type":1,"pageTitle":"Async","url":"docs/crocks/Async#asynctopromise","content":"crocks/Async/asyncToPromise Copy asyncToPromise :: Async e a -> Promise a e asyncToPromise :: (a -> Async e b) -> a -> Promise b e The asyncToPromise function takes an Async and when invoked will fork the instance internally and return a Promise that will be in-flight. This comes in handy for integration with other Promise based libraries that are utilized in a given application, program or flow through composition. Copy importAsyncfrom'crocks/Async' import race from'crocks/Async/race' import asyncToPromise from'crocks/Async/asyncToPromise' import ifElse from'crocks/logic/ifElse' import compose from'crocks/helpers/compose' import isPromise from'crocks/pointfree/isPromise' const{ resolveAfter, rejectAfter }=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // logIt :: Promise a e -> Promise a e constlogIt=p=> p.then(log('resolved'),log('rejected')) const logResult = compose(logIt,ifElse(isPromise,x=> x, asyncToPromise)) const failingPromise = newPromise((resolve, reject)=>setTimeout(()=>reject('Promise rejected!'),300)) // timeout :: Async Error a -> Async Error a const timeout = race(rejectAfter(300,newError('Request has timed out'))) // fast :: Async e String const fast = resolveAfter(150,'All good') // slow :: Async e Boolean const slow = resolveAfter(900,true) logResult(timeout(fast)) //=> resolved: \"All good\" logResult(timeout(slow)) //=> rejected: \"Error: Request has timed out\" logResult(failingPromise) //=> rejected: \"Promise rejected!\" runkit "},{"title":"eitherToAsync","type":1,"pageTitle":"Async","url":"docs/crocks/Async#eithertoasync","content":"crocks/Async/eitherToAsync Copy eitherToAsync :: Either b a -> Async b a eitherToAsync :: (a -> Either c b) -> a -> Async c b Used to transform a given Either instance to an Async instance or flatten an Async of Either into an Async when chained, eitherToAsync will turn a Right instance into a Resolved instance wrapping the original value contained in the original Right. If aLeft is provided, then eitherToAsync will return aRejected instance, wrapping the original Left value. Like all crocks transformation functions, eitherToAsync has two possible signatures and will behave differently when passed an Either instance or a function that returns an instance of Either. When passed the instance, a transformed Async is returned. When passed an Either returning function, a function will be returned that takes a given value and returns an Async. Copy importAsyncfrom'crocks/Async' importEitherfrom'crocks/Either' import eitherToAsync from'crocks/Async/eitherToAsync' import and from'crocks/logic/and' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' const{Resolved}=Async const{Left,Right}=Either // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // gte :: Number -> Number -> Boolean constgte= x=>y=> y >= x // isLarge :: a -> Boolean const isLarge = and(isNumber,gte(10)) // isValid :: a -> Either String a const isValid =ifElse( isLarge, Right, x=>Left(`${x} is not valid`) ) eitherToAsync(Right('Correct')) .fork(log('rej'),log('res')) //=> res: \"Correct\" eitherToAsync(Left('Not Good')) .fork(log('rej'),log('res')) //=> rej: \"Not Good\" Resolved(54) .chain(eitherToAsync(isValid)) .fork(log('rej'),log('res')) //=> res: 54 Resolved(4) .chain(eitherToAsync(isValid)) .fork(log('rej'),log('res')) //=> rej: \"4 is not valid\" Resolved('Bubble') .chain(eitherToAsync(isValid)) .fork(log('rej'),log('res')) //=> rej: \"Bubble is not valid\" Resolved(Left('Alone')) .chain(eitherToAsync) .fork(log('rej'),log('res')) //=> rej: \"Alone\" Resolved(Right('Away')) .chain(eitherToAsync) .fork(log('rej'),log('res')) //=> res: \"Away\" runkit "},{"title":"firstToAsync","type":1,"pageTitle":"Async","url":"docs/crocks/Async#firsttoasync","content":"crocks/Async/firstToAsync Copy firstToAsync :: e -> First a -> Async e a firstToAsync :: e -> (a -> First b) -> a -> Async e b Used to transform a given First instance to an Async instance or flatten an Async of First into an Async when chained, firstToAsync will turn a non-empty First instance into a Resolvedinstance wrapping the original value contained in the original non-empty. The First datatype is based on a Maybe and as such its left or empty value is fixed to a () type. As a means to allow for convenient transformation, firstToAsync takes a default Rejected value as the first argument. This value will be wrapped in a resulting Rejected instance in the case of empty. Like all crocks transformation functions, firstToAsync has two possible signatures and will behave differently when passed either a First instance or a function that returns an instance of First. When passed the instance, a transformed Async is returned. When passed a First returning function, a function will be returned that takes a given value and returns an Async. Copy importAsyncfrom'crocks/Async' importFirstfrom'crocks/First' import firstToAsync from'crocks/Async/firstToAsync' importPredfrom'crocks/Pred' import isString from'crocks/predicates/isString' import mconcatMap from'crocks/helpers/mconcatMap' import safe from'crocks/Maybe/safe' const{Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // length :: String -> Number constlength= x=> x.length // gte :: Number -> Number -> Boolean constgte= x=>y=> y >= x // isValid :: Pred String const isValid = Pred(isString) .concat(Pred(gte(4)).contramap(length)) // firstValid :: [ String ] -> First String const firstValid = mconcatMap(First,safe(isValid)) // findFirstValid :: [ String ] -> Async String String const findFirstValid = firstToAsync('Nothing Found', firstValid) firstToAsync('Error',First(true)) .fork(log('rej'),log('res')) //=> res: true firstToAsync('Error',First.empty()) .fork(log('rej'),log('res')) //=> rej: \"Error\" Resolved(['cat','rhino','unicorn']) .chain(findFirstValid) .fork(log('rej'),log('res')) //=> res: \"rhino\" Resolved([1,2,3]) .chain(findFirstValid) .fork(log('rej'),log('res')) //=> rej: \"Nothing Found\" Resolved(['cat','bat','imp']) .chain(findFirstValid) .fork(log('rej'),log('res')) //=> rej: \"Nothing Found\" Resolved(First.empty()) .chain(firstToAsync('Left')) .fork(log('rej'),log('res')) //=> rej: \"Left\" Resolved(First(42)) .chain(firstToAsync('Left')) .fork(log('rej'),log('res')) //=> res: 42 runkit "},{"title":"lastToAsync","type":1,"pageTitle":"Async","url":"docs/crocks/Async#lasttoasync","content":"crocks/Async/lastToAsync Copy lastToAsync :: e -> Last a -> Async e a lastToAsync :: e -> (a -> Last b) -> a -> Async e b Used to transform a given Last instance to an Async instance or flatten an Async of Last into an Async when chained, lastToAsync will turn a non-empty Last instance into a Resolvedinstance wrapping the original value contained in the original non-empty. The Last datatype is based on a Maybe and as such its left or empty value is fixed to a () type. As a means to allow for convenient transformation, lastToAsync takes a default Rejected value as the first argument. This value will be wrapped in a resulting Rejected instance, in the case of empty. Like all crocks transformation functions, lastToAsync has two possible signatures and will behave differently when passed either a Last instance or a function that returns an instance of Last. When passed the instance, a transformed Async is returned. When passed a Last returning function, a function will be returned that takes a given value and returns an Async. Copy importAsyncfrom'crocks/Async' importLastfrom'crocks/Last' import lastToAsync from'crocks/Async/lastToAsync' importPredfrom'crocks/Pred' import isString from'crocks/predicates/isString' import mconcatMap from'crocks/helpers/mconcatMap' import safe from'crocks/Maybe/safe' const{Resolved}=Async // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // length :: String -> Number constlength= x=> x.length // gte :: Number -> Number -> Boolean constgte= x=>y=> y >= x // isValid :: Pred String const isValid = Pred(isString) .concat(Pred(gte(4)).contramap(length)) // lastValid :: [ String ] -> Last String const lastValid = mconcatMap(Last,safe(isValid)) // findLastValid :: [ String ] -> Async String String const findLastValid = lastToAsync('Nothing Found', lastValid) lastToAsync('Error',Last(true)) .fork(log('rej'),log('res')) //=> res: true lastToAsync('Error',Last.empty()) .fork(log('rej'),log('res')) //=> rej: \"Error\" Resolved(['unicorn','rhino','cat']) .chain(findLastValid) .fork(log('rej'),log('res')) //=> res: \"rhino\" Resolved([1,2,3]) .chain(findLastValid) .fork(log('rej'),log('res')) //=> rej: \"Nothing Found\" Resolved(['cat','bat','imp']) .chain(findLastValid) .fork(log('rej'),log('res')) //=> rej: \"Nothing Found\" Resolved(Last.empty()) .chain(lastToAsync('Left')) .fork(log('rej'),log('res')) //=> rej: \"Left\" Resolved(Last('too know!')) .chain(lastToAsync('Left')) .fork(log('rej'),log('res')) //=> res: \"too know!\" runkit "},{"title":"maybeToAsync","type":1,"pageTitle":"Async","url":"docs/crocks/Async#maybetoasync","content":"crocks/Async/maybeToAsync Copy maybeToAsync :: e -> Maybe a -> Async e a maybeToAsync :: e -> (a -> Maybe b) -> a -> Async e b Used to transform a given Maybe instance to an Async instance or flatten an Async of Maybe into an Async when chained, maybeToAsync will turn a Just instance into a Resolved instance wrapping the original value contained in the original Just. A Nothing instance is fixed to a () type and as such can only ever contain a value of undefined. As a means to allow for convenient transformation, maybeToAsync takes a default Rejected value as the first argument. This value will be wrapped in a resulting Rejected instance, in the case of Nothing. Like all crocks transformation functions, maybeToAsync has two possible signatures and will behave differently when passed either a Maybe instance or a function that returns an instance of Maybe. When passed the instance, a transformed Async is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns an Async. Copy importAsyncfrom'crocks/Async' importMaybefrom'crocks/Maybe' import maybeToAsync from'crocks/Async/maybeToAsync' import and from'crocks/logic/and' import isEmpty from'crocks/predicates/isEmpty' import isArray from'crocks/predicates/isArray' import not from'crocks/logic/not' import safe from'crocks/Maybe/safe' const{Resolved}=Async const{Nothing,Just}=Maybe // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // isValid :: a -> Maybe [ b ] const isValid =safe( and(isArray,not(isEmpty)) ) maybeToAsync(false,Just(true)) .fork(log('rej'),log('res')) //=> res: true maybeToAsync('Bad',Nothing()) .fork(log('rej'),log('res')) //=> rej: \"Bad\" Resolved(['a','b','c']) .chain(maybeToAsync('Invalid', isValid)) .fork(log('rej'),log('res')) //=> res: [ 'a', 'b', 'c' ] Resolved([]) .chain(maybeToAsync('Invalid', isValid)) .fork(log('rej'),log('res')) //=> rej: \"Invalid\" Resolved('') .chain(maybeToAsync('Invalid', isValid)) .fork(log('rej'),log('res')) //=> rej: \"Invalid\" Resolved(Nothing()) .chain(maybeToAsync('Left')) .fork(log('rej'),log('res')) //=> rej: \"Left\" Resolved(Just('the 2 of us')) .chain(maybeToAsync('Left')) .fork(log('rej'),log('res')) //=> res: \"the 2 of us\" runkit "},{"title":"resultToAsync","type":1,"pageTitle":"Async","url":"docs/crocks/Async#resulttoasync","content":"crocks/Async/resultToAsync Copy resultToAsync :: Result b a -> Async b a resultToAsync :: (a -> Result c b) -> a -> Async c b Used to transform a given Result instance to an Async instance or flatten an Async of Result into an Async when chained, resultToAsync will turn an Ok instance into a Resolved instance wrapping the original value contained in the original Ok. If an Err is provided, then resultToAsync will return a Rejected instance, wrapping the original Err value. Like all crocks transformation functions, resultToAsync has two possible signatures and will behave differently when passed either a Result instance or a function that returns an instance of Result. When passed the instance, a transformed Async is returned. When passed a Result returning function, a function will be returned that takes a given value and returns an Async. Copy importAsyncfrom'crocks/Async' importResultfrom'crocks/Result' import resultToAsync from'crocks/Async/resultToAsync' import identity from'crocks/combinators/identity' import isNumber from'crocks/predicates/isNumber' import tryCatch from'crocks/Result/tryCatch' const{Resolved}=Async const{Err,Ok}=Result // log :: String -> a -> a constlog=label=>x=> (console.log(`${label}:`, x), x) // notNumber :: a -> Number functionnotNumber(x){ if(!isNumber(x)){ thrownewTypeError('Must be a Number') } return x } // safeFail :: a -> Result TypeError Number const safeFail = tryCatch(notNumber) resultToAsync(Ok(99)) .fork(log('rej'),log('res')) //=> res: 99 resultToAsync(Err('Not Good')) .fork(log('rej'),log('res')) //=> rej: \"Not Good\" Resolved(103) .chain(resultToAsync(safeFail)) .bimap(x=> x.message, identity) .fork(log('rej'),log('res')) //=> res: 103 Resolved('103') .chain(resultToAsync(safeFail)) .bimap(x=> x.message, identity) .fork(log('rej'),log('res')) //=> rej: \"Must be a Number\" Resolved(Err('Invalid entry')) .chain(resultToAsync) .fork(log('rej'),log('res')) //=> rej: \"Invalid entry\" Resolved(Ok('Success!')) .chain(resultToAsync) .fork(log('rej'),log('res')) //=> res: \"Success!\" runkit "},{"title":"Any","type":0,"sectionRef":"#","url":"docs/monoids/Any","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Any","url":"docs/monoids/Any#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"Any","url":"docs/monoids/Any#construction","content":"Copy Any :: a -> Any Boolean Any is constructed by calling the constructor with any type a. This will return an Any wrapping the provided value, coerced to a Boolean. For example, providing an non-empty String will result in an Any(true). While passing an empty String results in an Any(false). Copy importAnyfrom'crocks/Any' Any(0) //=> Any(false) Any(1) //=> Any(true) Any([]) //=> Any(true) runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Any","url":"docs/monoids/Any#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Any","url":"docs/monoids/Any#empty","content":"Copy Any.empty :: () -> Any empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Any the result of empty is false. empty is available on both the Constructor and the Instance for convenience. Copy importAnyfrom'crocks/Any' Any.empty()//=> Any false Any(true).concat(Any.empty())//=> Any true Any(false).concat(Any.empty())//=> Any false runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Any","url":"docs/monoids/Any#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Any","url":"docs/monoids/Any#equals","content":"Copy Any a ~> b -> Boolean Used to compare the underlying values of (2) Any instances for equality by value, equals takes any given argument and returns true if the passed argument is an Any with an underlying value equal to the underlying value of the Any the method is being called on. If the passed argument is not an Any or the underlying values are not equal, equals will return false. Copy importAnyfrom'crocks/Any' Any(true) .equals(Any(true)) //=> true Any(true) .equals(Any(false)) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Any","url":"docs/monoids/Any#concat","content":"Copy Any ~> Any -> Any concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Any, it will combine the (2) using logical OR (disjunction). Copy importAnyfrom'crocks/Any' Any(true).concat(Any(true))//=> Any true Any(true).concat(Any(false))//=> Any true Any(false).concat(Any(true))//=> Any true Any(false).concat(Any(false))//=> Any false runkit "},{"title":"valueOf","type":1,"pageTitle":"Any","url":"docs/monoids/Any#valueof","content":"Copy Any ~> () -> Boolean valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Any instance will result in the underlying Boolean value. Copy importAnyfrom'crocks/Any' Any(0).valueOf()//=> false Any('string').valueOf()//=> true //=> true Any(45) .concat('') .valueOf() runkit "},{"title":"Logic Functions","type":0,"sectionRef":"#","url":"docs/functions/logic-functions","content":"","keywords":""},{"title":"and","type":1,"pageTitle":"Logic Functions","url":"docs/functions/logic-functions#and","content":"Copy and :: ((a -> Boolean) | Pred a) -> ((a -> Boolean) | Pred a) -> a -> Boolean Say you have two predicate functions or Preds and would like to combine them into one predicate over conjunction, well you came to the right place, and accepts either predicate functions or Preds and will return you a function ready to take a value. Once that value is passed, it will run it through both of the predicates and return the result of combining it over a logical and. This is super helpful when combined with or for putting together reusable, complex predicates. As they follow the general form of (a -> Boolean) they are easily combined with other logic functions. Copy // p | q | p && q // ================ // T | T | T // T | F | F // F | T | F // F | F | F import and from'crocks/logic/and' import constant from'crocks/combinators/constant' import isArray from'crocks/predicates/isArray' import isEmpty from'crocks/predicates/isEmpty' import isNumber from'crocks/predicates/isNumber' import not from'crocks/logic/not' // gte :: Number -> Number -> Boolean constgte=x=>y=> y >= x // isLegalDrinkingAge :: Number -> Boolean const isLegalDrinkingAge = and(isNumber,gte(21)) // isValid :: a -> Boolean const isValid = and(isArray,not(isEmpty)) isLegalDrinkingAge(18) //=> false isLegalDrinkingAge(21) //=> true isValid([42]) //=> true isValid(null) //=> false isValid([]) //=> false and(constant(true),constant(true),'ignored') //=> true and(constant(true),constant(false),'ignored') //=> false and(constant(false),constant(true),'ignored') //=> false and(constant(false),constant(false),'ignored') //=> false runkit "},{"title":"ifElse","type":1,"pageTitle":"Logic Functions","url":"docs/functions/logic-functions#ifelse","content":"Copy ifElse :: ((a -> Boolean) | Pred a) -> (a -> b) -> (a -> b) -> a -> b Whenever you need to modify a value based some condition and want a functional way to do it without some imperative if statement, then reach for ifElse. This function take a predicate (some function that returns a Boolean) and two functions. The first is what is executed when the predicate is true, the second on a false condition. This will return a function ready to take a value to run through the predicate. After the value is evaluated, it will be ran through it's corresponding function, returning the result as the final result. This function comes in really handy when creating lifting functions for Sum Types (like Either or Maybe). Copy import ifElse from'crocks/logic/ifElse' importMaybefrom'crocks/Maybe' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import identity from'crocks/combinators/identity' import isArray from'crocks/predicates/isArray' import isNumber from'crocks/predicates/isNumber' const{Just,Nothing}=Maybe // safe :: (a -> Boolean) -> a -> Maybe a constsafe=pred=> ifElse(pred,Just,Nothing) // gte :: Number -> Number -> Maybe Number constgte=x=> safe(n=> n >= x) // isLarge :: a -> Maybe a const isLarge = compose(chain(gte(42)),safe(isNumber)) // ensureArray :: a -> Array const ensureArray = ifElse(isArray, identity,()=>[]) isLarge(10) //=> Nothing isLarge(44) //=> Just 44 ensureArray('nope') .map(x=> x + x) //=> [] ensureArray([3]) .map(x=> x + x) //=> [ 6 ] runkit "},{"title":"implies","type":1,"pageTitle":"Logic Functions","url":"docs/functions/logic-functions#implies","content":"Copy implies :: ((a -> Boolean) | Pred a) -> ((a -> Boolean) | Pred a) -> a -> Boolean implies is a logic combinator that will combine the evaluation of two predicates over logical implication. It takes any combination of predicate functions or Preds as its first two arguments and will return a new predicate function that will return false when the first predicate evaluates to true and the second evaluates to false. All other combinations will return true. Implication is a very weak condition in regards to assertion of a value and is usually paired with disjunction over conjunction for types like Pred and the AllMonoid. Copy // p | q | p -> q // ================ // T | T | T // T | F | F // F | T | T // F | F | T import implies from'crocks/logic/implies' importPredfrom'crocks/Pred' import isArray from'crocks/predicates/isArray' import isString from'crocks/predicates/isString' import not from'crocks/logic/not' import or from'crocks/logic/or' import safe from'crocks/Maybe/safe' // length :: (String | Array) -> Number constlength=x=> x.length // stringOrArray :: a -> Pred a const stringOrArray = Pred(or(isArray, isString)) // stringLength :: a -> Pred a const stringLength = Pred(implies(isString, length)) // emptyArray :: a -> Pred a const emptyArray = Pred(implies(isArray,not(length))) stringOrArray .runWith('') //=> true stringOrArray .runWith([1,2,3]) //=> true stringOrArray .runWith(23) //=> false stringLength .runWith('') //=> false stringLength .runWith('with length') //=> true stringLength .runWith([1,3]) //=> true emptyArray .runWith([1,3]) //=> false emptyArray .runWith([]) //=> true emptyArray .runWith(23) //=> true // pred :: a -> Pred a const pred = stringOrArray .concat(stringLength) .concat(emptyArray) // isValid :: a -> Maybe (String | Array) const isValid = safe(pred) isValid(34) //=> Nothing isValid([1,3]) //=> Nothing isValid('') //=> Nothing isValid([]) //=> Just [] isValid('valid') //=> Just \"valid\" runkit "},{"title":"not","type":1,"pageTitle":"Logic Functions","url":"docs/functions/logic-functions#not","content":"Copy not :: ((a -> Boolean) | Pred) -> a -> Boolean When you need to negate a predicate function or a Pred, but want a new predicate function that does the negation, then not is going to get you what you need. Using not will allow you to stay as declarative as possible. Just pass not your predicate function or a Pred, and it will give you back a predicate function ready for insertion into your flow. All predicate based functions in crocks take either a Pred or predicate function, so it should be easy to swap between the two. Copy // p | !p // ======== // T | F // F | T import not from'crocks/logic/not' importPredfrom'crocks/Pred' import and from'crocks/logic/and' import compose from'crocks/helpers/compose' import flip from'crocks/combinators/flip' import identity from'crocks/combinators/identity' import isString from'crocks/predicates/isString' import propSatisfies from'crocks/predicates/propSatisfies' // isFalsy :: a -> Boolean const isFalsy = not(identity) // isTruthy :: a -> Boolean const isTruthy = not(isFalsy) isTruthy('Test string') //=> true isTruthy('') //=> false isFalsy('') //=> true isFalsy('Test string') //=> false // User :: { email: String, firstName: String, lastName: String} // validUser :: User const validUser ={ email:'testuser@email.com', firstName:'Tom', lastName:'Smith' } // invalidUser :: User const invalidUser ={ email:'', firstName:'', lastName:'Smith' } // isNonEmptyString :: a -> Boolean const isNonEmptyString = and(isString, isTruthy) // hasValidStringProp :: String -> User -> Boolean const hasValidStringProp =compose( Pred, flip(propSatisfies, isNonEmptyString) ) // hasName :: User -> Boolean const hasName = hasValidStringProp('firstName') // hasEmail :: User -> Boolean const hasEmail = hasValidStringProp('email') // isUserInvalid :: User -> Boolean const isUserInvalid = Pred(not(hasName)) .concat(Pred(not(hasEmail))) isUserInvalid .runWith(invalidUser) //=> true isUserInvalid .runWith(validUser) //=> false runkit "},{"title":"or","type":1,"pageTitle":"Logic Functions","url":"docs/functions/logic-functions#or","content":"Copy or :: ((a -> Boolean) | Pred) -> ((a -> Boolean) | Pred) -> a -> Boolean Say you have two predicate functions or Preds and would like to combine them into one predicate over disjunction, look no further, or accepts either predicate functions or Preds and will return you a function ' ready to take a value. Once that value is passed, it will run it through both of the predicates and return the result of combining it over a logical or. This is super helpful when combined with and for putting together reusable, complex predicates. As they follow the general form of (a -> Boolean) they are easily combined with other logic functions. Copy // p | q | p || q // ================ // T | T | T // T | F | T // F | T | T // F | F | F import or from'crocks/logic/or' import constant from'crocks/combinators/constant' import isEmpty from'crocks/predicates/isEmpty' import not from'crocks/logic/not' import propSatisfies from'crocks/predicates/propSatisfies' import pathSatisfies from'crocks/predicates/pathSatisfies' or(constant(true),constant(true),'ignored') //=> true or(constant(true),constant(false),'ignored') //=> true or(constant(false),constant(true),'ignored') //=> true or(constant(false),constant(false),'ignored') //=> false // Response :: { error: String, response: { users: [ * ] } } // createResponse :: ([ * ], String) -> Response const createResponse =(users, error ='')=>({ error, response:{ users } }) // hasData :: Response -> Boolean const hasData =or( propSatisfies('error', isEmpty), pathSatisfies(['response','users'],not(isEmpty)) ) hasData(createResponse([{ name:'User 1'}])) //=> true hasData(createResponse([],'No users found')) //=> false runkit "},{"title":"unless","type":1,"pageTitle":"Logic Functions","url":"docs/functions/logic-functions#unless","content":"Copy unless :: ((a -> Boolean) | Pred) -> (a -> a) -> a -> a There may come a time when you need to adjust a value when a condition is false, that is where unless can come into play. Just provide a predicate function (a function that returns a Boolean) and a function to apply your desired modification. This will get you back a function that when you pass it a value, it will evaluate it and if false, will run your value through the provided function. Either the original or modified value will be returned depending on the result of the predicate. Check out when for a negated version of this function. Copy import unless from'crocks/logic/unless' import constant from'crocks/combinators/constant' import flip from'crocks/combinators/flip' import isString from'crocks/predicates/isString' // double :: Number -> Number constdouble=a=> a *2 // doubleUnless :: (a -> Boolean) -> Number -> Number const doubleUnless = flip(unless, double) doubleUnless(constant(true),21) //=> 21 doubleUnless(constant(false),21) //=> 42 // toString :: a -> String consttoString=x=> x.toString() // ensureString :: a -> String const ensureString = unless(isString, toString) // testData :: [ * ] const testData = [1,2,'3',4,true,false,newDate(1770,3,29)] testData.map(ensureString) //=> [ '1', '2', '3', '4', 'true', 'false', 'Sun Apr 29 1770 00:00:00 GMT-0752 (Pacific Daylight Time)' ] runkit "},{"title":"when","type":1,"pageTitle":"Logic Functions","url":"docs/functions/logic-functions#when","content":"Copy when :: ((a -> Boolean) | Pred) -> (a -> a) -> a -> a There may come a time when you need to adjust a value when a condition is true, that is where when can come into play. Just provide a predicate function (a function that returns a Boolean) and a function to apply your desired modification. This will get you back a function that when you pass it a value, it will evaluate it and if true, will run your value through the provided function. Either the original or modified value will be returned depending on the result of the predicate. Check out unless for a negated version of this function. Copy import when from'crocks/logic/when' import compose from'crocks/helpers/compose' import composeB from'crocks/combinators/composeB' import constant from'crocks/combinators/constant' import curry from'crocks/helpers/curry' import flip from'crocks/combinators/flip' import mapProps from'crocks/helpers/mapProps' // gt :: Number -> Number -> Boolean constgt=a=>b=> b > a // subtract :: Number -> Number constsubtract=a=>b=> b - a // protectedSubtract :: Number -> Number -> Number const protectedSubtract =curry( composeB(when(gt(0)),subtract) ) protectedSubtract(10,30) //=> 20 protectedSubtract(10,-5) //=> -5 // smallExplosion :: Number -> Number const smallExplosion = protectedSubtract(15) // largeExplosion :: Number -> Number const largeExplosion =compose( smallExplosion, smallExplosion, smallExplosion ) // Player :: { health: Number } // player :: Player const player ={ health:30 } // affectHealth :: (Number -> Number) -> Player -> Player const affectHealth =curry( fn=>mapProps({ health: fn }) ) affectHealth(smallExplosion, player) //=> { health: 15 } affectHealth(largeExplosion, player) //=> { health: 0 } // double :: Number -> Number constdouble=a=> a *2 // doubleWhen :: (a -> Boolean) -> Number -> Number const doubleWhen = flip(when, double) doubleWhen(constant(true),21) //=> 42 doubleWhen(constant(false),21) //=> 21 runkit "},{"title":"Assign","type":0,"sectionRef":"#","url":"docs/monoids/Assign","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Assign","url":"docs/monoids/Assign#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"Assign","url":"docs/monoids/Assign#construction","content":"Copy Assign :: Object -> Assign Object Assign is constructed by calling the constructor with an Object instance. This will return a new Assign instance, wrapping the reference to the provided Object. Copy importAssignfrom'crocks/Assign' Assign({ a:123, b:false}) //=> Assign({ a: 123, b: false }) runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Assign","url":"docs/monoids/Assign#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Assign","url":"docs/monoids/Assign#empty","content":"Copy Assign.empty :: () -> Assign empty provides the identity for the Monoid in that when the value it provides is concated to object other value, it will return the other value. In the case of Assign the result of empty is an empty Object. empty is available on both the Constructor and the Instance for convenience. Copy importAssignfrom'crocks/Assign' Assign.empty() //=> Assign {} Assign({}) .concat(Assign.empty()) //=> Assign {} Assign({ a:1}) .concat(Assign.empty()) //=> Assign { a: 1 } runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Assign","url":"docs/monoids/Assign#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Assign","url":"docs/monoids/Assign#equals","content":"Copy Assign a ~> b -> Boolean Used to compare the underlying values of (2) Assign instances for equality by value, equals takes any given argument and returns true if the passed argument is an Assign with an underlying value equal to the underlying value of the Assign the method is being called on. If the passed argument is not an Assign or the underlying values are not equal, equals will return false. Copy importAssignfrom'crocks/Assign' Assign({ a:5}) .equals(Assign({ a:5})) //=> true Assign({ a:5}) .equals(Assign({ a:15})) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Assign","url":"docs/monoids/Assign#concat","content":"Copy Assign ~> Assign -> Assign concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Assign, it will combine (2) objects, overwriting the first Object's previous values with the values of the second Object. Copy importAssignfrom'crocks/Assign' Assign({}) .concat(Assign({})) //=> Assign {} Assign({ a:1}) .concat(Assign({ b:2})) //=> Assign { a: 1, b: 2 } Assign({ a:1, b:2}) .concat(Assign({ a:3, b:4})) //=> Assign { a: 3, b: 4 } Assign({ b:4}) .concat(Assign({ a:1})) //=> Assign { b: 4, a: 1 } runkit "},{"title":"valueOf","type":1,"pageTitle":"Assign","url":"docs/monoids/Assign#valueof","content":"Copy Assign ~> () -> Object valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Assign instance will result in the underlying Object. Copy importAssignfrom'crocks/Assign' Assign({}) .valueOf() //=> {} Assign({ a:1}) .valueOf() //=> { a: 1 } Assign({ a:1}) .concat({ b:25}) .valueOf() //=> { a: 1, b: 25 } runkit "},{"title":"All","type":0,"sectionRef":"#","url":"docs/monoids/All","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"All","url":"docs/monoids/All#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"All","url":"docs/monoids/All#construction","content":"Copy All :: a -> All Boolean All is constructed by calling the constructor with any type a. This will return an All wrapping the provided value, coerced to a Boolean. For example, providing a non-zero Number will result in an All(true). While passing a zero results in an All(false). Copy importAllfrom'crocks/All' All('') //=> All(false) All('string') //=> All(true) All({ a:0}) //=> All(true) runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"All","url":"docs/monoids/All#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"All","url":"docs/monoids/All#empty","content":"Copy All.empty :: () -> All empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of All the result of empty is true. empty is available on both the Constructor and the Instance for convenience. Copy importAllfrom'crocks/All' All.empty()//=> All true All(true).concat(All.empty())//=> All true All(false).concat(All.empty())//=> All false runkit "},{"title":"Instance Methods","type":1,"pageTitle":"All","url":"docs/monoids/All#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"All","url":"docs/monoids/All#equals","content":"Copy All a ~> b -> Boolean Used to compare the underlying values of (2) All instances for equality by value, equals takes any given argument and returns true if the passed argument is an All with an underlying value equal to the underlying value of the All the method is being called on. If the passed argument is not an All or the underlying values are not equal, equals will return false. Copy importAllfrom'crocks/All' All(true) .equals(All(true)) //=> true All(true) .equals(All(false)) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"All","url":"docs/monoids/All#concat","content":"Copy All ~> All -> All concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of All, it will combine the (2) using logical AND (conjunction). Copy importAllfrom'crocks/All' All(true).concat(All(true))//=> All true All(true).concat(All(false))//=> All false All(false).concat(All(true))//=> All false All(false).concat(All(false))//=> All false runkit "},{"title":"valueOf","type":1,"pageTitle":"All","url":"docs/monoids/All#valueof","content":"Copy All ~> () -> Boolean valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an All instance will result in the underlying Boolean value. Copy importAllfrom'crocks/All' All(0).valueOf()//=> false All('string').valueOf()//=> true //=> false All(true) .concat('') .valueOf() runkit "},{"title":"Result","type":0,"sectionRef":"#","url":"docs/crocks/Result","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Result","url":"docs/crocks/Result#implements","content":"Setoid, Semigroup, Functor, Alt, Apply, Traversable,Chain, Applicative, Monad "},{"title":"Construction","type":1,"pageTitle":"Result","url":"docs/crocks/Result#construction","content":"Copy Result :: a -> Result e a Most of the time, Result is constructed using functions of your own making and helper functions like tryCatch or by employing one of the instance constructors, Ok or Err. This is due to the nature of Result and most other Sum Types. As a matter of consistency and completion, a Result instance can also be constructed using its TypeRep like any other type. The Result constructor is a unary function that accepts any type a and returns a Ok instance, wrapping the value passed to its argument. Copy importResultfrom'crocks/Result' import equals from'crocks/pointfree/equals' const{Ok,Err,of}=Result Result('some string') //=> Ok \"some string\" Result(null) //=> Ok null Result(undefined) //=> Ok undefined of('some string') //=> Ok \"some string\" of(null) //=> Ok null of(undefined) //=> Ok undefined Ok('some string') //=> Ok \"some string\" Ok(null) //=> Ok null Ok(undefined) //=> Ok undefined Err('some string') //=> Err \"some string\" Err(null) //=> Err null Err(undefined) //=> Err undefined equals( Result.Ok([1,2,3]), Result.of([1,2,3]) ) //=> true equals( of({ a:100}), Result({ a:100}) ) //=> true runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Result","url":"docs/crocks/Result#constructor-methods","content":""},{"title":"Err","type":1,"pageTitle":"Result","url":"docs/crocks/Result#err","content":"Copy Result.Err :: e -> Result e a Used to construct an Err instance that represents the \"false\" portion of a disjunction. When an instance is an Err, most Result returning methods will just return a new Err instance with the same containing value. The power of the Err as opposed to a Left or a Nothing is that it can hold meaningful information on why the flow is in this path. It will also accumulate this information when ap or alt are used. This works as a core tool when using Railway Orientated Programming concepts. Copy importResultfrom'crocks/Result' import bimap from'crocks/pointfree/bimap' import chain from'crocks/pointfree/chain' import composeB from'crocks/combinators/composeB' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' const{Ok,Err}=Result // ensure :: (a -> Boolean) -> a -> Result a constensure=pred=> ifElse(pred,Ok,Err) // buildError :: () -> String constbuildError=()=> 'The value given was not a valid number' // add10 :: Number -> Number constadd10= x=> x +10 // protectedAdd10 :: a -> Result String Number const protectedAdd10 =composeB( bimap(buildError, add10), ensure(isNumber) ) Err(undefined) //=> Err undefined Err(null) //=> Err null Err(23) .map(add10) //=> Err 23 Ok(23) .map(add10) //=> Ok 33 chain(protectedAdd10,Err('number')) //=> Err \"number\" chain(protectedAdd10,Ok(10)) //=> Ok 20 runkit "},{"title":"Ok","type":1,"pageTitle":"Result","url":"docs/crocks/Result#ok","content":"Copy Result.Ok :: a -> Result e a Used to construct an Ok instance that represents the \"true\" portion of a disjunction or a valid value. Ok will wrap any given value in anOk, signaling the validity of the wrapped value. Copy importResultfrom'crocks/Result' import bimap from'crocks/pointfree/bimap' import composeB from'crocks/combinators/composeB' import identity from'crocks/combinators/identity' import ifElse from'crocks/logic/ifElse' import isString from'crocks/predicates/isString' import map from'crocks/pointfree/map' const{Ok,Err}=Result // ensure :: (a -> Boolean) -> a -> Result a constensure=pred=> ifElse(pred,Ok,Err) // buildError :: () -> String constbuildError=()=> 'The value given is not a valid string' // ensureString :: a -> Result String Number const ensureString =composeB( bimap(buildError, identity), ensure(isString) ) // toUpper :: String -> String consttoUpper= x=> x.toUpperCase() Ok(32) //=> Ok 32 Ok(undefined) //=> Ok undefined Ok(null) //=> Ok null // safeShout :: a -> Result String const safeShout =composeB( map(toUpper), ensureString ) safeShout(45) //=> Err \"The value given is not a valid string\" safeShout('Hey there!') //=> Ok \"HEY THERE!\" runkit "},{"title":"of","type":1,"pageTitle":"Result","url":"docs/crocks/Result#of","content":"Copy Result.of :: a -> Result e a Used to wrap any value into a Result as an Ok, of is used mostly by helper functions that work \"generically\" with instances of either Applicative or Monad types. When working specifically with the Result type, the Ok constructor should be used. Reach for of when working with functions that will work with ANY Applicative/Monad. Copy importResultfrom'crocks/Result' const{Ok,of}=Result of('Some result!') //=> Ok \"Some result!\" of(undefined) //=> Ok undefined Ok('Some result!') //=> Ok \"Some result!\" Ok(undefined) //=> Ok undefined Result('Some result!') //=> Ok \"Some result!\" Result(undefined) //=> Ok undefined runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Result","url":"docs/crocks/Result#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Result","url":"docs/crocks/Result#equals","content":"Copy Result e a ~> b -> Boolean Used to compare the contained values of two Result instances for equality by value. equals takes any given argument and returns true if the passed argument is a Result (Ok or Err) with a contained value equal to the contained value of the Result the method is being called on. If the passed argument is not a Result or the contained values are not equal by value then equals will return false. Copy importResultfrom'crocks/Result' import equals from'crocks/pointfree/equals' const{Ok,Err}=Result Ok('result') .equals(Ok('result')) //=> true Ok(null) .equals(Ok(null)) //=> true Ok('error') .equals(Err('error')) //=> false // by value, not reference for most types Ok([1,{ a:2},'string']) .equals(Ok([1,{ a:2},'string'])) //=> true equals(Ok('result'),'result') //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Result","url":"docs/crocks/Result#concat","content":"Copy Semigroup s => Result e s ~> Result e s -> Result e s When an underlying value of a given Result is fixed to a Semigroup, concat can be used to concat another Result instance with an underlying Semigroup of the same type. Expecting a Result wrapping a Semigroup of the same type, concat will give back a new Result instance wrapping the result of combining the two underlying Semigroups. When called on a Err instance, concat will return an Err with the value of the first Err in the chain. Copy importResultfrom'crocks/Result' import concat from'crocks/pointfree/concat' const{Ok,Err}=Result Ok([1,2,3]) .concat(Ok([4,5,6])) //=> [ 1, 2, 3, 4, 5, 6 ] Ok([1,2,3]) .concat(Err([4,5,6])) //=> Err [ 4, 5, 6 ] concat(Ok('Result'),Err('Error')) //=> Err \"Error\" concat(Err('Error'),Ok('Result')) //=> Err \"Error\" concat(Err('Error 1'),Err('Error 2')) //=> Err \"Error 2\" runkit "},{"title":"map","type":1,"pageTitle":"Result","url":"docs/crocks/Result#map","content":"Copy Result e a ~> (a -> b) -> Result e b Used to apply transformations to values in the safety of a Result, map takes a function that it will lift into the context of the Result and apply to it the wrapped value. When run on an Ok instance, map will apply the wrapped value to the provided function and return the result in a new Okinstance. When run on an 'Err'map with return the error value in a newErr instance. Copy importResultfrom'crocks/Result' import assign from'crocks/helpers/assign' import compose from'crocks/helpers/compose' import composeB from'crocks/combinators/composeB' import fanout from'crocks/Pair/fanout' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import map from'crocks/pointfree/map' import merge from'crocks/pointfree/merge' import objOf from'crocks/helpers/objOf' const{Ok,Err}=Result // buildError :: () -> Result String a constbuildError=()=> Err('The value given was not a valid number') // double :: Number -> Number constdouble= x=> x *2 // fromNumber :: a -> Result String Number const fromNumber = ifElse(isNumber,Ok, buildError) // doubleNumber :: a -> Result String Number const doubleNumber =composeB( map(double), fromNumber ) doubleNumber(21) //=> Ok 42 doubleNumber('down') //=> Err \"The value given was not a valid number\" // isEvenOrOdd :: Number -> String constisEvenOrOdd=n=> n %2===0?'Even':'Odd' // getParity :: Number -> Object const getParity =composeB( objOf('parity'), isEvenOrOdd ) // getInfo :: a -> Result String ({ parity: String, value: Number }) const getInfo =compose( map(merge(assign)), map(fanout(objOf('value'), getParity)), fromNumber ) getInfo(5324) //=> Ok { parity: \"Even\", value: 5324 } getInfo('down') //=> Err \"The value given was not a valid number\" runkit "},{"title":"alt","type":1,"pageTitle":"Result","url":"docs/crocks/Result#alt","content":"Copy Result e a ~> Result e a -> Result e a Providing a means for a fallback or alternative value, alt combines two Result instances and will return the first Ok it encounters or am Err if neither value is an Ok. If the value in both Err are Semigroups of the same type then they will accumulate based on their rules. Copy importResultfrom'crocks/Result' import alt from'crocks/pointfree/alt' import compose from'crocks/helpers/compose' import curry from'crocks/core/curry' import flip from'crocks/combinators/flip' import identity from'crocks/combinators/identity' import ifElse from'crocks/logic/ifElse' import map from'crocks/pointfree/map' import reduce from'crocks/pointfree/reduce' import bimap from'crocks/pointfree/bimap' const{Ok,Err}=Result // ensure :: (a -> Boolean) -> a -> Result a constensure=pred=> ifElse(pred,Ok,Err) // gte :: Number -> Number -> Boolean constgte=x=>y=> y >= x // find :: (a -> Boolean) -> Foldable a -> Result String a const find =curry( pred=>compose( bimap(()=>'Not Found', identity), reduce(flip(alt),Err()), map(ensure(pred)) ) ) Err('Error') .alt(Ok('Result')) //=> Ok \"Result\" Ok('Result') .alt(Err('Error')) //=> Ok \"Result\" Err('Error 1.') .alt(Err('Error 2.')) //=> Err \"Error 1.Error 2.\" find(gte(41),[17,25,38,42]) //=> Ok 42 find(gte(11),[1,2,3,4]) //=> Err \"Not found\" runkit "},{"title":"bimap","type":1,"pageTitle":"Result","url":"docs/crocks/Result#bimap","content":"Copy Result e a ~> ((e -> d), (a -> b)) -> Result d b While it's more common to only map over a Result that's anOk there may come a time when you need to map over a Result regardless of whether it's an Ok or an Err. bimap takes two mapping functions as its arguments. The first function is used to map an Err instance, while the second maps an Ok.Result only provides a means to map an Ok instance exclusively usingmap. If the need arises to map an Err instance exclusively, then bimap can be used, passing the mapping function to the first argument and identity to the second. Copy importResultfrom'crocks/Result' import bimap from'crocks/pointfree/bimap' import composeB from'crocks/combinators/composeB' import identity from'crocks/combinators/identity' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import map from'crocks/pointfree/map' import objOf from'crocks/helpers/objOf' import setProp from'crocks/helpers/setProp' const{Ok,Err}=Result // ensure :: (a -> Boolean) -> a -> Result a constensure=pred=> ifElse(pred,Ok,Err) // buildError :: () -> String constbuildError=()=> 'The value given was not a valid number' // prod :: Number -> Number -> Number constprod=x=>y=> x * y // fromNumber :: a -> Result String Number const fromNumber =composeB( bimap(buildError, identity), ensure(isNumber) ) // hasError :: Boolean -> Object -> Object const hasError = setProp('hasError') // Outcome :: { result: Number, hasError: Boolean, error: String } // buildResult :: (String, Boolean) -> a -> Outcome constbuildResult=(key, isError)=> composeB(hasError(isError),objOf(key)) // finalize :: Result e a -> Result Outcome const finalize =bimap( buildResult('error',true), buildResult('result',false) ) // double :: a -> Result String Number const double =composeB( map(prod(2)), fromNumber ) finalize(double(21)) //=> Ok { hasError: false, result: 42 } finalize(double('unk')) //=> Err { hasError: true, error: \"The value given was not a valid number\" } runkit "},{"title":"ap","type":1,"pageTitle":"Result","url":"docs/crocks/Result#ap","content":"Copy Result e (a -> b) ~> Result e a -> Result e b Short for apply, ap is used to apply a Result instance containing a value to another Result instance that contains a function, resulting in new Result instance with the result. ap requires that it is called on an instance that is either an Err or an Ok that wraps a curried polyadic function. When either instance is an Err, ap will return an Err. This can be used to safely combine multiple values under a given combination function. If any of the inputs results in an Err than they will never be applied to the function and not provide exceptions or unexpected results. However if the value in both Err are Semigroups of the same type then they will accumulate based on their rules. Copy importResultfrom'crocks/Result' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import liftA2 from'crocks/helpers/liftA2' import map from'crocks/pointfree/map' const{Ok,Err}=Result // buildError :: () -> Result String a constbuildError=()=> Err('The value given was not a valid number') // prod :: Number -> Number -> Number constprod=x=>y=> x * y // fromNumber :: a -> Result String Number const fromNumber = ifElse(isNumber,Ok, buildError) map(prod,fromNumber(2)) .ap(fromNumber(5)) //=> Ok 10 map(prod,fromNumber('string')) .ap(fromNumber(5)) //=> Err \"The value given was not a valid number\" Ok(prod) .ap(fromNumber(2)) .ap(fromNumber(21)) //=> Ok 42 Ok(prod) .ap(fromNumber('string')) .ap(fromNumber(21)) //=> Err \"The value given was not a valid number\" liftA2(prod,fromNumber(2),fromNumber(21)) //=> Ok 42 liftA2(prod,Err('Not 2'),Err('Not 21')) //=> Err \"Not 2Not 21\" liftA2(prod,Err(['Not 2']),Err(['Not 21'])) //=> Err [ \"Not 2\", \"Not 21\" ] runkit "},{"title":"sequence","type":1,"pageTitle":"Result","url":"docs/crocks/Result#sequence","content":"Copy Apply f => Result e (f a) ~> (b -> f b) -> f (Result e a) Applicative f => Result e (f a) ~> TypeRep f -> f (Result e a) When an instance of Result wraps an Apply instance, sequence can be used to swap the type sequence. sequence requires either an Applicative TypeRep or an Apply returning function is provided for its argument. This will be used in the case that the Result instance is a Err. sequence can be derived from traverse by passing it an identity function (x => x). Copy importResultfrom'crocks/Result' importIdentityfrom'crocks/Identity' const{Err,Ok}=Result // arrayOf :: a -> [ a ] constarrayOf= x=>[ x ] Ok([1,2,3]) .sequence(arrayOf) //=> [ Ok 1, Ok 2, Ok 3 ] Err('no array here') .sequence(arrayOf) //=> [ Err \"no array here\" ] Ok(Identity.of(42)) .sequence(Identity) //=> Identity (Ok 42) Err(0) .sequence(Identity) //=> Identity (Err 0) runkit "},{"title":"traverse","type":1,"pageTitle":"Result","url":"docs/crocks/Result#traverse","content":"Copy Apply f => Result e a ~> (c -> f c), (a -> f b)) -> f Result e b Applicative f => Result e a ~> (TypeRep f, (a -> f b)) -> f Result e b Used to apply the \"effect\" of an Apply to a value inside of a Result,traverse combines both the \"effects\" of the Apply and the Result by returning a new instance of the Apply, wrapping the result of the Applys \"effect\" on the value in the Result. traverse requires either an Applicative TypeRep or an Apply returning function as its first argument and a function that is used to apply the \"effect\" of the target Apply to the value inside of the Result. This will be used in the case that the Result instance is a Err. Both arguments must provide an instance of the target Apply. Copy importResultfrom'crocks/Result' importPairfrom'crocks/Pair' importStatefrom'crocks/State' importSumfrom'crocks/Sum' import constant from'crocks/combinators/constant' import ifElse from'crocks/logic/ifElse' import traverse from'crocks/pointfree/traverse' const{Err,Ok}=Result const{get, modify }=State // lte :: Number -> Number -> Boolean constlte=y=>x=> x <= y // ensure :: (a -> Boolean) -> a -> Result a constensure=pred=> ifElse(pred,Ok,Err) // tallyOf :: Number -> Pair Sum Number consttallyOf=x=> Pair(Sum.empty(), x) // incBy :: Number -> Pair Sum Number constincBy=x=> Pair(Sum(x), x) Ok(12) .traverse(tallyOf, incBy) //=> Pair( Sum 12, Ok 12 ) Err(true) .traverse(tallyOf, incBy) //=> Pair( Sum 0, Err true ) // lte10 :: Number -> Result Number const lte10 = ensure(lte(10)) // update :: Number -> State Number constupdate=x=> modify(state=> x + state) .chain(constant(get())) // updateSmall :: () => State Number constupdateSmall=()=> get(lte10) .chain(traverse(State, update)) updateSmall() .runWith(3) //=> Pair( Ok 6, 6 ) updateSmall() .chain(updateSmall) .runWith(3) //=> Pair( Ok 12, 12 ) updateSmall() .chain(updateSmall) .chain(updateSmall) .runWith(3) //=> Pair( Err 12, 12 ) updateSmall() .chain(updateSmall) .chain(updateSmall) .runWith(30) //=> Pair( Err 30, 30 ) runkit "},{"title":"chain","type":1,"pageTitle":"Result","url":"docs/crocks/Result#chain","content":"Copy Result e a ~> (a -> Result e b) -> Result e b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. chain expects a unary, Result returning function as its argument. When invoked on an Err, chain will not run the function, but will instead return a new Err instance with the same containing value. When called on an Ok however, the inner value will be passed to provided function, returning the result as the new instance. Copy importResultfrom'crocks/Result' import chain from'crocks/pointfree/chain' import composeB from'crocks/combinators/composeB' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import maybeToResult from'crocks/Result/maybeToResult' import map from'crocks/pointfree/map' import getProp from'crocks/Maybe/getProp' const{Err,Ok}=Result // errText :: (String | Number) -> String consterrText=name=> `${name} does not exist on the value given` // buildError :: () -> Result String a constbuildError=()=> Err('the value given is not valid') // ensure :: (a -> Boolean) -> a -> Result String a constensure=pred=> ifElse(pred,Ok, buildError) // fromNumber :: a -> Result String Number const fromNumber = ensure(isNumber) // prop :: (String | Number) -> Object -> Result String a constprop=name=> maybeToResult(errText(name),getProp(name)) // protectedAdd10 :: a -> Result String Number const protectedAdd10 =composeB( map(x=> x +10), fromNumber ) // getAge :: Object -> Result String Number const getAge =composeB( chain(fromNumber), prop('age') ) getAge({ name:'Sarah', age:21}) //=> Ok 21 getAge({ name:'Sarah', age:'unk'}) //=> Err \"the value given is not valid\" getAge({ name:'Sarah'}) //=> Err \"age does not exist on the value given\" getAge({ name:'Sarah', age:21}) .chain(protectedAdd10) //=> Ok 31 getAge({ name:'Sarah', age:'unk'}) .chain(protectedAdd10) //=> Err \"the value given is not valid\" runkit "},{"title":"coalesce","type":1,"pageTitle":"Result","url":"docs/crocks/Result#coalesce","content":"Copy Result e a ~> ((e -> b), (a -> b))) -> Result c b There will come a time in your flow that you will want to ensure you have an Ok of a given type. coalesce allows you to map over both the Ok and the Err and return an Ok. coalesce expects two functions for it's inputs. The first function is used when invoked on a Err and will return a Ok instance wrapping the result of the function. The second function is used when coalesce is invoked on a Ok and is used to map the original value, returning a new Ok instance wrapping the result of the second function. Copy importResultfrom'crocks/Result' import assign from'crocks/helpers/assign' import chain from'crocks/pointfree/chain' import coalesce from'crocks/pointfree/coalesce' import compose from'crocks/helpers/compose' import composeB from'crocks/combinators/composeB' import constant from'crocks/combinators/constant' import fanout from'crocks/Pair/fanout' import hasProp from'crocks/predicates/hasProp' import identity from'crocks/combinators/identity' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import isObject from'crocks/predicates/isObject' import map from'crocks/pointfree/map' import merge from'crocks/pointfree/merge' import objOf from'crocks/helpers/objOf' import setProp from'crocks/helpers/setProp' const{Err,Ok}=Result // gte :: Number -> Number -> Boolean constgte=y=>x=> x >= y // ensure :: (a -> Boolean) -> a -> Result a constensure=pred=> ifElse(pred,Ok,Err) // fromNumber :: a -> Result a Number const fromNumber = ensure(isNumber) // ensureIsObject :: a -> Result a Object const ensureIsObject = ensure(isObject) fromNumber(45) .coalesce(constant(42), identity) //=> Ok 45 fromNumber('number') .coalesce(constant(42), identity) //=> Ok 42 // hasAge :: a -> Result a Boolean const hasAge = ensure(hasProp('age')) // prop :: String -> Object -> a constprop=name=>x=> x[name] // Person :: { canDrink: Boolean, name: String: age: Number } // ensureHasAge :: a -> Result a Person const ensureHasAge =compose( coalesce(setProp('age',0), identity), chain(hasAge), coalesce(constant({}), identity), ensureIsObject ) // determineCanDrink :: Number -> { canDrink: Boolean } const determineCanDrink = composeB(objOf('canDrink'),gte(18)) // setCanDrink :: a -> Result a Person const setCanDrink =compose( merge(assign), map(determineCanDrink), fanout(identity,prop('age')) ) // setCanDrink :: a -> Result Person const getDetails =composeB( map(setCanDrink), ensureHasAge ) getDetails({ name:'John', age:17}) //=> Ok { canDrink: false, name: \"John\", age: 17 } getDetails({ name:'Laury', age:22}) //=> Ok { canDrink: true, name: \"Laury\", age: 22 } getDetails(null) //=> Ok { canDrink: false, age: 0 } getDetails(undefined) //=> Ok { canDrink: false, age: 0 } getDetails(1) //=> Ok { canDrink: false, age: 0 } getDetails(false) //=> Ok { canDrink: false, age: 0 } runkit "},{"title":"bichain","type":1,"pageTitle":"Result","url":"docs/crocks/Result#bichain","content":"Copy Result c a ~> ((c -> Result d b), (a -> Result d b)) -> Result d b Combining a sequential series of transformations that capture disjunction can be accomplished with chain. Along the same lines, bichain allows you to do this from both Err and Ok. bichain expects two unary, Either returning functions as its arguments. When invoked on an Err instance, bichain will use the left, or first, function that can return either an Err or an Ok instance. When called on an Ok instance, it will behave exactly as chain would with the right, or second, function. Copy importResultfrom'crocks/Result' import bichain from'crocks/pointfree/bichain' import compose from'crocks/helpers/compose' import composeK from'crocks/helpers/composeK' import constant from'crocks/combinators/constant' import equals from'crocks/pointfree/equals' import getProp from'crocks/Maybe/getProp' import isNumber from'crocks/predicates/isNumber' import map from'crocks/pointfree/map' import maybeToResult from'crocks/Result/maybeToResult' import objOf from'crocks/helpers/objOf' import safe from'crocks/Maybe/safe' import substitution from'crocks/combinators/substitution' import tryCatch from'crocks/Result/tryCatch' const{Err,Ok}=Result // swapResult :: Result e a -> Result a e const swapResult = bichain(Ok,Err) swapResult(Err('err')) //=> Ok \"err\" swapResult(Ok('ok')) //=> Err \"ok\" // Wrapped :: { value: Number } // wrapEven :: Number -> Wrapped functionwrapEven(num){ if(!isNumber(num)){ thrownewTypeError('wrapEven: Must be a Number') } if(num %2){ thrownewError('wrapEven: Nunber must be even') } return{ value: num } } // increment :: Number -> Number constincrement=x=> x +1 const checkEvenError =composeK( safe(equals('wrapEven: Nunber must be even')), getProp('message') ) // alwaysWrapInc :: Number -> () -> Wrapped const alwaysWrapInc =compose( constant, objOf('value'), increment ) // makeWrappedEven :: Number -> Error -> Maybe Wrapped constmakeWrappedEven=orig=>compose( map(alwaysWrapInc(orig)), checkEvenError ) // resolveError :: Number -> Error -> Result Error Wrapped const resolveError =compose( substitution(maybeToResult), makeWrappedEven ) // safeWrapEven :: Number -> Result Error Wrapped constsafeWrapEven=num=> tryCatch(wrapEven, num) .bichain(resolveError(num),Ok) safeWrapEven(2) //=> Ok { value: 2 } safeWrapEven(42) //=> Ok { value: 42 } safeWrapEven(23) //=> Ok { value: 24 } safeWrapEven('92') //=> Err TypeError: wrapEven: Must be a Number safeWrapEven(null) //=> Err TypeError: wrapEven: Must be a Number runkit "},{"title":"swap","type":1,"pageTitle":"Result","url":"docs/crocks/Result#swap","content":"Copy Result e a ~> ((e -> a), (a -> e)) -> Result e a Used to map the value of a Result instance and transform an Err into anOk or an Ok into an Err, swap takes two functions as its arguments. The first function is used to map and transform an Err into an Ok, while the second maps and transforms an Ok into an Err. If no mapping of the contained values is required for either instance, then identity functions can be used in one or both arguments. Copy importResultfrom'crocks/Result' import constant from'crocks/combinators/constant' import identity from'crocks/combinators/identity' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import when from'crocks/logic/when' import swap from'crocks/pointfree/swap' const{Ok,Err}=Result // simpleSwap :: Result e a -> Result a e const simpleSwap = swap(identity, identity) simpleSwap(Ok(42)) //=> Err 42 simpleSwap(Err(21)) //=> Ok 21 // ensure :: (a -> Boolean) -> a -> Result String a constensure=pred=> ifElse(pred,Ok,Err) // fromNumber :: a -> Result String Number const fromNumber = ensure(isNumber) // toString :: Number -> String consttoString=x=> x.toString() // toNumber :: String -> Number consttoNumber=x=> parseInt(x) // parseWithDefault :: Number -> a -> Number constparseWithDefault=defaultValue=>value=> when(isNaN,constant(defaultValue),toNumber(value)) // swapWith :: Result String Number -> Result String Number const swapValues = swap(parseWithDefault(0), toString) swapValues(fromNumber(4)) //=> Err \"4\" swapValues(fromNumber('number')) //=> Ok 0 runkit "},{"title":"either","type":1,"pageTitle":"Result","url":"docs/crocks/Result#either","content":"Copy Result e a ~> ((e -> b), (a -> b)) -> b Used to provide a means to map a given Result instance folding it out of its container. either expects two functions as its arguments. The first is a function that will be used to map an Err. While the second will map the value wrapped in a given Ok and return the result of that mapping. By composing either you can create functions that us the power of ADTs while returning a plain javascript type. Copy importResultfrom'crocks/Result' import compose from'crocks/helpers/compose' import either from'crocks/pointfree/either' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import map from'crocks/pointfree/map' import objOf from'crocks/helpers/objOf' import setProp from'crocks/helpers/setProp' const{Ok,Err}=Result // buildError :: () -> Result String a constbuildError=()=> Err('The value given was not a valid number') // ensure :: (a -> Boolean) -> a -> Result String a constensure=pred=> ifElse(pred,Ok, buildError) // fromNumber :: a -> Result String Number const fromNumber = ensure(isNumber) // double :: Number -> Number constdouble=x=> x *2 // hasError :: Boolean -> Object -> Object const hasError = setProp('hasError') // buildResult :: (String, Boolean) -> a -> Object constbuildResult=(key, isError)=> compose(hasError(isError),objOf(key)) // ResultDetail :: { result: Number, hasError: Boolean, error: String } // createResult :: Result e a -> ResultDetail const createResult =either( buildResult('error',true), buildResult('result',false) ) // doubleNumber :: a -> ResultDetail const doubleNumber =compose( createResult, map(double), fromNumber ) doubleNumber(42) //=> { result: 84, hasError: false } doubleNumber('value') //=> { error: 'The value given was not a valid number', hasError: true } runkit "},{"title":"Helper Functions","type":1,"pageTitle":"Result","url":"docs/crocks/Result#helper-functions","content":""},{"title":"tryCatch","type":1,"pageTitle":"Result","url":"docs/crocks/Result#trycatch","content":"crocks/Result/tryCatch Copy tryCatch :: (* -> a) -> * -> Result e a Used when you want to take any variadic function and wrap it with the added function of a Result type. tryCatch will execute the function with the parameters passed and return either an Ok when successful or anErr when an exception is thrown. Although we do our best to not use Error to control program flow, there are times when we don't have full control over the behaviour of a function. The saviour in this situation is tryCatch. You can wrap this function and it will always return a Result Copy import tryCatch from'crocks/Result/tryCatch' tryCatch(()=>{ thrownewError('Simple error!') })() // Err \"Simple error!\" // calculateArea :: (a, b) -> Number constcalculateArea=(width, height)=>{ if(isNaN(width)||isNaN(height)){ throwError('Parameter is not a number!') } return width * height } // tryCalculateArea :: (a, b) -> Result String Number const tryCalculateArea = tryCatch(calculateArea) tryCalculateArea(3,6) //=> Ok 18 tryCalculateArea('String',5) // Err \"Error: Parameter is not a number!\" // getLength :: a -> Number constgetLength=a=> a.length // tryGetLength :: a -> Result String Number const tryGetLength = tryCatch(getLength) tryGetLength([3,2,1]) //=> Ok 3 tryGetLength() //=> Err \"TypeError: Cannot read property 'length' of undefined\" runkit "},{"title":"Transformation Functions","type":1,"pageTitle":"Result","url":"docs/crocks/Result#transformation-functions","content":""},{"title":"eitherToResult","type":1,"pageTitle":"Result","url":"docs/crocks/Result#eithertoresult","content":"crocks/Result/eitherToResult Copy eitherToResult :: Either b a -> Result b a eitherToResult :: (a -> Either c b) -> a -> Result c b Used to transform a given Either instance to a Result instance or flatten a Result of Either into a Result when chained, eitherToMaybe will turn a Right instance into an Ok wrapping the original value contained in the Right. All Left instances will map to an Err, mapping the originally contained value to a Unit. Values on the Left will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, eitherToMaybe has two possible signatures and will behave differently when passed either an Either instance or a function that returns an instance of Either. When passed the instance, a transformed Result is returned. When passed an Either returning function, a function will be returned that takes a given value and returns a Result. Copy importResultfrom'crocks/Result' importEitherfrom'crocks/Either' import assign from'crocks/helpers/assign' import composeK from'crocks/helpers/composeK' import composeB from'crocks/combinators/composeB' import eitherToResult from'crocks/Result/eitherToResult' import fanout from'crocks/Pair/fanout' import isNumber from'crocks/predicates/isNumber' import liftA2 from'crocks/helpers/liftA2' import map from'crocks/pointfree/map' import maybeToEither from'crocks/Either/maybeToEither' import merge from'crocks/pointfree/merge' import objOf from'crocks/helpers/objOf' import getProp from'crocks/Maybe/getProp' import safeLift from'crocks/Maybe/safeLift' const{Left,Right}=Either const{Ok}=Result eitherToResult(Left('no good')) //=> Err \"no good\" eitherToResult(Right('so good')) //=> Ok \"so good\" // safeInc :: a -> Maybe Number const safeInc = safeLift(isNumber,x=> x +1) // incProp :: String -> a -> Maybe Number constincProp=key=> composeK(safeInc,getProp(key)) // incResult :: String -> a -> Either [ String ] Object constincResult=key=>maybeToEither( [`${key} is not valid`], composeB( map(objOf(key)), incProp(key) ) ) // incThem :: a -> Either [ String ] Object const incThem =composeB( merge(liftA2(assign)), fanout(incResult('b'),incResult('a')) ) Result.of({}) .chain(eitherToResult(incThem)) //=> Err [ \"b is not valid\" ] Result.of({ a:33}) .chain(eitherToResult(incThem)) //=> Err [ \"b is not valid\" ] Result.of({ a:99, b:'41'}) .chain(eitherToResult(incThem)) //=> Err [ \"b is not valid\" ] Result.of({ a:99, b:41}) .chain(eitherToResult(incThem)) //=> Ok { a: 100, b: 42 } Ok(Left('Err')) .chain(eitherToResult) //=> Err \"Err\" Ok(Right('42')) .chain(eitherToResult) //=> Ok \"42\" runkit "},{"title":"firstToResult","type":1,"pageTitle":"Result","url":"docs/crocks/Result#firsttoresult","content":"crocks/Result/firstToResult Copy firstToResult :: e -> First a -> Result e a firstToResult :: e -> (a -> First b) -> a -> Result e b Used to transform a given First instance to a Result instance or flatten a Result of First into a Result when chained, firstToResult will turn a non-empty instance into an Ok wrapping the original value contained within the First. All empty instances will map to an Err with the given value. Like all crocks transformation functions, firstToResult has two possible signatures and will behave differently when passed either a First instance or a function that returns an instance of First. When passed the instance, a transformed Result is returned. When passed a First returning function, a function will be returned that takes a given value and returns a Result. Copy importFirstfrom'crocks/First' import composeB from'crocks/combinators/composeB' import concat from'crocks/pointfree/concat' import firstToResult from'crocks/Result/firstToResult' import flip from'crocks/combinators/flip' import mapReduce from'crocks/helpers/mapReduce' import getProp from'crocks/Maybe/getProp' const{ empty }=First // Person :: { name: String, age: Number } // createPerson :: (String, Number) -> Person constcreatePerson=(name, age)=>({ name, age }) // liftName :: Person -> First String const liftName =composeB( First, getProp('name') ) // mergeFirstName :: [ Person ] -> First String const mergeFirstName =composeB( firstToResult('(No name found)'), mapReduce(liftName,flip(concat),empty()) ) mergeFirstName([ createPerson('John',30), createPerson('Jon',33) ]) //=> Ok \"John\" mergeFirstName([ createPerson(undefined,30), createPerson(undefined,33) ]) //=> Err \"(No name found)\" runkit "},{"title":"lastToResult","type":1,"pageTitle":"Result","url":"docs/crocks/Result#lasttoresult","content":"crocks/Result/lastToResult Copy lastToResult :: e -> Last a -> Result e a lastToResult :: e -> (a -> Last b) -> a -> Result e b Used to transform a given Last instance to a Result instance or flatten a Result of Last into a Result when chained, lastToResult will turn a non-empty instance into a Ok wrapping the original value contained within the Last. All empty instances will map to aErr. Like all crocks transformation functions, lastToResult has two possible signatures and will behave differently when passed either a Last instance or a function that returns an instance of Last. When passed the instance, a transformed Result is returned. When passed a Last returning function, a function will be returned that takes a given value and returns a Result. Copy importResultfrom'crocks/Result' importLastfrom'crocks/Last' import lastToResult from'crocks/Result/lastToResult' import mconcat from'crocks/helpers/mconcat' const{Ok,Err}=Result // lastValue :: [ a ] -> Last a const lastValue = mconcat(Last) lastToResult('Error occurred!',Last('the end')) //=> Ok \"the end\" Err('Error occurred!') .chain(lastToResult('Error occurred!', lastValue)) //=> Err \"Error occurred!\" Ok([]) .chain(lastToResult('Error occurred!', lastValue)) //=> Err \"Error occurred!\" Ok(['first','second','third']) .chain(lastToResult('Error occurred!', lastValue)) //=> Ok \"third\" Ok(Last('last')) .chain(lastToResult('Error occurred!')) //=> Ok \"last\" runkit "},{"title":"maybeToResult","type":1,"pageTitle":"Result","url":"docs/crocks/Result#maybetoresult","content":"crocks/Result/maybeToResult Copy maybeToResult :: e -> Maybe a -> Result e a maybeToResult :: e -> (a -> Maybe b) -> a -> Result e b Used to transform a given Maybe instance to a Result instance or flatten a Result of Maybe into a Result when chained, maybeToResult will turn a Just instance into an Ok wrapping the original value contained in the Just. All Nothing instances will map to a Err, containing the given e value. Like all crocks transformation functions, maybeToResult has two possible signatures and will behave differently when passed either a Maybe instance or a function that returns an instance of Maybe. When passed the instance, a transformed Result is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns a Result. This means that when used with the Maybe-helpers and compose you have a larger collection of Result returning functions. Copy importResultfrom'crocks/Result' import composeB from'crocks/combinators/composeB' import maybeToResult from'crocks/Result/maybeToResult' importMaybefrom'crocks/Maybe' import getProp from'crocks/Maybe/getProp' const{Ok}=Result const{Just,Nothing}=Maybe maybeToResult('An error occurred',Just('21')) //=> Ok \"21\" maybeToResult('An error occurred',Nothing()) //=> Err \"An error occurred\" // Person :: { name: string, age: Number } // getName :: Person -> Result String const getName =composeB( maybeToResult('Name did not exist or was undefined'), getProp('name') ) getName({ name:'John', age:21}) //=> Ok \"John\" getName({ age:27}) //=> Err \"Name did not exist or was undefined\" Ok(Just('in time!')) .chain(maybeToResult('An error occurred')) //=> Ok \"in time!\" Ok(Nothing()) .chain(maybeToResult('An error occurred')) //=> Err \"An error occurred\" runkit "},{"title":"Max","type":0,"sectionRef":"#","url":"docs/monoids/Max","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Max","url":"docs/monoids/Max#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"Max","url":"docs/monoids/Max#construction","content":"Copy Max :: Number -> Max Number Max is a Monoid fixed to the type of Number and as such requires a Number instance to be passed to the constructor. A new Max instance is returned, wrapping the provided Number. The values undefined, null and NaN will map to the empty (-Infinity) instead of throwing a TypeError. Copy importMaxfrom'crocks/Max' import equals from'crocks/pointfree/equals' Max(99) //=> Max 99 Max(Infinity) //=> Max Infinity Max(null) //=> Max -Infinity equals(Max(undefined),Max.empty()) //=> true runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Max","url":"docs/monoids/Max#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Max","url":"docs/monoids/Max#empty","content":"Copy Max.empty :: () -> Max empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Max the result of empty is -Infinity. empty is available on both the Constructor and the Instance for convenience. Copy importMaxfrom'crocks/Max' Max.empty() //=> Max -Infinity Max.empty() .concat(Max.empty()) //=> Max -Infinity Max(32) .concat(Max.empty()) //=> Max 32 Max.empty() .concat(Max(34)) //=> Max 34 runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Max","url":"docs/monoids/Max#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Max","url":"docs/monoids/Max#equals","content":"Copy Max a ~> b -> Boolean Used to compare the underlying values of (2) Max instances for equality by value, equals takes any given argument and returns true if the passed argument is a Max with an underlying value equal to the underlying value of the Max the method is being called on. If the passed argument is not a Max or the underlying values are not equal, equals will return false. Copy importMaxfrom'crocks/Max' Max(5) .equals(Max(5)) //=> true Max(25) .equals(Max(31)) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Max","url":"docs/monoids/Max#concat","content":"Copy Max ~> Max -> Max concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Max, it will result in the largest of the (2) Numbers. Copy importMaxfrom'crocks/Max' Max(23) .concat(Max(13)) //=> Max 23 Max(-23) .concat(Max(-32)) //=> Max -23 Max.empty() .concat(Max(Infinity)) //=> Max Infinity runkit "},{"title":"valueOf","type":1,"pageTitle":"Max","url":"docs/monoids/Max#valueof","content":"Copy Max ~> () -> Number valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Max instance will result in the underlying Number. Copy importMaxfrom'crocks/Max' Max(4) .valueOf() //=> 4 Max.empty() .valueOf() //=> -Infinity Max(34) .concat(Max(21)) .valueOf() //=> 34 runkit "},{"title":"Min","type":0,"sectionRef":"#","url":"docs/monoids/Min","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Min","url":"docs/monoids/Min#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"Min","url":"docs/monoids/Min#construction","content":"Copy Min :: Number -> Min Number Min is a Monoid fixed to the type of Number and as such requires a Number instance to be passed to the constructor. A new Min instance is returned, wrapping the provided Number. The values undefined, null and NaN will map to the empty (Infinity) instead of throwing a TypeError. Copy importMinfrom'crocks/Min' import equals from'crocks/pointfree/equals' Min(42) //=> Min 42 Min(-Infinity) //=> Min -Infinity Min(undefined) //=> Min Infinity equals(Min(NaN),Min.empty()) //=> true runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Min","url":"docs/monoids/Min#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Min","url":"docs/monoids/Min#empty","content":"Copy Min.empty :: () -> Min empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Min the result of empty is Infinity. empty is available on both the Constructor and the Instance for convenience. Copy importMinfrom'crocks/Min' Min.empty() //=> Min Infinity Min.empty() .concat(Min.empty()) //=> Min Infinity Min(32) .concat(Min.empty()) //=> Min 32 Min.empty() .concat(Min(34)) //=> Min 34 runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Min","url":"docs/monoids/Min#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Min","url":"docs/monoids/Min#equals","content":"Copy Min a ~> b -> Boolean Used to compare the underlying values of (2) Min instances for equality by value, equals takes any given argument and returns true if the passed argument is a Min with an underlying value equal to the underlying value of the Min the method is being called on. If the passed argument is not a Min or the underlying values are not equal, equals will return false. Copy importMinfrom'crocks/Min' Min(5) .equals(Min(5)) //=> true Min(25) .equals(Min(31)) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Min","url":"docs/monoids/Min#concat","content":"Copy Min ~> Min -> Min concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Min, it will result in the smallest of the (2) Numbers. Copy importMinfrom'crocks/Min' Min(50) .concat(Min(24)) //=> Min 24 Min(-120) .concat(Min(-50)) //=> Min -120 Min.empty() .concat(Min(-Infinity)) //=> Min -Infinity runkit "},{"title":"valueOf","type":1,"pageTitle":"Min","url":"docs/monoids/Min#valueof","content":"Copy Min ~> () -> Number valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Min instance will result in the underlying Number. Copy importMinfrom'crocks/Min' Min(33) .valueOf() //=> 33 Min.empty() .valueOf() //=> Infinity Min(35) .concat(Min(20)) .valueOf() //=> 20 runkit "},{"title":"Prod","type":0,"sectionRef":"#","url":"docs/monoids/Prod","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Prod","url":"docs/monoids/Prod#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"Prod","url":"docs/monoids/Prod#construction","content":"Copy Prod :: Number -> Prod Number Prod provides multiplication on Numbers and needs to be constructed with a Number instance. Calling the constructor with a Number, results in a new Prod that wraps the provided Number. Passing undefined, NaN or null to the constructor will result in an empty instance, or an instance containing a 1. Copy importProdfrom'crocks/Prod' import equals from'crocks/pointfree/equals' Prod(100) //=> Prod 100 Prod(-Infinity) //=> Prod -Infinity Prod(undefined) //=> Prod 1 equals(Prod(null),Prod.empty()) //=> true runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Prod","url":"docs/monoids/Prod#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Prod","url":"docs/monoids/Prod#empty","content":"Copy Prod.empty :: () -> Prod empty provides the identity for the Monoid in that when the value it provides is concated to object other value, it will return the other value. In the case of Prod the result of empty is 1. empty is available on both the Constructor and the Instance for convenience. Copy importProdfrom'crocks/Prod' Prod.empty() //=> Prod 1 Prod.empty() .concat(Prod.empty()) //=> Prod 1 Prod(4) .concat(Prod.empty()) //=> Prod 4 Prod.empty() .concat(Prod(4)) //=> Prod 4 runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Prod","url":"docs/monoids/Prod#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Prod","url":"docs/monoids/Prod#equals","content":"Copy Prod a ~> b -> Boolean Used to compare the underlying values of (2) Prod instances for equality by value, equals takes any given argument and returns true if the passed argument is a Prod with an underlying value equal to the underlying value of the Prod the method is being called on. If the passed argument is not a Prod or the underlying values are not equal, equals will return false. Copy importProdfrom'crocks/Prod' Prod(5) .equals(Prod(5)) //=> true Prod(25) .equals(Prod(31)) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Prod","url":"docs/monoids/Prod#concat","content":"Copy Prod ~> Prod -> Prod concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Prod, concat will multiply the (2) Numbers. Copy importProdfrom'crocks/Prod' Prod(5) .concat(Prod(4)) //=> Prod 20 Prod(45) .concat(Prod(32)) //=> Prod 1440 Prod(1000) .concat(Prod(Infinity)) //=> Prod Infinity Prod.empty() .concat(Prod(3)) //=> Prod 3 runkit "},{"title":"valueOf","type":1,"pageTitle":"Prod","url":"docs/monoids/Prod#valueof","content":"Copy Prod ~> () -> Number valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Prod instance will result in the underlying Number. Copy importProdfrom'crocks/Prod' Prod.empty() .valueOf() //=> 1 Prod(4) .valueOf() //=> 4 Prod(34) .concat(Prod(21)) .valueOf() //=> 714 runkit "},{"title":"Endo","type":0,"sectionRef":"#","url":"docs/monoids/Endo","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Endo","url":"docs/monoids/Endo#implements","content":"Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"Endo","url":"docs/monoids/Endo#construction","content":"Copy Endo :: (a -> a) -> Endo a Endo is constructed by passing the constructor an Endomorphism, which is a function in which the domain/codomain (src/target) are of the same type. For example a function that is String -> String. There is no type checking on the provided function, so some discipline on the part of the user is required to make sure the proper type is being used on in all cases. This can be partly mitigated by using an Endomorphism of the type Maybe a. Then the supplied functions could do type checking and return Nothing if the types do not match up. Copy importEndofrom'crocks/Endo' Endo(x=> x +5) //=> Endo (Number -> Number) runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Endo","url":"docs/monoids/Endo#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Endo","url":"docs/monoids/Endo#empty","content":"Copy Endo.empty :: () -> Endo a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Endo the result of empty is the identity function, which echoes its input. empty is available on both the Constructor and the Instance for convenience. Copy importEndofrom'crocks/Endo' import runWith from'crocks/pointfree/runWith' // empty :: Endo a const empty =Endo.empty() // toUpper :: Endo String const toUpper = Endo(x=> x.toUpperCase()) // runNice :: Endo String -> String const runNice = runWith('nice') runNice(empty.concat(toUpper)) //=> \"NICE\" runNice(toUpper.concat(empty)) //=> \"NICE\" runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Endo","url":"docs/monoids/Endo#instance-methods","content":""},{"title":"concat","type":1,"pageTitle":"Endo","url":"docs/monoids/Endo#concat","content":"Copy Endo a ~> Endo a -> Endo a concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Endo, it will combine (2) endofunctions under function composition. Copy importEndofrom'crocks/Endo' import setProp from'crocks/helpers/setProp' import mapProps from'crocks/helpers/mapProps' import objOf from'crocks/helpers/objOf' // inc :: Number -> Number constinc= x=> x +1 // incValue :: Endo Object const incValue = Endo(mapProps({ value: inc })) // addDone :: Endo Object const addDone = Endo(setProp('done',true)) // finish :: Endo Object const packResults = Endo(objOf('results')) // finish :: Endo Object const finish = incValue.concat(addDone) finish.runWith({ value:99}) //=> { value: 100, done: true } finish .concat(packResults) .runWith({ value:99}) //=> { results: { value: 100, done: true } } runkit "},{"title":"valueOf","type":1,"pageTitle":"Endo","url":"docs/monoids/Endo#valueof","content":"Copy Endo a ~> () -> (a -> a) valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on an Endo instance will result in the underlying endofunction. Copy importEndofrom'crocks/Endo' import filter from'crocks/pointfree/filter' import map from'crocks/pointfree/map' import mconcat from'crocks/helpers/mconcat' // lt10 :: [ Number ] -> [ Number ] const lt10 = filter(x=> x <10) // double :: [ Number ] -> [ Number ] const double = map(x=> x *2) // buildEndo :: [ (a -> a) ] -> Endo a const buildEndo = mconcat(Endo) // fn :: [ Number ] -> [ Number ] const fn = buildEndo([ lt10, double ]) .valueOf() fn([12,5,3,90]) //=> [ 10, 6 ] fn([]) //=> [] runkit "},{"title":"runWith","type":1,"pageTitle":"Endo","url":"docs/monoids/Endo#runwith","content":"Copy Endo a ~> a -> a Endo wraps a function and as such, its underlying endofunction can be run while inside of an Endo by calling runWith. Providing a valid value of the same type required by the function, runWith will execute the underlying function and return the result. Copy importEndofrom'crocks/Endo' import filter from'crocks/pointfree/filter' import map from'crocks/pointfree/map' import mconcat from'crocks/helpers/mconcat' // lt10 :: [ Number ] -> [ Number ] const lt10 = filter(x=> x <10) // double :: [ Number ] -> [ Number ] const double = map(x=> x *2) // buildEndo :: [ (a -> a) ] -> Endo a const flow = mconcat(Endo,[ lt10, double ]) flow .runWith([12,5,3,90]) //=> [ 10, 6 ] flow .runWith([]) //=> [] runkit "},{"title":"Helpers","type":0,"sectionRef":"#","url":"docs/functions/helpers","content":"","keywords":""},{"title":"assign","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#assign","content":"crocks/helpers/assign Copy assign :: Object -> Object -> Object When working with Objects, a common operation is to combine (2) of them. This can be accomplished in crocks by reaching for assign. Unlike the Object.assign that ships with JavaScript, this assign will combine your Objects into a new shallow copy of their merger. assign only takes two arguments and will overwrite keys present in the second argument with values from the first. As with most of the crocksObject based functions, assign will omit any key-value pairs that are undefined. Check out a related function named defaultProps that will only assign values that are undefined in the second argument. "},{"title":"binary","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#binary","content":"crocks/helpers/binary Copy binary :: ((*) -> c) -> a -> b -> c With all the different functions out there in the real world, sometimes it is nice to restrict them to a specific -arity to work with your all your wonderful compositions. When you want to restrict any function of any arity to a simple binary function. Just pass your function to binary and you will get back a curried, binary function that will only apply (2) arguments to the inner function, ignoring any others. This works very well with functions like Array.prototype.reduce where you may only care about the first 2 arguments. if you need to constrain to more than (2) arguments, then you will want to reach for nAry. binary is basically syntactic sugar for nAry(2, fn). Also related is unary, which constrains to (1) argument. "},{"title":"compose","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#compose","content":"crocks/helpers/compose Copy compose :: ((y -> z), ..., (a -> b)) -> a -> z While the composeB can be used to create a composition of two functions, there are times when you want to compose an entire flow together. That is where compose is useful. With compose you can create a right-to-left composition of functions. It will return you a function that represents your flow. crocks provides a means to build compostions using a left-to-right style in the form of pipe. Copy import compose from'crocks/helpers/compose' import objOf from'crocks/helpers/objOf' // double :: Number -> Number constdouble=x=> x + x // doubleAndWrap :: Number -> Object const doubleAndWrap =compose( objOf('result'), double ) doubleAndWrap(25) //=> { result: 50 } doubleAndWrap(0) //=> { result: 0 } runkit "},{"title":"composeK","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#composek","content":"crocks/helpers/composeK Copy composeK :: Chain m => ((y -> m z), ..., (a -> m b)) -> a -> m z There are many times that, when working with the various crocks, our flows are just a series of chains. Due to some neat properties with types that provide a chain function, you can remove some boilerplate by reaching for composeK. Just pass it the functions you would normally pass to chain and it will do all the boring hook up for you. Just like compose, functions are applied right-to-left, so you can turn this: Copy import compose from'crocks/helpers/compose' import chain from'crocks/pointfree/chain' import getProp from'crocks/Maybe/getProp' import isObject from'crocks/predicates/isObject' import safe from'crocks/Maybe/safe' const data ={ do:{ re:{ mi:'fa' } } } // fluent :: a -> Maybe b constfluent=x=> safe(isObject, x) .chain(getProp('do')) .chain(getProp('re')) .chain(getProp('mi')) fluent(data) //=> Just 'fa' // pointfree :: a -> Maybe b const pointfree =compose( chain(getProp('mi')), chain(getProp('re')), chain(getProp('do')), safe(isObject) ) pointfree(data) //=> Just 'fa' runkit into the more abbreviated form: Copy import composeK from'crocks/helpers/composeK' import getProp from'crocks/Maybe/getProp' import isObject from'crocks/predicates/isObject' import safe from'crocks/Maybe/safe' const data ={ do:{ re:{ mi:'fa' } } } // flow :: a -> Maybe b const flow =composeK( getProp('mi'), getProp('re'), getProp('do'), safe(isObject) ) flow(data) //=> Just 'fa' runkit As demonstrated in the above example, this function more closely resembles flows that are using a more pointfree style of coding. As with the other composition functions in crocks, a pipeK function is provided for flows that make more sense expressed in a left-to-right style. "},{"title":"composeP","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#composep","content":"crocks/helpers/composeP Copy composeP :: Promise p => ((y -> p z c), ..., (a -> p b c)) -> a -> p z c When working with Promises, it is common place to create chains on a Promise's then function. Doing this involves a lot of boilerplate and forces you into a fluent style, whether you want to be or not. Using composeP you have the option to compose a series of Promise returning functions like you would any other function composition, in a right-to-left fashion. Due to the nature of the then function, only the head of your composition needs to return a Promise. This will create a function that takes a value, which is passed through your chain, returning a Promise which can be extended. This is only a then chain, it does not do anything with the catch function. If you would like to provide your functions in a left-to-right manner, check out pipeP. Copy import composeP from'crocks/helpers/composeP' importAsyncfrom'crocks/Async' import asyncToPromise from'crocks/Async/asyncToPromise' import composeB from'crocks/combinators/composeB' const{ resolveAfter }=Async // resolveQuick :: a -> Async e a constresolveQuick=value=> resolveAfter(300, value) // promiseSomething :: a -> Promise a e const promiseSomething =composeB( asyncToPromise, resolveQuick ) // log :: a -> () constlog=x=> console.log(x) // sayHello :: String -> String constsayHello=to=> `Hello ${to}` // emphasize :: String -> String constemphasize=to=> `${to}!` // promFunc :: a -> Promise a e constpromFunc=x=> promiseSomething(x) .then(emphasize) .then(sayHello) // composedPromFunc :: a -> Promise a e const composedPromFunc = composeP(sayHello, emphasize, promiseSomething) promFunc('World') .then(log) //=> Hello World! composedPromFunc('World') .then(log) //=> Hello World! runkit "},{"title":"composeS","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#composes","content":"crocks/helpers/composeS Copy composeS :: Semigroupoid s => (s y z, ..., s a b) -> s a z When working with things like Arrow and Star there will come a point when you would like to compose them like you would any Function. That is where composeS comes in handy. Just pass it the Semigroupoids you want to compose and it will give you back a new Semigroupoid of the same type with all of the underlying functions composed and ready to be run. Like compose, composeS composes the functions in a right-to-left fashion. If you would like to represent your flow in a more left-to-right manner, then pipeS is provided for such things. Copy importArrowfrom'crocks/Arrow' import bimap from'crocks/pointfree/bimap' import branch from'crocks/Pair/branch' import composeS from'crocks/helpers/composeS' import merge from'crocks/pointfree/merge' import mreduce from'crocks/helpers/mreduce' importSumfrom'crocks/Sum' // length :: a -> Number constlength=xs=> xs.length // divide :: (Number, Number) -> Number constdivide=(x, y)=> x / y // avg :: Arrow [ Number ] Number const avg = Arrow(bimap(mreduce(Sum), length)) .promap(branch,merge(divide)) // double :: Arrow Number Number const double = Arrow(x=> x *2) // data :: [ Number ] const data = [34,198,3,43,92] composeS(double, avg) .runWith(data) //=> 148 runkit "},{"title":"curry","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#curry","content":"crocks/helpers/curry Copy curry :: ((a, b, ...) -> z) -> a -> b -> ... -> z Pass this function a function and it will return you a function that can be called in any form that you require until all arguments have been provided. For example if you pass a function: f : (a, b, c) -> d you get back a function that can be called in any combination, such as: f(x, y, z), f(x)(y)(z),f(x, y)(z), or even f(x)(y, z). That is to say, this function fulfills the role of both curry and uncurry, returning a function that can be used as a curried function, an uncurried function, or any combination of argument applications in between. The returned function has 2^(n-1) type signatures, where n is the number of parameters. Copy import compose from'crocks/helpers/compose' import curry from'crocks/helpers/curry' import map from'crocks/pointfree/map' import prop from'crocks/maybe/prop' // add :: (Number, Number, Number) -> Number constadd=(a, b, c)=> a + b + c // partial application impossible add(1) //=> NaN // 1 + undefined + undefined => NaN // crocksCurriedAdd :: Number -> Number -> Number -> Number const crocksCurriedAdd = curry(add) // appliedAdd :: Number -> Number -> Number const appliedAdd = crocksCurriedAdd(1) appliedAdd(1,1) //=> 3 crocksCurriedAdd(1)(2)(3) crocksCurriedAdd(1,2)(3) crocksCurriedAdd(1)(2,3) crocksCurriedAdd(1,2,3) //=> 6 // strictCurriedPluck :: String -> [ a ] -> Maybe b const strictCurriedPluck = compose(map, prop) const crockCurriedPluck = curry(strictCurriedPluck) // data :: [ { a: String, b: String } ] const data =[ { a:'nice'}, { a:'great', b:'nice'}, { b:'nice'} ] strictCurriedPluck('a')(data) //=> [ Just \"nice\", Just \"great\", Nothing ] crockCurriedPluck('a', data) //=> [ Just \"nice\", Just \"great\", Nothing ] runkit An important caveat when using curry with functions containing optional parameters, is that the defaults are applied immediately, reducing the number of partial applications to just the number of required parameters. Adding optional parameters to functions may not be a good choice if the intention is to use them with curry, as the ability to change the defaults is lost. Parameters are applied up until the first optional parameter, at which point subsequent parameters either receive the declared default or go undefined. Copy import curry from'crocks/helpers/curry' // curriedConsolelog :: [ (Object | String) ] -> () const curriedConsolelog = curry(console.log) curriedConsolelog('Hello %s','World') //=> Hello %s curriedConsolelog('Hello','World') //=> Hello runkit "},{"title":"defaultProps","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#defaultprops","content":"crocks/helpers/defaultProps Copy defaultProps :: Object -> Object -> Object Picture this, you have an Object and you want to make sure that some properties are set with a given default value. When the need for this type of operation presents itself, defaultProps can come to your aid. Just pass it an Object that defines your defaults and then the Object your want to default those props on. If a key that is present on the defaults Object is not defined on your data, then the default value will be used. Otherwise, the value from your data will be used instead. You could just apply flip to the assign function and get the same result, but having a function named defaultProps may be easier to read in code. As with most Object related functions in crocks, defaultProps will return you a shallow copy of the result and not include any undefined values in either Object. "},{"title":"defaultTo","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#defaultto","content":"crocks/helpers/defaultTo Copy defaultTo :: a -> b -> a With things like null, undefined and NaN showing up all over the place, it can be hard to keep your expected types inline without resorting to nesting in a Maybe with functions like safe. If you want to specifically guard for null, undefined and NaN and get things defaulted into the expected type, then defaultTo should work for you. Just pass it what you would like your default value to be and then the value you want guarded, and you will get back either the default or the passed value, depending on if the passed value is null, undefined or NaN. While this is JavaScript and you can return anything, it is suggested to stick to the signature and only let as through. As a b can be an a as well. "},{"title":"fromPairs","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#frompairs","content":"crocks/helpers/fromPairs Copy fromPairs :: Foldable f => f (Pair String a) -> Object As an inverse to toPairs, fromPairs takes either an Array or List of key-value Pairs and constructs an Object from it. The Pair must contain a String in the fst and any type of value in the snd. The fst will become the key for the value in the snd. All primitive values are copied into the new Object, while non-primitives are references to the original. If you provide an undefined values for the second, that Pair will not be represented in the resulting Object. Also, when if multiple keys share the same name, that last value will be moved over. "},{"title":"getPathOr","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#getpathor","content":"crocks/helpers/getPathOr Copy getPathOr :: a -> [ (String | Integer) ] -> b -> a While getPropOr is good for simple, single-level structures, there may come a time when you have to work with nested POJOs or Arrays. When you run into this situation, just pull in getPathOr, which was previously called propPathOr, and pass it a left-to-right traversal path of keys, indices or a combination of both (gross...but possible). This will kick you back a function that behaves just like getPropOr. You pass it some data, and it will attempt to resolve your provided path. If the path is valid, it will return the value. But if at any point that path \"breaks\" it will give you back the default value. Copy import getPathOr from'crocks/helpers/getPathOr' const data ={ foo:{ bar:'bar', null:null, nan:NaN, undef:undefined }, arr:[1,2] } // def :: [ String | Integer ] -> a -> b const def = getPathOr('default') def(['foo','bar'], data) //=> \"bar\" def(['baz','tommy'], data) //=> \"default\" def(['foo','null'], data) //=> null def(['foo','nan'], data) //=> NaN def(['foo','undef'], data) //=> \"default\" def(['arr','length'], data) //=> 2 runkit "},{"title":"getPropOr","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#getpropor","content":"crocks/helpers/getPropOr Copy getPropOr :: a -> (String | Integer) -> b -> a Reach for getPropOr, previously known as propOr, when you want some safety around pulling a value out of an Object or Array with a single key or index. Well, as long as you are working with non-nested data that is. Just tell getPropOr either the key or index you are interested in, and you will get back a function that will take anything and return the wrapped value if the key/index is defined. If the key/index is not defined however, you will get back the provided default value. Copy import getPropOr from'crocks/helpers/getPropOr' const data ={ foo:'bar', null:null, nan:NaN, undef:undefined } // def :: (String | Integer) -> a -> b const def = getPropOr('default') def('foo', data) //=> \"bar\" def('null', data) //=> null def('nan', data) //=> NaN def('baz', data) //=> \"default\" def('undef', data) //=> \"default\" runkit "},{"title":"liftA2","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#lifta2","content":"crocks/helpers/liftA2 Copy liftA2 :: Applicative m => (a -> b -> c) -> m a -> m b -> m c "},{"title":"liftA3","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#lifta3","content":"crocks/helpers/liftA3 Copy liftA3 :: Applicative m => (a -> b -> c -> d) -> m a -> m b -> m c -> m d Ever see yourself wanting to map a binary or trinary function, but map only allows unary functions? Both of these functions allow you to pass in your function as well as the number of Applicatives (containers that provide both of and ap functions) you need to get the mapping you are looking for. "},{"title":"liftN","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#liftn","content":"crocks/helpers/liftN Copy liftN :: Applicative m => Number -> ((*) -> a) -> (*m) -> m a While liftA2 and liftA3 will handle a majority of the functions we tend to encounter, many cases arise when we want to deal with functions of a greater arity. In those cases, liftN will allow the lifting of function of any size arity. liftN takes a Number that specifies the arity of the function to be lifted, followed by the function itself and finally the required number of Applicative instances of the same type to be applied to the target function. In most cases, there is no need to explicitly curry the target function. This function operates in the same vein as nAry and as such manually curried functions (i.e. x => y => x + y) will need to be explicitly curried using curry to ensure proper application of the arguments. Copy import liftN from'crocks/helpers/liftN' import compose from'crocks/helpers/compose' import curry from'crocks/helpers/curry' import isNumber from'crocks/predicates/isNumber' import isString from'crocks/predicates/isString' import map from'crocks/pointfree/map' import safe from'crocks/Maybe/safe' // apply :: (((*) -> b), [ a ]) -> b constapply=fn=>xs=> fn.apply(null, xs) // join :: String -> String -> String constjoin=x=>y=> `${x}${y}` // safeString :: a -> Maybe String const safeString = safe(isString) // sumArgs :: (* Number) -> Number constsumArgs=(...args)=> args.reduce((x, y)=> x + y,0) // max :: Applicative m => [ m Number ] -> m Number const max = apply(liftN(4,Math.max)) // sum :: Applicative m => [ m Number ] -> m Number const sum = apply(liftN(4, sumArgs)) // apJoin :: Applicative m => [ m String ] -> m String const apJoin = liftN(2,curry(join)) // good :: [ Number ] const good = [45,54,96,99] // bad :: [ String ] const bad = ['one','two','three','four'] // arMax :: [ Number ] -> [ Number ] const arMax = compose(max,map(Array.of)) // safeSum :: Maybe Number -> Maybe Number const safeSum = compose(sum,map(safe(isNumber))) arMax(good) //=> [ 99 ] safeSum(good) //=> Just 294 safeSum(bad) //=> Nothing apJoin(safeString('Joey'),safeString('Fella')) //=> Just \"Joey Fella\" apJoin(safeString(9),safeString('Fella')) //=> Nothing runkit "},{"title":"mapProps","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#mapprops","content":"crocks/helpers/mapProps Copy mapProps :: { (* -> *) } -> Object -> Object Would like to map specific keys in an Object with a specific function? Just bring in mapProps and pass it an Object with the functions you want to apply on the keys you want them associated to. When the resulting function receives an Object, it will return a new Object with the keys mapped according to the mapping functions. All keys from the original Object that do not exist in the mapping Object will still exist untouched, but the keys with mapping functions with now contain the result of applying the original value to the provided mapping function. mapProps also allows for mapping on nested Objects for times when the shape of the original Object is know. Copy import mapProps from'crocks/helpers/mapProps' // add :: Number -> Number -> Number constadd=x=>y=> x + y // toUpper :: String -> String consttoUpper=x=> x.toUpperCase() // mapping :: Object const mapping ={ entry: toUpper, fauna:{ unicorns:add(1), elephants:add(-1) }, flora:{ nariphon:add(10), birch:add(1) } } mapProps(mapping,{ entry:'legend', fauna:{ unicorns:10, zombies:3 }, other:{ hat:2 } }) //=> { entry: 'LEGEND', fauna: { unicorns: 11, zombies: 3 }, other: { hat: 2} } runkit "},{"title":"mapReduce","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#mapreduce","content":"crocks/helpers/mapReduce Copy mapReduce :: Foldable f => (a -> b) -> (c -> b -> c) -> c -> f a -> c Sometimes you need the power provided by mreduceMap but you do not have a Monoid to lift into. mapReduce provides the same power, but with the flexibility of using functions to lift and combine. mapReduce takes a unary mapping function, a binary reduction function, the initial value and finally a Foldable structure of data. Once all arguments are provided,mapReduce folds the provided data, by mapping each value through your mapping function, before sending it to the second argument of your reduction function. Copy import mapReduce from'crocks/helpers/mapReduce' import isNumber from'crocks/predicates/isNumber' importMaybefrom'crocks/Maybe' importMaxfrom'crocks/Max' import safeLift from'crocks/Maybe/safeLift' const{Nothing}=Maybe // data :: [ * ] const data = ['100',null,3,true,1] // safeMax :: [ * ] -> Maybe Max const safeMax =mapReduce( safeLift(isNumber,Max), (y, x)=> y.concat(x).alt(y).alt(x), Nothing() ) safeMax(data) .option(Max.empty()) .valueOf() //=> 3 runkit "},{"title":"mconcat","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#mconcat","content":"crocks/helpers/mconcat Copy mconcat :: Monoid m, Foldable f => m -> f a -> m a "},{"title":"mreduce","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#mreduce","content":"crocks/helpers/mreduce Copy mreduce :: Monoid m, Foldable f => m -> f a -> a These two functions are very handy for combining an entire List or Array of values by providing a Monoid and your collection of values. The difference between the two is that mconcat returns the result inside the Monoid used to combine them. Where mreduce returns the bare value itself. "},{"title":"mconcatMap","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#mconcatmap","content":"crocks/helpers/mconcatMap Copy mconcatMap :: Monoid m, Foldable f => m -> (b -> a) -> f b -> m a "},{"title":"mreduceMap","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#mreducemap","content":"crocks/helpers/mreduceMap Copy mreduceMap :: Monoid m, Foldable f => m -> (b -> a) -> f b -> a There comes a time where the values you have in a List or an Array are not in the type that is needed for the Monoid you want to combine with. These two functions can be used to map some transforming function from a given type into the type needed for the Monoid. In essence, this function will run each value through the function before it lifts the value into the Monoid, before concat is applied. The difference between the two is that mconcatMap returns the result inside the Monoid used to combine them. Where mreduceMap returns the bare value itself. "},{"title":"nAry","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#nary","content":"crocks/helpers/nAry Copy nAry :: Number -> ((*) -> a) -> (*) -> a When using functions like Math.max or Object.assign that take as many arguments as you can throw at them, it makes it hard to curry them in a reasonable manner. nAry can make things a little nicer for functions like that. It can also be put to good use to limit a given function to a desired number of arguments to avoid accidentally supplying default arguments when you do not what them applied. First pass nAry the number of arguments you wish to limit the function to and then the function you wish to limit. nAry will give you back a curried function that will only apply the specified number of arguments to the inner function. Unary and binary functions are so common that crocks provides specific functions for those cases: unary and binary. "},{"title":"objOf","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#objof","content":"crocks/helpers/objOf Copy objOf :: String -> a -> Object If you ever find yourself in a situation where you have a key and a value and just want to combine the two into an Object, then it sounds like objOf is the function for you. Just pass it a String for the key and any type of value, and you'll get back an Object that is composed of those two. If you find yourself constantly concatenating the result of this function into another Object, you may want to use assoc instead. "},{"title":"omit","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#omit","content":"crocks/helpers/omit Copy omit :: [ String ] -> Object -> Object Sometimes you just want to strip Objects of unwanted properties by key. Using omit will help you get that done. Just pass it a Foldable structure with a series of Strings as keys and then pass it an Object and you will get back not only a shallow copy, but also an Object free of any of those pesky undefined values. You can think of omit as a way to black-list or reject Object properties based on key names. This function ignores inherited properties and should only be used with POJOs. If you want to filter or white-list properties rather than reject them, take a look at pick. "},{"title":"once","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#once","content":"crocks/helpers/once Copy once :: ((*) -> a) -> ((*) -> a) There are times in JavaScript development where you only want to call a function once and memo-ize the first result for every subsequent call to that function. Just pass the function you want guarded to once and you will get back a function with the expected guarantees. "},{"title":"partial","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#partial","content":"crocks/helpers/partial Copy partial :: (((*) -> c), *) -> (*) -> c There are many times when using functions from non-functional libraries or from built-in JS functions, where it does not make sense to wrap it in a curry. You just want to partially apply some arguments to it and get back a function ready to take the rest. That is a perfect opportunity to use partial. Just pass a function as the first argument and then apply any other arguments to it. You will get back a curried function that is ready to accept the rest of the arguments. Copy import partial from'crocks/helpers/partial' import map from'crocks/pointfree/map' // max10 :: Number -> Number const max10 = partial(Math.min,10) // data :: [ Number ] const data = [13,5,13] map(max10, data) //=> [ 10, 5, 10] runkit "},{"title":"pick","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#pick","content":"crocks/helpers/pick Copy pick :: Foldable f => f String -> Object -> Object When dealing with Objects, sometimes it is necessary to only let some of the key-value pairs on an object through. Think of pick as a sort of white-list or filter for Object properties. Pass it a Foldable structure of Strings that are the keys you would like to pick off of your Object. This will give you back a shallow copy of the key-value pairs you specified. This function will ignore inherited properties and should only be used with POJOs. Any undefined values will not be copied over, although null values are allowed. For black-listing properties, have a look at omit. "},{"title":"pipe","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#pipe","content":"crocks/helpers/pipe Copy pipe :: ((a -> b), ..., (y -> z)) -> a -> z Similar to compose, pipe allows for the composition of functions, but takes its functions in a left-to-right fashion, which is the opposite of compose. Just like compose, pipewill return a new function that represents the composed flow. Copy import pipe from'crocks/helpers/pipe' import objOf from'crocks/helpers/objOf' // double :: Number -> Number constdouble=x=> x + x // doubleAndWrap :: Number -> Object const doubleAndWrap =pipe( double, objOf('result') ) doubleAndWrap(25) //=> { result: 50 } doubleAndWrap(0) //=> { result: 0 } runkit "},{"title":"pipeK","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#pipek","content":"crocks/helpers/pipeK Copy pipeK :: Chain m => ((a -> m b), ..., (y -> m z)) -> a -> m z Like composeK, you can remove much of the boilerplate when chaining together a series of functions with the signature:Chain m => a -> m b. The difference between the two functions is, whilecomposeK is right-to-left, pipeK is the opposite, taking its functions left-to-right. Copy import pipeK from'crocks/helpers/pipeK' import curry from'crocks/core/curry' importListfrom'crocks/List' importWriterfrom'crocks/Writer' // OpWriter :: Writer List constOpWriter= Writer(List) // addLog :: Number -> Number -> OpWriter Number const addLog =curry( (x, y)=> OpWriter(`adding ${x} to ${y}`, x + y) ) // addLog :: Number -> Number -> OpWriter Number const scaleLog =curry( (x, y)=> OpWriter(`scaling ${y} by ${x}`, x * y) ) constfluent=x=> OpWriter.of(x) .chain(addLog(4)) .chain(scaleLog(3)) fluent(0).log() //=> List [ \"adding 4 to 0\", \"scaling 4 by 3\" ] const chainPipe =pipeK( addLog(4), scaleLog(3) ) chainPipe(0).log() //=> List [ \"adding 4 to 0\", \"scaling 4 by 3\" ] runkit "},{"title":"pipeP","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#pipep","content":"crocks/helpers/pipeP Copy pipeP :: Promise p => ((a -> p b d), ..., (y -> p z d)) -> a -> p z d Like the composeP function, pipeP will let you remove the standard boilerplate that comes with working with Promise chains. The only difference between pipeP and composeP is that it takes its functions in a left-to-right order: Copy import pipeP from'crocks/helpers/pipeP' importAsyncfrom'crocks/Async' import asyncToPromise from'crocks/Async/asyncToPromise' import composeB from'crocks/combinators/composeB' const{ resolveAfter }=Async // prod :: Number -> Number -> Number constprod=a=>b=> b * a // resolveQuick :: a -> Async e a constresolveQuick=value=> resolveAfter(300, value) // promise :: a -> Promise a e const promise =composeB( asyncToPromise, resolveQuick ) // double :: Number -> Number const double = prod(2) // triple :: Number -> Number const triple = prod(3) // promFunc :: Number -> Promise Number e constpromFunc=x=> promise(x) .then(double) .then(triple) // promPipe :: Number -> Promise Number e const promPipe = pipeP(promise, double, triple) promFunc(5) .then(v=>console.log(v)) //=> 30 promPipe(5) .then(v=>console.log(v)) //=> 30 runkit "},{"title":"pipeS","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#pipes","content":"crocks/helpers/pipeS Copy pipeS :: Semigroupoid s => (s a b, ..., s y z) -> s a z While Stars and Arrows come in very handy at times, the only thing that could make them better is to compose them. With pipeS you can do just that with any Semigroupoid. Just like with composeS, you just pass it Semigroupoids of the same type and you will get back another Semigroupoid with them all composed together. The only difference between the two, is that pipeS composes in a left-to-right fashion, while composeS does the opposite. Copy import pipeS from'crocks/helpers/pipeS' importMaybefrom'crocks/Maybe' import curry from'crocks/core/curry' import getProp from'crocks/Maybe/getProp' import isNumber from'crocks/predicates/isNumber' import safeLift from'crocks/Maybe/safeLift' importStarfrom'crocks/Star' // MaybeStar :: Star a (Maybe b) constMaybeStar= Star(Maybe) // add :: Number -> Number -> Number const add =curry( (x, y)=> x + y ) // pull :: String -> MaybeStar Object Number constpull=x=> MaybeStar(getProp(x)) // safeAdd :: Number -> MaybeStar Number Number constsafeAdd=x=> MaybeStar(safeLift(isNumber,add(x))) // data :: { num: Number, string: String } const data ={ num:56, string:'56' } // flow :: (String, Number) -> MaybeStar Object Number constflow=(key, num)=>pipeS( pull(key), safeAdd(num) ) flow('num',10) .runWith(data) //=> Just 66 flow('string',100) .runWith(data) //=> Nothing runkit "},{"title":"setPath","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#setpath","content":"crocks/helpers/setPath Copy setPath :: [ (String | Integer) ] -> a -> (Object | Array) -> (Object | Array) Used to set a value on a deeply nested Object, setPath will traverse down a path and set the a the final property to the provided value. setPath returns the an Object/Array with the modification and does not alter the original Object/Array along the path. The provided path can be a mixture of either Integers or Strings to allow for traversing through both Arrays and Objects. When an Integer zero or greater is provided it will treat that portion as an Array while Strings are used to reference through Objects. If at any point in the provided a NaN, undefined or null values is encountered, a new Object/Array will be created. Copy import setPath from'crocks/helpers/setPath' setPath(['account','name'],'Awesome Place',{ account:{ name:'Great Place', rating:5 } }) //=> { account: { name: 'Awesome Place', rating: 5 } } setPath(['people',2,'age'],26,{ people:[ { name:'George', age:22}, { name:'Greta', age:21}, { name:'Ali', age:25} ] }) //=> { people: [ // { name: 'George', age: 22 }, // { name: 'Greta', age: 21 }, // { name: 'Ali', age: 26 }, // ] } setPath(['a','c'],false,{ a:{ b:true}}) //=> { a: { b: true, c: false } } setPath(['list','a'],'ohhh, I see.',{ list:['string','another']}) //=> { list: { 0: 'string', 1: 'another', a: 'ohhh, I see.' } } runkit "},{"title":"setProp","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#setprop","content":"crocks/helpers/setProp Copy setProp :: (String | Integer) -> a -> (Object | Array) -> (Object | Array) Used to set a given value for a specific key or index of an Object or Array. setProp, previously called assoc, takes either a String or Integer value as its first argument and a value of any type as its second. The third parameter is dependent of the type of the first argument. When a String is provided, the third argument must be an Object. Otherwise if the first argument is an Integer zero or greater, then the third must be an Array. setProp will return a new instance of either Object or Array with the addition applied. When the value exists on the provided object, then the value will overwritten. If the value does not exist then it will be added to the resulting structure. In the case of Array, the value will be added to the provided index, leaving undefined values, resulting in a sparse Array. Copy import setProp from'crocks/helpers/setProp' setProp('a',false,{ a:true}) //=> { a: false } setProp('b',43,{ a:true}) //=> { a: true, b: 43 } setProp(0,'string',['a']) //=> [ \"string\" ] setProp(1,'b',['a']) //=> [ \"a\", \"b\" ] setProp(2,'c',['a']) //=> [ \"a\", undefined, \"c\" ] runkit "},{"title":"tap","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#tap","content":"crocks/helpers/tap Copy tap :: (a -> b) -> a -> a It is hard knowing what is going on inside of some of these ADTs or your wonderful function compositions. Debugging can get messy when you need to insert a side-effect into your flow for introspection purposes. With tap, you can intervene in your otherwise pristine flow and make sure that the original value is passed along to the next step of your flow. This function does not guarantee immutability for reference types (Objects, Arrays, etc), you will need to exercise some discipline here to not mutate. "},{"title":"tryCatch","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#trycatch","content":"crocks/Result/tryCatch Copy tryCatch :: ((*) -> b) -> (*) -> Result e b Typical try-catch blocks are very imperative in their usage. This tryCatch function provides a means of capturing that imperative nature in a simple declarative style. Pass it a function that could fail and it will return you another function wrapping the first function. When called, the new function will either return the result in a Result.Ok if everything was good, or an error wrapped in an Result.Err if it fails. "},{"title":"unary","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#unary","content":"crocks/helpers/unary Copy unary :: ((*) -> b) -> a -> b If you every need to lock down a given function to just one argument, then look no further than unary. Just pass it a function of any arity, and you will get back another function that will only apply (1) argument to given function, no matter what is passed to it. unary is just syntactic sugar aroundnAry in the form of nAry(1, fn) as it is such a common case. Another common case is binary which, as the name implies, only applies (2) arguments to a given function. "},{"title":"unit","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#unit","content":"crocks/helpers/unit Copy unit :: () -> undefined While it seems like just a simple function, unit can be used for a number of things. A common use for it is as a default noop as it is a function that does nothing and returns undefined. You can also use it in a pointed fashion to represent some special value for a given type. This pointed use is the heart and soul of the infamous Maybe type. "},{"title":"unsetPath","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#unsetpath","content":"crocks/helpers/unsetPath Copy unsetPath :: [ (String | Integer) ] -> a -> a Used to remove a property or index on a deeply nested Object/Array.unsetPath, previously called dissoc, will return a new instance with the property or index removed. The provided path can be a mixture of either Positive Integers or Strings to allow for traversing through both Arrays and Objects. When an Integer is provided it will treat that portion as an Array while Strings are used to reference through Objects. Copy import unsetPath from'crocks/helpers/unsetPath' unsetPath(['people',0,'remove'],{ people:[ { name:'Tonya', remove:true}, { name:'Bobby'} ] }) //=> { people: [ { name: 'Tonya' }, { name: 'Bobby' } ] } unsetPath(['a','c','d'],{ a:null}) //=> { a: null } unsetPath(['a','b'],{ a:{ b:false}}) //=> { a: {} } unsetPath(['a','b'],{ a:{ c:false}}) //=> { a: { c: false } } runkit "},{"title":"unsetProp","type":1,"pageTitle":"Helpers","url":"docs/functions/helpers#unsetprop","content":"crocks/helpers/unsetProp Copy unsetProp :: (String | Integer) -> a -> a unsetProp is a binary function that takes either a property name or an index as its first argument. Which specifies what should be removed, or \"unset\", from the Object or Array provided as the second argument. If the value provided for the second argument is not an Object or Array, then the value provided is echoed back as the result. The first argument must be either a non-empty String or positive Integer. A String should be provided when working with an Object, while Arrays require an Integer. unsetProp will return a new instance of either the Object or Array, sans the key or index. Copy import unsetProp from'/crocks/helpers/unsetProp' unsetProp('temp',{ name:'Joey', temp:33}) //=> { name: 'Joey' } unsetProp(1,[33,22,99]) //=> [ 33, 99 ] unsetProp('d',{ a:'A', b:'B'}) //=> { a: 'A', b: 'B' } unsetProp(10,['a','b','c']) //=> [ 'a', 'b', 'c' ] unsetProp('silly',null) //=> null runkit "},{"title":"Sum","type":0,"sectionRef":"#","url":"docs/monoids/Sum","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Sum","url":"docs/monoids/Sum#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"Sum","url":"docs/monoids/Sum#construction","content":"Copy Sum :: Number -> Sum Number Sum provides addition on Numbers and needs to be constructed with a Number instance. Calling the constructor with a Number, results in a new Sum that wraps the provided Number. Passing undefined, NaN or null to the constructor will result in an empty instance, or an instance containing a 0. Copy importSumfrom'crocks/Sum' import equals from'crocks/pointfree/equals' Sum(41) //=> Sum 41 Sum(Infinity) //=> Sum Infinity Sum(NaN) //=> Sum 0 equals(Sum(undefined),Sum.empty()) //=> true runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Sum","url":"docs/monoids/Sum#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Sum","url":"docs/monoids/Sum#empty","content":"Copy Sum.empty :: () -> Sum empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Sum the result of empty is 0. empty is available on both the Constructor and the Instance for convenience. Copy importSumfrom'crocks/Sum' Sum.empty() //=> Sum 0 Sum.empty() .concat(Sum.empty()) //=> Sum 0 Sum(4) .concat(Sum.empty()) //=> Sum 4 Sum.empty() .concat(Sum(4)) //=> Sum 4 runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Sum","url":"docs/monoids/Sum#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Sum","url":"docs/monoids/Sum#equals","content":"Copy Sum a ~> b -> Boolean Used to compare the underlying values of (2) Sum instances for equality by value, equals takes any given argument and returns true if the passed argument is a Sum with an underlying value equal to the underlying value of the Sum the method is being called on. If the passed argument is not a Sum or the underlying values are not equal, equals will return false. Copy importSumfrom'crocks/Sum' Sum(5) .equals(Sum(5)) //=> true Sum(25) .equals(Sum(31)) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Sum","url":"docs/monoids/Sum#concat","content":"Copy Sum ~> Sum -> Sum concat is used to combine (2) Semigroups of the same type under an operation specified by the Semigroup. In the case of Sum, it will add the (2) Numbers. Copy importSumfrom'crocks/Sum' Sum(5) .concat(Sum(4)) //=> Sum 9 Sum(45) .concat(Sum(32)) //=> Sum 77 Sum(1000) .concat(Sum(Infinity)) //=> Sum Infinity Sum(1) .concat(Sum(3)) //=> Sum 4 runkit "},{"title":"valueOf","type":1,"pageTitle":"Sum","url":"docs/monoids/Sum#valueof","content":"Copy Sum ~> () -> Number valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Sum instance will result in the underlying Number. Copy importSumfrom'crocks/Sum' Sum(4) .valueOf() //=> 4 Sum.empty() .valueOf() //=> 0 Sum(34) .concat(Sum(21)) .valueOf() //=> 55 runkit "},{"title":"Last","type":0,"sectionRef":"#","url":"docs/monoids/Last","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"Last","url":"docs/monoids/Last#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"Last","url":"docs/monoids/Last#construction","content":"Copy Last :: a -> Last (Maybe a) Last :: Maybe a -> Last (Maybe a) A Last instance can be constructed by passing either a direct (unwrapped) value a or a Maybe a to the constructor. When a direct value is passed, the constructor will always wrap the value in a Just and return a new Last Just a instance. Alternatively, by passing a Maybe a, the user can programmatically provide an empty case to a given Last by passing a Nothing. Copy importLastfrom'crocks/Last' importMaybefrom'crocks/Maybe' const{Just,Nothing}=Maybe Last(Just([1,2,3])) //=> Last( Just [ 1, 2, 3 ] ) Last(Nothing()) //=> Last( Nothing ) Last(null) //=> Last( Just null ) Last(false) //=> Last( Just false ) runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"Last","url":"docs/monoids/Last#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"Last","url":"docs/monoids/Last#empty","content":"Copy Last.empty :: () -> Last a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of Last the result of empty is Nothing. empty is available on both the Constructor and the Instance for convenience. Copy importLastfrom'crocks/Last' const{ empty }=Last empty() //=> Last( Nothing ) Last(3) .concat(empty()) //=> Last( Just 3 ) empty() .concat(Last(3)) //=> Last( Just 3 ) runkit "},{"title":"Instance Methods","type":1,"pageTitle":"Last","url":"docs/monoids/Last#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"Last","url":"docs/monoids/Last#equals","content":"Copy Last a ~> b -> Boolean Used to compare the underlying values of two Last instances for equality by value, equals takes any given argument and returns true if the passed argument is a Last with an underlying value equal to the underlying value of the Last the method is being called on. If the passed argument is not a Last or the underlying values are not equal, equals will return false. Copy importLastfrom'crocks/Last' importMaybefrom'crocks/Maybe' Last(33) .equals(Last(33)) //=> true Last(42) .equals(Last(10)) //=> false Last({ a:5}) .equals({ a:5}) //=> false Last(95) .equals(95) //=> false Last(95) .equals(Maybe.of(95)) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"Last","url":"docs/monoids/Last#concat","content":"Copy Last a ~> Last a -> Last a concat is used to combine two Semigroups of the same type under an operation specified by the Semigroup. In the case of Last, it will always provide the last non-empty value. All previous non-empty values will be thrown away and will always result in the last non-empty value. Copy importLastfrom'crocks/Last' import concat from'crocks/pointfree/concat' const a =Last('a') const b =Last('b') const c =Last('c') a.concat(b) //=> Last( Just \"b\" ) b.concat(a) //=> Last( Just \"a\" ) concat(c,concat(b, a)) //=> Last( Just \"c\" ) concat(concat(c, b), a) //=> Last( Just \"c\" ) concat(concat(a, b), c) //=> Last( Just \"a\" ) runkit "},{"title":"option","type":1,"pageTitle":"Last","url":"docs/monoids/Last#option","content":"Copy Last a ~> a -> a Last wraps an underlying Maybe which provides the ability to option out a value in the case of an empty instance. Just like option on a Maybe instance, it takes a value as its argument. When run on an empty instance, the provided default will be returned. If option is run on a non-empty instance however, the wrapped value will be extracted not only from the Last but also from the underlying Just. If the underlying Maybe is desired, the valueOf method can be used and will return the Maybe instead. Copy importLastfrom'crocks/Last' import compose from'crocks/helpers/compose' import chain from'crocks/pointfree/chain' import getProp from'crocks/Maybe/getProp' import isString from'crocks/predicates/isString' import mconcatMap from'crocks/helpers/mconcatMap' import safe from'crocks/Maybe/safe' // stringVal :: a -> Maybe String const stringVal =compose( chain(safe(isString)), getProp('val') ) // lastValid :: [ a ] -> Last String const lastValid = mconcatMap(Last, stringVal) // good :: [ Object ] const good = [{ val:23},{ val:'string'},{ val:'23'}] // bad :: [ Object ] const bad = [{ val:23},{ val:null},{}] lastValid(good) .option('') //=> \"23\" lastValid(bad) .option('') //=> \"\" runkit "},{"title":"valueOf","type":1,"pageTitle":"Last","url":"docs/monoids/Last#valueof","content":"Copy Last a ~> () -> Maybe a valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a Last instance will result in the underlying Maybe. Copy importLastfrom'crocks/Last' importMaybefrom'crocks/Maybe' import valueOf from'crocks/pointfree/valueOf' const{Nothing}=Maybe valueOf(Last(56)) //=> Just 56 valueOf(Last.empty()) //=> Nothing Last(37) .concat(Last(99)) .valueOf() //=> Just 99 Last(Nothing()) .concat(Last.empty()) .valueOf() //=> Nothing runkit "},{"title":"Transformation Functions","type":1,"pageTitle":"Last","url":"docs/monoids/Last#transformation-functions","content":""},{"title":"eitherToLast","type":1,"pageTitle":"Last","url":"docs/monoids/Last#eithertolast","content":"crocks/Last/eitherToLast Copy eitherToLast :: Either b a -> Last a eitherToLast :: (a -> Either c b) -> a -> Last b Used to transform a given Either instance to a Last instance, eitherToLast will turn a Right instance into a non-empty Last, wrapping the original value contained in the Right. All Left instances will map to an emptyLast, mapping the originally contained value to a Unit. Values on the Left will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, eitherToLast has two possible signatures and will behave differently when passed either an Either instance or a function that returns an instance of Either. When passed the instance, a transformed Last is returned. When passed an Either returning function, a function will be returned that takes a given value and returns a Last. Copy importLastfrom'crocks/Last' importEitherfrom'crocks/Either' import eitherToLast from'crocks/Last/eitherToLast' import concat from'crocks/pointfree/concat' import constant from'crocks/combinators/constant' import flip from'crocks/combinators/flip' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import mapReduce from'crocks/helpers/mapReduce' const{Left,Right}=Either // someNumber :: a -> Either String Number const someNumber =ifElse( isNumber, Right, constant(Left('Nope')) ) // lastNumber :: [ a ] -> Last Number const lastNumber =mapReduce( eitherToLast(someNumber), flip(concat), Last.empty() ) // \"Bad Times\" is lost, mapped to Nothing eitherToLast(Left('Bad Times')) //=> Last( Nothing ) eitherToLast(Right('correct')) //=> Last( Just \"correct\" ) lastNumber(['string',null,34,76]) //=> Last( Just 76 ) lastNumber(['string',null,true]) //=> Last( Nothing ) runkit "},{"title":"firstToLast","type":1,"pageTitle":"Last","url":"docs/monoids/Last#firsttolast","content":"crocks/Last/firstToLast Copy firstToLast :: First a -> Last a firstToLast :: (a -> First b) -> a -> Last b Used to transform a given First instance to a Last instance, firstToLast will turn a non-empty instance into a non-empty Last wrapping the original value contained within the First. All empty instances will map to an emptyLast. Like all crocks transformation functions, firstToLast has two possible signatures and will behave differently when passed either a First instance or a function that returns an instance of First. When passed the instance, a transformed Last is returned. When passed a First returning function, a function will be returned that takes a given value and returns a Last. Copy importLastfrom'crocks/Last' importFirstfrom'crocks/First' import firstToLast from'crocks/Last/firstToLast' import isString from'crocks/predicates/isString' import mconcatMap from'crocks/helpers/mconcatMap' import safe from'crocks/Maybe/safe' // firstString :: [ a ] -> First String const firstString = mconcatMap(First,safe(isString)) // unfixFirstString :: [ a ] -> Last String const unfixFirstString = firstToLast(firstString) firstToLast(First.empty()) //=> Last( Nothing ) firstToLast(First(false)) //=> Last( Just false ) unfixFirstString(['one',2,'Three',4]) //=> Last( Just \"one\" ) unfixFirstString(['one',2,'Three',4]) .concat(Last('another string')) //=> Last( Just \"another string\" ) unfixFirstString([1,2,3,4]) .concat(Last('Last String')) //=> Last( Just \"Last String\" ) runkit "},{"title":"maybeToLast","type":1,"pageTitle":"Last","url":"docs/monoids/Last#maybetolast","content":"crocks/Last/maybeToLast Copy maybeToLast :: Maybe a -> Last a maybeToLast :: (a -> Maybe b) -> a -> Last b Used to transform a given Maybe instance to a Last instance, maybeToLast will turn a Just into a non-empty Last instance, wrapping the original value contained within the Last. All Nothing instances will map to an emptyLast instance. This function is available mostly for completion sake, as Last can always take a Maybe as its argument during construction. So while there is not a real need for this to be used for transforming instances, it can come in handy for lifting Maybe returning functions. Like all crocks transformation functions, maybeToLast has two possible signatures and will behave differently when passed either a Maybe instance or a function that returns an instance of Maybe. When passed the instance, a transformed Last is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns a Last. Copy importLastfrom'crocks/Last' importMaybefrom'crocks/Maybe' import maybeToLast from'crocks/Last/maybeToLast' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import getProp from'crocks/Maybe/getProp' import isNumber from'crocks/predicates/isNumber' import safe from'crocks/Maybe/safe' const{Nothing,Just}=Maybe // numVal :: a -> Maybe Number const numVal =compose( chain(safe(isNumber)), getProp('val') ) // lastNumVal :: a -> Last Number const lastNumVal = maybeToLast(numVal) maybeToLast(Just(99)) //=> Last( Just 99 ) maybeToLast(Nothing()) //=> Last( Nothing ) Last(Just(99)) //=> Last( Just 99 ) Last(Nothing()) //=> Last( Nothing ) Last(Just(80)) .concat(lastNumVal({ val:97})) //=> Last( Just 97 ) lastNumVal({ val:97}) .concat(Last(80)) //=> Last( Just 80 ) lastNumVal(null) .concat(Last(80)) //=> Last( Just 80 ) runkit "},{"title":"resultToLast","type":1,"pageTitle":"Last","url":"docs/monoids/Last#resulttolast","content":"crocks/Last/resultToLast Copy resultToLast :: Result e a -> Last a resultToLast :: (a -> Result e b) -> a -> Last b Used to transform a given Result instance to a Last instance,resultToLast will turn an Ok instance into a non-empty Last, wrapping the original value contained in the Ok. All Err instances will map to an emptyLast, mapping the originally contained value to a Unit. Values on the Err will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, resultToLast has two possible signatures and will behave differently when passed either an Result instance or a function that returns an instance of Result. When passed the instance, a transformed Last is returned. When passed a Result returning function, a function will be returned that takes a given value and returns a Last. Copy importLastfrom'crocks/Last' importResultfrom'crocks/Result' import resultToLast from'crocks/Last/resultToLast' import isNumber from'crocks/predicates/isNumber' import tryCatch from'crocks/Result/tryCatch' const{Err,Ok}=Result functiononlyNums(x){ if(!isNumber(x)){ thrownewError('something amiss') } return x } // lastNum :: a -> Last Number const lastNum = resultToLast(tryCatch(onlyNums)) // \"this is bad\" is lost, mapped to Nothing resultToLast(Err('this is bad')) //=> Last( Nothing ) resultToLast(Ok('this is great')) //=> Last( Just \"this is great\" ) lastNum(90) .concat(Last(0)) //=> Last( Just 0 ) lastNum(null) .concat(Last(0)) //=> Last( Just 0 ) runkit "},{"title":"First","type":0,"sectionRef":"#","url":"docs/monoids/First","content":"","keywords":""},{"title":"Implements","type":1,"pageTitle":"First","url":"docs/monoids/First#implements","content":"Setoid, Semigroup, Monoid "},{"title":"Construction","type":1,"pageTitle":"First","url":"docs/monoids/First#construction","content":"Copy First :: a -> First (Maybe a) First :: Maybe a -> First (Maybe a) A First instance can be constructed by passing either a direct (unwrapped) value a or a Maybe a to the constructor. When a direct value is passed, the constructor will always wrap the value in a Just and return a new First Just a instance. Alternatively, by passing a Maybe a, the user can programmatically provide an empty case to a given First by passing a Nothing. Copy importFirstfrom'crocks/First' importMaybefrom'crocks/Maybe' const{Just,Nothing}=Maybe First(Just(22)) //=> First( Just 22 ) First(Nothing()) //=> First( Nothing ) First(undefined) //=> First( Just undefined ) First('string') //=> First( Just \"string\" ) runkit "},{"title":"Constructor Methods","type":1,"pageTitle":"First","url":"docs/monoids/First#constructor-methods","content":""},{"title":"empty","type":1,"pageTitle":"First","url":"docs/monoids/First#empty","content":"Copy First.empty :: () -> First a empty provides the identity for the Monoid in that when the value it provides is concated to any other value, it will return the other value. In the case of First the result of empty is Nothing. empty is available on both the Constructor and the Instance for convenience. Copy importFirstfrom'crocks/First' const{ empty }=First First.empty() //=> First( Nothing ) First(3) .concat(empty()) //=> First( Just 3 ) empty() .concat(First(3)) //=> First( Just 3 ) runkit "},{"title":"Instance Methods","type":1,"pageTitle":"First","url":"docs/monoids/First#instance-methods","content":""},{"title":"equals","type":1,"pageTitle":"First","url":"docs/monoids/First#equals","content":"Copy First a ~> b -> Boolean Used to compare the underlying values of two First instances for equality by value, equals takes any given argument and returns true if the passed arguments is a First with an underlying value equal to the underlying value of the First the method is being called on. If the passed argument is not a First or the underlying values are not equal, equals will return false. Copy importFirstfrom'crocks/First' importMaybefrom'crocks/Maybe' First(33) .equals(First(33)) //=> true First(42) .equals(First(10)) //=> false First({ a:5}) .equals({ a:5}) //=> false First(95) .equals(95) //=> false First(95) .equals(Maybe.of(95)) //=> false runkit "},{"title":"concat","type":1,"pageTitle":"First","url":"docs/monoids/First#concat","content":"Copy First a ~> First a -> First a concat is used to combine two Semigroups of the same type under an operation specified by the Semigroup. In the case of First, it will always provide the first non-empty value. Any subsequent non-empty values will be thrown away and will always result in the first non-empty value. Copy importFirstfrom'crocks/First' import concat from'crocks/pointfree/concat' const a =First('a') const b =First('b') const c =First('c') a.concat(b) //=> First( Just \"a\" ) b.concat(a) //=> First( Just \"b\" ) concat(c,concat(b, a)) //=> First( Just \"a\" ) concat(concat(c, b), a) //=> First( Just \"a\" ) concat(concat(a, b), c) //=> First( Just \"c\" ) runkit "},{"title":"option","type":1,"pageTitle":"First","url":"docs/monoids/First#option","content":"Copy First a ~> a -> a First wraps an underlying Maybe which provides the ability to option out a value in the case of an empty instance. Just likeoption on a Maybe instance, it takes a value as its argument. When run on an empty instance, the provided default will be returned. If option is run on a non-empty instance however, the wrapped value will be extracted not only from the First but also from the underlying Just. If the underlying Maybe is desired, the valueOfmethod can be used and will return the Maybe instead. Copy importFirstfrom'crocks/First' import compose from'crocks/helpers/compose' import chain from'crocks/pointfree/chain' import getProp from'crocks/Maybe/getProp' import isString from'crocks/predicates/isString' import mconcatMap from'crocks/helpers/mconcatMap' import safe from'crocks/Maybe/safe' // stringVal :: a -> Maybe String const stringVal =compose( chain(safe(isString)), getProp('val') ) // firstValid :: [ a ] -> First String const firstValid = mconcatMap(First, stringVal) // good :: [ Object ] const good = [{ val:23},{ val:'string'},{ val:'23'}] // bad :: [ Object ] const bad = [{ val:23},{ val:null},{}] firstValid(good) .option('') //=> \"string\" firstValid(bad) .option('') //=> \"\" runkit "},{"title":"valueOf","type":1,"pageTitle":"First","url":"docs/monoids/First#valueof","content":"Copy First a ~> () -> Maybe a valueOf is used on all crocksMonoids as a means of extraction. While the extraction is available, types that implement valueOf are not necessarily a Comonad. This function is used primarily for convenience for some of the helper functions that ship with crocks. Calling valueOf on a First instance will result in the underlying Maybe. Copy importFirstfrom'crocks/First' importMaybefrom'crocks/Maybe' import valueOf from'crocks/pointfree/valueOf' const{Nothing}=Maybe valueOf(First(56)) //=> Just 56 valueOf(First.empty()) //=> Nothing First(37) .concat(First(99)) .valueOf() //=> Just 37 First(Nothing()) .concat(First.empty()) .valueOf() //=> Nothing runkit "},{"title":"Transformation Functions","type":1,"pageTitle":"First","url":"docs/monoids/First#transformation-functions","content":""},{"title":"eitherToFirst","type":1,"pageTitle":"First","url":"docs/monoids/First#eithertofirst","content":"crocks/First/eitherToFirst Copy eitherToFirst :: Either b a -> First a eitherToFirst :: (a -> Either c b) -> a -> First b Used to transform a given Either instance to a First instance, eitherToFirst will turn a Right instance into a non-empty First, wrapping the original value contained in the Right. All Left instances will map to an emptyFirst, mapping the originally contained value to a Unit. Values on the Left will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, eitherToFirst has two possible signatures and will behave differently when passed either an Either instance or a function that returns an instance of Either. When passed the instance, a transformed First is returned. When passed an Either returning function, a function will be returned that takes a given value and returns a First. Copy importFirstfrom'crocks/First' importEitherfrom'crocks/Either' import eitherToFirst from'crocks/First/eitherToFirst' import concat from'crocks/pointfree/concat' import constant from'crocks/combinators/constant' import flip from'crocks/combinators/flip' import ifElse from'crocks/logic/ifElse' import isNumber from'crocks/predicates/isNumber' import mapReduce from'crocks/helpers/mapReduce' const{Left,Right}=Either // someNumber :: a -> Either String Number const someNumber =ifElse( isNumber, Right, constant(Left('Nope')) ) // firstNumber :: [ a ] -> First Number const firstNumber =mapReduce( eitherToFirst(someNumber), flip(concat), First.empty() ) // \"Bad Times\" is lost, mapped to Nothing eitherToFirst(Left('Bad Times')) //=> First( Nothing ) eitherToFirst(Right('correct')) //=> First( Just \"correct\" ) firstNumber(['string',null,34,76]) //=> First( Just 34 ) firstNumber(['string',null,true]) //=> First( Nothing ) runkit "},{"title":"lastToFirst","type":1,"pageTitle":"First","url":"docs/monoids/First#lasttofirst","content":"crocks/First/lastToFirst Copy lastToFirst :: Last a -> First a lastToFirst :: (a -> Last b) -> a -> First b Used to transform a given Last instance to a First instance,lastToFirst will turn a non-empty instance into a non-empty First wrapping the original value contained within the Last. All empty instances will map to an emptyFirst. Like all crocks transformation functions, lastToFirst has two possible signatures and will behave differently when passed either a Last instance or a function that returns an instance of Last. When passed the instance, a transformed First is returned. When passed a Last returning function, a function will be returned that takes a given value and returns a First. Copy importFirstfrom'crocks/First' importLastfrom'crocks/Last' import lastToFirst from'crocks/First/lastToFirst' import isString from'crocks/predicates/isString' import mconcatMap from'crocks/helpers/mconcatMap' import safe from'crocks/Maybe/safe' // lastString :: [ a ] -> Last String const lastString = mconcatMap(Last,safe(isString)) // fixLastString :: [ a ] -> First String const fixLastString = lastToFirst(lastString) lastToFirst(Last.empty()) //=> First( Nothing ) lastToFirst(Last(false)) //=> First( Just false ) fixLastString(['one',2,'Three',4]) .concat(First('another string')) //=> First( Just \"Three\" ) fixLastString([1,2,3,4]) .concat(First('First String')) //=> First( Just \"First String\" ) runkit "},{"title":"maybeToFirst","type":1,"pageTitle":"First","url":"docs/monoids/First#maybetofirst","content":"crocks/First/maybeToFirst Copy maybeToFirst :: Maybe a -> First a maybeToFirst :: (a -> Maybe b) -> a -> First b Used to transform a given Maybe instance to a First instance, maybeToFirst will turn a Just into a non-empty First instance, wrapping the original value contained within the First. All Nothing instances will map to an emptyFirst instance. This function is available mostly for completion sake, as First can always take a Maybe as its argument during construction. So while there is not a real need for this to be used for transforming instances, it can come in handy for lifting Maybe returning functions. Like all crocks transformation functions, maybeToFirst has two possible signatures and will behave differently when passed either a Maybeinstance or a function that returns an instance of Maybe. When passed the instance, a transformed First is returned. When passed a Maybe returning function, a function will be returned that takes a given value and returns a First. Copy importFirstfrom'crocks/First' importMaybefrom'crocks/Maybe' import maybeToFirst from'crocks/First/maybeToFirst' import chain from'crocks/pointfree/chain' import compose from'crocks/helpers/compose' import getProp from'crocks/Maybe/getProp' import isNumber from'crocks/predicates/isNumber' import safe from'crocks/Maybe/safe' const{Nothing,Just}=Maybe // numVal :: a -> Maybe Number const numVal =compose( chain(safe(isNumber)), getProp('val') ) // firstNumVal :: a -> First Number const firstNumVal = maybeToFirst(numVal) maybeToFirst(Just(99)) //=> First( Just 99 ) maybeToFirst(Nothing()) //=> First( Nothing ) First(Just(99)) //=> First( Just 99 ) First(Nothing()) //=> First( Nothing ) firstNumVal({ val:97}) .concat(First(80)) //=> First( Just 97 ) firstNumVal({ val:'97'}) .concat(First(80)) //=> First( Just 80 ) firstNumVal(null) .concat(First(80)) //=> First( Just 80 ) runkit "},{"title":"resultToFirst","type":1,"pageTitle":"First","url":"docs/monoids/First#resulttofirst","content":"crocks/First/resultToFirst Copy resultToFirst :: Result e a -> First a resultToFirst :: (a -> Result e b) -> a -> First b Used to transform a given Result instance to a First instance,resultToFirst will turn an Ok instance into a non-empty First, wrapping the original value contained in the Ok. All Err instances will map to an emptyFirst, mapping the originally contained value to a Unit. Values on the Err will be lost and as such this transformation is considered lossy in that regard. Like all crocks transformation functions, resultToFirst has two possible signatures and will behave differently when passed either an Result instance or a function that returns an instance of Result. When passed the instance, a transformed First is returned. When passed a Result returning function, a function will be returned that takes a given value and returns a First. Copy importFirstfrom'crocks/First' importResultfrom'crocks/Result' import resultToFirst from'crocks/First/resultToFirst' import isNumber from'crocks/predicates/isNumber' import tryCatch from'crocks/Result/tryCatch' const{Err,Ok}=Result functiononlyNums(x){ if(!isNumber(x)){ thrownewError('something amiss') } return x } // firstNum :: a -> First Number const firstNum = resultToFirst(tryCatch(onlyNums)) // \"this is bad\" is lost, mapped to Nothing resultToFirst(Err('this is bad')) //=> First( Nothing ) resultToFirst(Ok('this is great')) //=> First( Just \"this is great\" ) firstNum(90) .concat(First(0)) //=> First( Just 90 ) firstNum(null) .concat(First(0)) //=> First( Just 0 ) runkit "}]