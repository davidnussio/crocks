(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{100:function(e,n,t){"use strict";t.d(n,"a",(function(){return s})),t.d(n,"b",(function(){return d}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),b=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},s=function(e){var n=b(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),s=b(t),u=a,d=s["".concat(i,".").concat(u)]||s[u]||m[u]||o;return t?r.a.createElement(d,c(c({ref:n},l),{},{components:t})):r.a.createElement(d,c({ref:n},l))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var c={};for(var p in n)hasOwnProperty.call(n,p)&&(c[p]=n[p]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<o;l++)i[l]=t[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},97:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return p})),t.d(n,"default",(function(){return b}));var a=t(2),r=t(6),o=(t(0),t(100)),i={title:"Helpers",description:"Helper functions",layout:"notopic",functions:["assign","assoc","binary","compose","composek","composep","composes","curry","defaultprops","defaultto","dissoc","frompairs","getpathor","getpropor","lifta2","lifta3","liftn","mapprops","mapreduce","mconcat","mconcatmap","mreduce","mreducemap","nary","objof","omit","once","partial","pick","pipe","pipek","pipep","pipes","propor","proppathor","setpath","setprop","tap","unary","unit","unsetpath","unsetprop"],weight:20},c={unversionedId:"functions/helpers",id:"functions/helpers",isDocsHomePage:!1,title:"Helpers",description:"Helper functions",source:"@site/docs/functions/helpers.md",slug:"/functions/helpers",permalink:"/crocks/docs/docs/functions/helpers",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/functions/helpers.md",version:"current",sidebar:"sidebar",previous:{title:"Combinators",permalink:"/crocks/docs/docs/functions/combinators"},next:{title:"Logic Functions",permalink:"/crocks/docs/docs/functions/logic-functions"}},p=[{value:"assign",id:"assign",children:[]},{value:"binary",id:"binary",children:[]},{value:"compose",id:"compose",children:[]},{value:"composeK",id:"composek",children:[]},{value:"composeP",id:"composep",children:[]},{value:"composeS",id:"composes",children:[]},{value:"curry",id:"curry",children:[]},{value:"defaultProps",id:"defaultprops",children:[]},{value:"defaultTo",id:"defaultto",children:[]},{value:"fromPairs",id:"frompairs",children:[]},{value:"getPathOr",id:"getpathor",children:[]},{value:"getPropOr",id:"getpropor",children:[]},{value:"liftA2",id:"lifta2",children:[]},{value:"liftA3",id:"lifta3",children:[]},{value:"liftN",id:"liftn",children:[]},{value:"mapProps",id:"mapprops",children:[]},{value:"mapReduce",id:"mapreduce",children:[]},{value:"mconcat",id:"mconcat",children:[]},{value:"mreduce",id:"mreduce",children:[]},{value:"mconcatMap",id:"mconcatmap",children:[]},{value:"mreduceMap",id:"mreducemap",children:[]},{value:"nAry",id:"nary",children:[]},{value:"objOf",id:"objof",children:[]},{value:"omit",id:"omit",children:[]},{value:"once",id:"once",children:[]},{value:"partial",id:"partial",children:[]},{value:"pick",id:"pick",children:[]},{value:"pipe",id:"pipe",children:[]},{value:"pipeK",id:"pipek",children:[]},{value:"pipeP",id:"pipep",children:[]},{value:"pipeS",id:"pipes",children:[]},{value:"setPath",id:"setpath",children:[]},{value:"setProp",id:"setprop",children:[]},{value:"tap",id:"tap",children:[]},{value:"tryCatch",id:"trycatch",children:[]},{value:"unary",id:"unary",children:[]},{value:"unit",id:"unit",children:[]},{value:"unsetPath",id:"unsetpath",children:[]},{value:"unsetProp",id:"unsetprop",children:[]}],l={rightToc:p};function b(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h3",{id:"assign"},"assign"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/assign")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"assign :: Object -> Object -> Object\n")),Object(o.b)("p",null,"When working with ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s, a common operation is to combine (2) of them. This\ncan be accomplished in ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," by reaching for ",Object(o.b)("inlineCode",{parentName:"p"},"assign"),". Unlike\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"Object.assign")," that ships with JavaScript, this ",Object(o.b)("inlineCode",{parentName:"p"},"assign")," will combine\nyour ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s into a new shallow copy of their merger. ",Object(o.b)("inlineCode",{parentName:"p"},"assign")," only takes two\narguments and will overwrite keys present in the second argument with values\nfrom the first. As with most of the ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," based functions, ",Object(o.b)("inlineCode",{parentName:"p"},"assign")," will\nomit any key-value pairs that are ",Object(o.b)("inlineCode",{parentName:"p"},"undefined"),". Check out a related function\nnamed ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#defaultprops"}),Object(o.b)("inlineCode",{parentName:"a"},"defaultProps"))," that will only assign values that\nare ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," in the second argument."),Object(o.b)("h3",{id:"binary"},"binary"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/binary")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"binary :: ((*) -> c) -> a -> b -> c\n")),Object(o.b)("p",null,"With all the different functions out there in the real world, sometimes it is\nnice to restrict them to a specific -arity to work with your all your wonderful\ncompositions. When you want to restrict any function of any arity to a simple\nbinary function. Just pass your function to ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," and you will get back a\ncurried, binary function that will only apply (2) arguments to the inner\nfunction, ignoring any others. This works very well with functions\nlike ",Object(o.b)("inlineCode",{parentName:"p"},"Array.prototype.reduce")," where you may only care about the first 2 arguments.\nif you need to constrain to more than (2) arguments, then you will want to reach\nfor  ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#nary"}),Object(o.b)("inlineCode",{parentName:"a"},"nAry")),". ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," is basically syntactic sugar for ",Object(o.b)("inlineCode",{parentName:"p"},"nAry(2, fn)"),".\nAlso related is ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#unary"}),Object(o.b)("inlineCode",{parentName:"a"},"unary")),", which constrains to (1) argument."),Object(o.b)("h3",{id:"compose"},"compose"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/compose")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"compose :: ((y -> z), ..., (a -> b)) -> a -> z\n")),Object(o.b)("p",null,"While the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"combinators#composeb"}),Object(o.b)("inlineCode",{parentName:"a"},"composeB"))," can be used to create a\ncomposition of two functions, there are times when you want to compose an entire\nflow together. That is where ",Object(o.b)("inlineCode",{parentName:"p"},"compose")," is useful. With ",Object(o.b)("inlineCode",{parentName:"p"},"compose")," you can create\na right-to-left composition of functions. It will return you a function that\nrepresents your flow. ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," provides a means to build compostions using a\nleft-to-right style in the form of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#pipe"}),Object(o.b)("inlineCode",{parentName:"a"},"pipe")),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import compose from 'crocks/helpers/compose'\n\nimport objOf from 'crocks/helpers/objOf'\n\n// double :: Number -> Number\nconst double = x =>\n  x + x\n\n// doubleAndWrap :: Number -> Object\nconst doubleAndWrap = compose(\n  objOf('result'),\n  double\n)\n\ndoubleAndWrap(25)\n//=> { result: 50 }\n\ndoubleAndWrap(0)\n//=> { result: 0 }\n")),Object(o.b)("h3",{id:"composek"},"composeK"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/composeK")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"composeK :: Chain m => ((y -> m z), ..., (a -> m b)) -> a -> m z\n")),Object(o.b)("p",null,"There are many times that, when working with the various ",Object(o.b)("inlineCode",{parentName:"p"},"crocks"),", our flows are\njust a series of ",Object(o.b)("inlineCode",{parentName:"p"},"chain"),"s. Due to some neat properties with types that provide\na ",Object(o.b)("inlineCode",{parentName:"p"},"chain")," function, you can remove some boilerplate by reaching for ",Object(o.b)("inlineCode",{parentName:"p"},"composeK"),".\nJust pass it the functions you would normally pass to ",Object(o.b)("inlineCode",{parentName:"p"},"chain")," and it will do all\nthe boring hook up for you. Just like ",Object(o.b)("inlineCode",{parentName:"p"},"compose"),", functions are applied\nright-to-left, so you can turn this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import compose from 'crocks/helpers/compose'\n\nimport chain from 'crocks/pointfree/chain'\nimport getProp from 'crocks/Maybe/getProp'\nimport isObject from 'crocks/predicates/isObject'\nimport safe from 'crocks/Maybe/safe'\n\nconst data = {\n  do: {\n    re: {\n      mi: 'fa'\n    }\n  }\n}\n\n// fluent :: a -> Maybe b\nconst fluent = x =>\n  safe(isObject, x)\n    .chain(getProp('do'))\n    .chain(getProp('re'))\n    .chain(getProp('mi'))\n\nfluent(data)\n//=> Just 'fa'\n\n// pointfree :: a -> Maybe b\nconst pointfree = compose(\n  chain(getProp('mi')),\n  chain(getProp('re')),\n  chain(getProp('do')),\n  safe(isObject)\n)\n\npointfree(data)\n//=> Just 'fa'\n")),Object(o.b)("p",null,"into the more abbreviated form:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import composeK from 'crocks/helpers/composeK'\n\nimport getProp from 'crocks/Maybe/getProp'\nimport isObject from 'crocks/predicates/isObject'\nimport safe from 'crocks/Maybe/safe'\n\nconst data = {\n  do: {\n    re: {\n      mi: 'fa'\n    }\n  }\n}\n\n// flow :: a -> Maybe b\nconst flow = composeK(\n  getProp('mi'),\n  getProp('re'),\n  getProp('do'),\n  safe(isObject)\n)\n\nflow(data)\n//=> Just 'fa'\n")),Object(o.b)("p",null,"As demonstrated in the above example, this function more closely resembles flows\nthat are using a more pointfree style of coding. As with the other composition\nfunctions in ",Object(o.b)("inlineCode",{parentName:"p"},"crocks"),", a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#pipek"}),Object(o.b)("inlineCode",{parentName:"a"},"pipeK"))," function is provided for flows that\nmake more sense expressed in a left-to-right style."),Object(o.b)("h3",{id:"composep"},"composeP"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/composeP")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"composeP :: Promise p => ((y -> p z c), ..., (a -> p b c)) -> a -> p z c\n")),Object(o.b)("p",null,"When working with ",Object(o.b)("inlineCode",{parentName:"p"},"Promise"),"s, it is common place to create chains on\na ",Object(o.b)("inlineCode",{parentName:"p"},"Promise"),"'s ",Object(o.b)("inlineCode",{parentName:"p"},"then")," function. Doing this involves a lot of boilerplate and\nforces you into a fluent style, whether you want to be or not. Using ",Object(o.b)("inlineCode",{parentName:"p"},"composeP")," you\nhave the option to compose a series of ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," returning functions like you\nwould any other function composition, in a right-to-left fashion."),Object(o.b)("p",null,"Due to the nature of the ",Object(o.b)("inlineCode",{parentName:"p"},"then")," function, only the head of your composition\nneeds to return a ",Object(o.b)("inlineCode",{parentName:"p"},"Promise"),". This will create a function that takes a value,\nwhich is passed through your chain, returning a ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," which can be extended.\nThis is only a ",Object(o.b)("inlineCode",{parentName:"p"},"then")," chain, it does not do anything with the ",Object(o.b)("inlineCode",{parentName:"p"},"catch")," function.\nIf you would like to provide your functions in a left-to-right manner, check\nout ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#pipep"}),"pipeP"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import composeP from 'crocks/helpers/composeP'\n\nimport Async from 'crocks/Async'\nimport asyncToPromise from 'crocks/Async/asyncToPromise'\nimport composeB from 'crocks/combinators/composeB'\n\nconst { resolveAfter } = Async\n\n// resolveQuick :: a -> Async e a\nconst resolveQuick = value =>\n  resolveAfter(300, value)\n\n// promiseSomething :: a -> Promise a e\nconst promiseSomething = composeB(\n  asyncToPromise, resolveQuick\n)\n\n// log :: a -> ()\nconst log = x =>\n  console.log(x)\n\n// sayHello :: String -> String\nconst sayHello = to =>\n  `Hello ${to}`\n\n// emphasize :: String -> String\nconst emphasize = to =>\n  `${to}!`\n\n// promFunc :: a -> Promise a e\nconst promFunc = x =>\n  promiseSomething(x)\n    .then(emphasize)\n    .then(sayHello)\n\n// composedPromFunc :: a -> Promise a e\nconst composedPromFunc =\n  composeP(sayHello, emphasize, promiseSomething)\n\npromFunc('World')\n  .then(log)\n//=> Hello World!\n\ncomposedPromFunc('World')\n  .then(log)\n//=> Hello World!\n")),Object(o.b)("h3",{id:"composes"},"composeS"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/composeS")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"composeS :: Semigroupoid s => (s y z, ..., s a b) -> s a z\n")),Object(o.b)("p",null,"When working with things like ",Object(o.b)("inlineCode",{parentName:"p"},"Arrow")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Star")," there will come a point when\nyou would like to compose them like you would any ",Object(o.b)("inlineCode",{parentName:"p"},"Function"),". That is\nwhere ",Object(o.b)("inlineCode",{parentName:"p"},"composeS")," comes in handy. Just pass it the ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroupoid"),"s you want to compose\nand it will give you back a new ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroupoid")," of the same type with all of the\nunderlying functions composed and ready to be run.\nLike ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#compose"}),Object(o.b)("inlineCode",{parentName:"a"},"compose")),", ",Object(o.b)("inlineCode",{parentName:"p"},"composeS")," composes the functions in a right-to-left\nfashion. If you would like to represent your flow in a more left-to-right manner,\nthen ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#pipes"}),Object(o.b)("inlineCode",{parentName:"a"},"pipeS"))," is provided for such things."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Arrow from 'crocks/Arrow'\n\nimport bimap from 'crocks/pointfree/bimap'\nimport branch from 'crocks/Pair/branch'\nimport composeS from 'crocks/helpers/composeS'\nimport merge from 'crocks/pointfree/merge'\nimport mreduce from 'crocks/helpers/mreduce'\nimport Sum from 'crocks/Sum'\n\n// length :: a -> Number\nconst length = xs =>\n  xs.length\n\n// divide :: (Number, Number) -> Number\nconst divide = (x, y) =>\n  x / y\n\n// avg :: Arrow [ Number ] Number\nconst avg =\n  Arrow(bimap(mreduce(Sum), length))\n    .promap(branch, merge(divide))\n\n// double :: Arrow Number Number\nconst double =\n  Arrow(x => x * 2)\n\n// data :: [ Number ]\nconst data =\n  [ 34, 198, 3, 43, 92 ]\n\ncomposeS(double, avg)\n  .runWith(data)\n//=> 148\n")),Object(o.b)("h3",{id:"curry"},"curry"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/curry")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"curry :: ((a, b, ...) -> z) -> a -> b -> ... -> z\n")),Object(o.b)("p",null,"Pass this function a function and it will return you a function that can be\ncalled in any form that you require until all arguments have been provided. For\nexample if you pass a function: ",Object(o.b)("inlineCode",{parentName:"p"},"f : (a, b, c) -> d")," you get back a function\nthat can be called in any combination, such as: ",Object(o.b)("inlineCode",{parentName:"p"},"f(x, y, z)"),", ",Object(o.b)("inlineCode",{parentName:"p"},"f(x)(y)(z)"),",\n",Object(o.b)("inlineCode",{parentName:"p"},"f(x, y)(z)"),", or even ",Object(o.b)("inlineCode",{parentName:"p"},"f(x)(y, z)"),". That is to say, this function fulfills the role\nof both curry and uncurry, returning a function that can be used as a curried\nfunction, an uncurried function, or any combination of argument applications in\nbetween. The returned function has ",Object(o.b)("inlineCode",{parentName:"p"},"2^(n-1)")," type signatures, where ",Object(o.b)("inlineCode",{parentName:"p"},"n")," is the\nnumber of parameters."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import compose from 'crocks/helpers/compose'\nimport curry from 'crocks/helpers/curry'\nimport map from 'crocks/pointfree/map'\nimport prop from 'crocks/maybe/prop'\n\n// add :: (Number, Number, Number) -> Number\nconst add = (a, b, c) =>\n  a + b + c\n\n// partial application impossible\nadd(1)\n//=> NaN\n// 1 + undefined + undefined => NaN\n\n// crocksCurriedAdd :: Number -> Number -> Number -> Number\nconst crocksCurriedAdd =\n  curry(add)\n\n// appliedAdd :: Number -> Number -> Number\nconst appliedAdd =\n  crocksCurriedAdd(1)\n\nappliedAdd(1, 1)\n//=> 3\n\ncrocksCurriedAdd(1)(2)(3)\ncrocksCurriedAdd(1, 2)(3)\ncrocksCurriedAdd(1)(2, 3)\ncrocksCurriedAdd(1, 2, 3)\n//=> 6\n\n// strictCurriedPluck :: String -> [ a ] -> Maybe b\nconst strictCurriedPluck =\n  compose(map, prop)\n\nconst crockCurriedPluck =\n  curry(strictCurriedPluck)\n\n// data :: [ { a: String, b: String } ]\nconst data = [\n  { a: 'nice' },\n  { a: 'great', b: 'nice' },\n  { b: 'nice' }\n]\n\nstrictCurriedPluck('a')(data)\n//=> [ Just \"nice\", Just \"great\", Nothing ]\n\ncrockCurriedPluck('a', data)\n//=> [ Just \"nice\", Just \"great\", Nothing ]\n\n")),Object(o.b)("p",null,"An important caveat when using ",Object(o.b)("inlineCode",{parentName:"p"},"curry")," with functions containing optional parameters,\nis that the defaults are applied immediately, reducing the number of partial\napplications to just the number of required parameters. Adding optional parameters\nto functions may not be a good choice if the intention is to use them with ",Object(o.b)("inlineCode",{parentName:"p"},"curry"),",\nas the ability to change the defaults is lost. Parameters are applied up until the\nfirst optional parameter, at which point subsequent parameters either receive the\ndeclared default or go undefined."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import curry from 'crocks/helpers/curry'\n\n// curriedConsolelog :: [ (Object | String) ] -> ()\nconst curriedConsolelog =\n  curry(console.log)\n\ncurriedConsolelog('Hello %s', 'World')\n//=> Hello %s\n\ncurriedConsolelog('Hello', 'World')\n//=> Hello\n\n")),Object(o.b)("h3",{id:"defaultprops"},"defaultProps"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/defaultProps")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"defaultProps :: Object -> Object -> Object\n")),Object(o.b)("p",null,"Picture this, you have an ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," and you want to make sure that some\nproperties are set with a given default value. When the need for this type of\noperation presents itself, ",Object(o.b)("inlineCode",{parentName:"p"},"defaultProps")," can come to your aid. Just pass it\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," that defines your defaults and then the ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," your want to default\nthose props on. If a key that is present on the defaults ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," is not defined\non your data, then the default value will be used. Otherwise, the value from\nyour data will be used instead. You could just apply ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"combinators#flip"}),Object(o.b)("inlineCode",{parentName:"a"},"flip"))," to\nthe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#assign"}),Object(o.b)("inlineCode",{parentName:"a"},"assign"))," function and get the same result, but having a function\nnamed ",Object(o.b)("inlineCode",{parentName:"p"},"defaultProps")," may be easier to read in code. As with most ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," related\nfunctions in ",Object(o.b)("inlineCode",{parentName:"p"},"crocks"),", ",Object(o.b)("inlineCode",{parentName:"p"},"defaultProps")," will return you a shallow copy of the\nresult and not include any ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," values in either ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"."),Object(o.b)("h3",{id:"defaultto"},"defaultTo"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/defaultTo")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"defaultTo :: a -> b -> a\n")),Object(o.b)("p",null,"With things like ",Object(o.b)("inlineCode",{parentName:"p"},"null"),", ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," and ",Object(o.b)("inlineCode",{parentName:"p"},"NaN")," showing up all over the place, it\ncan be hard to keep your expected types inline without resorting to nesting in\na ",Object(o.b)("inlineCode",{parentName:"p"},"Maybe")," with functions like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe#safe"}),Object(o.b)("inlineCode",{parentName:"a"},"safe")),". If you want to specifically guard\nfor ",Object(o.b)("inlineCode",{parentName:"p"},"null"),", ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," and ",Object(o.b)("inlineCode",{parentName:"p"},"NaN")," and get things defaulted into the expected\ntype, then ",Object(o.b)("inlineCode",{parentName:"p"},"defaultTo")," should work for you. Just pass it what you would like\nyour default value to be and then the value you want guarded, and you will get\nback either the default or the passed value, depending on if the passed value\nis ",Object(o.b)("inlineCode",{parentName:"p"},"null"),", ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," or ",Object(o.b)("inlineCode",{parentName:"p"},"NaN"),". While this ",Object(o.b)("em",{parentName:"p"},"is")," JavaScript and you can return\nanything, it is suggested to stick to the signature and only let ",Object(o.b)("inlineCode",{parentName:"p"},"a"),"s through.\nAs a ",Object(o.b)("inlineCode",{parentName:"p"},"b")," can be an ",Object(o.b)("inlineCode",{parentName:"p"},"a")," as well."),Object(o.b)("h3",{id:"frompairs"},"fromPairs"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/fromPairs")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"fromPairs :: Foldable f => f (Pair String a) -> Object\n")),Object(o.b)("p",null,"As an inverse to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Pair#topairs"}),Object(o.b)("inlineCode",{parentName:"a"},"toPairs")),", ",Object(o.b)("inlineCode",{parentName:"p"},"fromPairs")," takes either\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," or ",Object(o.b)("inlineCode",{parentName:"p"},"List")," of key-value ",Object(o.b)("inlineCode",{parentName:"p"},"Pair"),"s and constructs an ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," from it.\nThe ",Object(o.b)("inlineCode",{parentName:"p"},"Pair")," must contain a ",Object(o.b)("inlineCode",{parentName:"p"},"String")," in the ",Object(o.b)("inlineCode",{parentName:"p"},"fst")," and any type of value in\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"snd"),". The ",Object(o.b)("inlineCode",{parentName:"p"},"fst")," will become the key for the value in the ",Object(o.b)("inlineCode",{parentName:"p"},"snd"),". All\nprimitive values are copied into the new ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),", while non-primitives are\nreferences to the original. If you provide an ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," values for the second,\nthat ",Object(o.b)("inlineCode",{parentName:"p"},"Pair")," will not be represented in the resulting ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),". Also, when if\nmultiple keys share the same name, that last value will be moved over."),Object(o.b)("h3",{id:"getpathor"},"getPathOr"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/getPathOr")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"getPathOr :: a -> [ (String | Integer) ] -> b -> a\n")),Object(o.b)("p",null,"While ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#getpropor"}),Object(o.b)("inlineCode",{parentName:"a"},"getPropOr"))," is good for simple, single-level\nstructures, there may come a time when you have to work with nested POJOs or\nArrays. When you run into this situation, just pull in ",Object(o.b)("inlineCode",{parentName:"p"},"getPathOr"),", which was\npreviously called ",Object(o.b)("inlineCode",{parentName:"p"},"propPathOr"),", and pass it a left-to-right traversal path of\nkeys, indices or a combination of both (gross...but possible). This will kick\nyou back a function that behaves just like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#getpropor"}),Object(o.b)("inlineCode",{parentName:"a"},"getPropOr")),'. You pass\nit some data, and it will attempt to resolve your provided path. If the path is\nvalid, it will return the value. But if at any point that path "breaks" it will\ngive you back the default value.'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import getPathOr from 'crocks/helpers/getPathOr'\n\nconst data = {\n  foo: {\n    bar: 'bar',\n    null: null,\n    nan: NaN,\n    undef: undefined\n  },\n  arr: [ 1, 2 ]\n}\n\n// def :: [ String | Integer ] -> a -> b\nconst def =\n  getPathOr('default')\n\ndef([ 'foo', 'bar' ], data)\n//=> \"bar\"\n\ndef([ 'baz', 'tommy' ], data)\n//=> \"default\"\n\ndef([ 'foo', 'null' ], data)\n//=> null\n\ndef([ 'foo', 'nan' ], data)\n//=> NaN\n\ndef([ 'foo', 'undef' ], data)\n//=> \"default\"\n\ndef([ 'arr', 'length' ], data)\n//=> 2\n")),Object(o.b)("h3",{id:"getpropor"},"getPropOr"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/getPropOr")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"getPropOr :: a -> (String | Integer) -> b -> a\n")),Object(o.b)("p",null,"Reach for ",Object(o.b)("inlineCode",{parentName:"p"},"getPropOr"),", previously known as ",Object(o.b)("inlineCode",{parentName:"p"},"propOr"),", when you want some safety\naround pulling a value out of an Object or Array with a single key or\nindex. Well, as long as you are working with non-nested data that is. Just\ntell ",Object(o.b)("inlineCode",{parentName:"p"},"getPropOr")," either the key or index you are interested in, and you will get\nback a function that will take anything and return the wrapped value if the\nkey/index is defined. If the key/index is not defined however, you will get back\nthe provided default value."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import getPropOr from 'crocks/helpers/getPropOr'\n\nconst data = {\n  foo: 'bar',\n  null: null,\n  nan: NaN,\n  undef: undefined\n}\n\n// def :: (String | Integer) -> a -> b\nconst def =\n  getPropOr('default')\n\ndef('foo', data)\n//=> \"bar\"\n\ndef('null', data)\n//=> null\n\ndef('nan', data)\n//=> NaN\n\ndef('baz', data)\n//=> \"default\"\n\ndef('undef', data)\n//=> \"default\"\n")),Object(o.b)("h3",{id:"lifta2"},"liftA2"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/liftA2")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"liftA2 :: Applicative m => (a -> b -> c) -> m a -> m b -> m c\n")),Object(o.b)("h3",{id:"lifta3"},"liftA3"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/liftA3")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"liftA3 :: Applicative m => (a -> b -> c -> d) -> m a -> m b -> m c -> m d\n")),Object(o.b)("p",null,"Ever see yourself wanting to ",Object(o.b)("inlineCode",{parentName:"p"},"map")," a binary or trinary function, but ",Object(o.b)("inlineCode",{parentName:"p"},"map")," only\nallows unary functions? Both of these functions allow you to pass in your\nfunction as well as the number of ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative"),"s (containers that provide\nboth ",Object(o.b)("inlineCode",{parentName:"p"},"of")," and ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," functions) you need to get the mapping you are looking for."),Object(o.b)("h3",{id:"liftn"},"liftN"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/liftN")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"liftN :: Applicative m => Number -> ((*) -> a) -> (*m) -> m a\n")),Object(o.b)("p",null,"While ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#lifta2"}),Object(o.b)("inlineCode",{parentName:"a"},"liftA2"))," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#lifta3"}),Object(o.b)("inlineCode",{parentName:"a"},"liftA3"))," will handle a majority of\nthe functions we tend to encounter, many cases arise when we want to deal with\nfunctions of a greater arity. In those cases, ",Object(o.b)("inlineCode",{parentName:"p"},"liftN")," will allow the lifting of\nfunction of any size arity."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"liftN")," takes a ",Object(o.b)("inlineCode",{parentName:"p"},"Number")," that specifies the arity of the function to be lifted,\nfollowed by the function itself and finally the required number\nof ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative")," instances of the same type to be applied to the target\nfunction."),Object(o.b)("p",null,"In most cases, there is no need to explicitly curry the target function. This\nfunction operates in the same vein as ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#nary"}),Object(o.b)("inlineCode",{parentName:"a"},"nAry"))," and as such manually\ncurried functions (i.e. ",Object(o.b)("inlineCode",{parentName:"p"},"x => y => x + y"),") will need to be explicitly curried\nusing ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#curry"}),Object(o.b)("inlineCode",{parentName:"a"},"curry"))," to ensure proper application of the arguments."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import liftN from 'crocks/helpers/liftN'\n\nimport compose from 'crocks/helpers/compose'\nimport curry from 'crocks/helpers/curry'\nimport isNumber from 'crocks/predicates/isNumber'\nimport isString from 'crocks/predicates/isString'\nimport map from 'crocks/pointfree/map'\nimport safe from 'crocks/Maybe/safe'\n\n// apply :: (((*) -> b), [ a ]) -> b\nconst apply = fn => xs =>\n  fn.apply(null, xs)\n\n// join :: String -> String -> String\nconst join = x => y =>\n  `${x} ${y}`\n\n// safeString :: a -> Maybe String\nconst safeString =\n  safe(isString)\n\n// sumArgs :: (* Number) -> Number\nconst sumArgs = (...args) =>\n  args.reduce((x, y) => x + y, 0)\n\n// max :: Applicative m => [ m Number ] -> m Number\nconst max =\n  apply(liftN(4, Math.max))\n\n// sum :: Applicative m => [ m Number ] -> m Number\nconst sum =\n  apply(liftN(4, sumArgs))\n\n// apJoin :: Applicative m => [ m String ] -> m String\nconst apJoin =\n  liftN(2, curry(join))\n\n// good :: [ Number ]\nconst good =\n  [ 45, 54, 96, 99 ]\n\n// bad :: [ String ]\nconst bad =\n  [ 'one', 'two', 'three', 'four' ]\n\n// arMax :: [ Number ] -> [ Number ]\nconst arMax =\n  compose(max, map(Array.of))\n\n// safeSum :: Maybe Number -> Maybe Number\nconst safeSum =\n  compose(sum, map(safe(isNumber)))\n\narMax(good)\n//=> [ 99 ]\n\nsafeSum(good)\n//=> Just 294\n\nsafeSum(bad)\n//=> Nothing\n\napJoin(safeString('Joey'), safeString('Fella'))\n//=> Just \"Joey Fella\"\n\napJoin(safeString(9), safeString('Fella'))\n//=> Nothing\n")),Object(o.b)("h3",{id:"mapprops"},"mapProps"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/mapProps")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"mapProps :: { (* -> *) } -> Object -> Object\n")),Object(o.b)("p",null,"Would like to map specific keys in an Object with a specific function? Just\nbring in ",Object(o.b)("inlineCode",{parentName:"p"},"mapProps")," and pass it an ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," with the functions you want to apply\non the keys you want them associated to. When the resulting function receives\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),", it will return a new ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," with the keys mapped according to the\nmapping functions. All keys from the original ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," that do not exist in\nthe mapping ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," will still exist untouched, but the keys with mapping\nfunctions with now contain the result of applying the original value to the\nprovided mapping function."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"mapProps")," also allows for mapping on nested ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s for times when the shape\nof the original ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," is know."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import mapProps from 'crocks/helpers/mapProps'\n\n// add :: Number -> Number -> Number\nconst add = x => y =>\n  x + y\n\n// toUpper :: String -> String\nconst toUpper = x =>\n  x.toUpperCase()\n\n// mapping :: Object\nconst mapping = {\n  entry: toUpper,\n  fauna: {\n    unicorns: add(1),\n    elephants: add(-1)\n  },\n  flora: {\n    nariphon: add(10),\n    birch: add(1)\n  }\n}\n\nmapProps(mapping, {\n  entry: 'legend',\n  fauna: {\n    unicorns: 10,\n    zombies: 3\n  },\n  other: {\n    hat: 2\n  }\n})\n//=> { entry: 'LEGEND', fauna: { unicorns: 11, zombies: 3 }, other: { hat: 2} }\n")),Object(o.b)("h3",{id:"mapreduce"},"mapReduce"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/mapReduce")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"mapReduce :: Foldable f => (a -> b) -> (c -> b -> c) -> c -> f a -> c\n")),Object(o.b)("p",null,"Sometimes you need the power provided by ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#mreducemap"}),Object(o.b)("inlineCode",{parentName:"a"},"mreduceMap"))," but you do\nnot have a ",Object(o.b)("inlineCode",{parentName:"p"},"Monoid")," to lift into. ",Object(o.b)("inlineCode",{parentName:"p"},"mapReduce")," provides the same power, but with\nthe flexibility of using functions to lift and combine. ",Object(o.b)("inlineCode",{parentName:"p"},"mapReduce")," takes a\nunary mapping function, a binary reduction function, the initial value and\nfinally a ",Object(o.b)("inlineCode",{parentName:"p"},"Foldable")," structure of data. Once all arguments are provided,\n",Object(o.b)("inlineCode",{parentName:"p"},"mapReduce")," folds the provided data, by mapping each value through your mapping\nfunction, before sending it to the second argument of your reduction function."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import mapReduce from 'crocks/helpers/mapReduce'\n\nimport isNumber from 'crocks/predicates/isNumber'\nimport Maybe from 'crocks/Maybe'\nimport Max from 'crocks/Max'\nimport safeLift from 'crocks/Maybe/safeLift'\n\nconst { Nothing } = Maybe\n\n// data :: [ * ]\nconst data =\n  [ '100', null, 3, true, 1 ]\n\n// safeMax :: [ * ] -> Maybe Max\nconst safeMax = mapReduce(\n  safeLift(isNumber, Max),\n  (y, x) => y.concat(x).alt(y).alt(x),\n  Nothing()\n)\n\nsafeMax(data)\n  .option(Max.empty())\n  .valueOf()\n//=> 3\n")),Object(o.b)("h3",{id:"mconcat"},"mconcat"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/mconcat")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"mconcat :: Monoid m, Foldable f => m -> f a -> m a\n")),Object(o.b)("h3",{id:"mreduce"},"mreduce"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/mreduce")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"mreduce :: Monoid m, Foldable f => m -> f a -> a\n")),Object(o.b)("p",null,"These two functions are very handy for combining an entire ",Object(o.b)("inlineCode",{parentName:"p"},"List")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," of\nvalues by providing a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/"}),Object(o.b)("inlineCode",{parentName:"a"},"Monoid"))," and your collection of\nvalues. The difference between the two is that ",Object(o.b)("inlineCode",{parentName:"p"},"mconcat")," returns the result\ninside the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/"}),Object(o.b)("inlineCode",{parentName:"a"},"Monoid"))," used to combine them.\nWhere ",Object(o.b)("inlineCode",{parentName:"p"},"mreduce")," returns the bare value itself."),Object(o.b)("h3",{id:"mconcatmap"},"mconcatMap"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/mconcatMap")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"mconcatMap :: Monoid m, Foldable f => m -> (b -> a) -> f b -> m a\n")),Object(o.b)("h3",{id:"mreducemap"},"mreduceMap"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/mreduceMap")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"mreduceMap :: Monoid m, Foldable f => m -> (b -> a) -> f b -> a\n")),Object(o.b)("p",null,"There comes a time where the values you have in a ",Object(o.b)("inlineCode",{parentName:"p"},"List")," or an ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," are not\nin the type that is needed for the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/"}),Object(o.b)("inlineCode",{parentName:"a"},"Monoid"))," you want to\ncombine with. These two functions can be used to ",Object(o.b)("inlineCode",{parentName:"p"},"map")," some transforming\nfunction from a given type into the type needed for\nthe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/"}),Object(o.b)("inlineCode",{parentName:"a"},"Monoid")),". In essence, this function will run each value through\nthe function before it lifts the value into the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/"}),Object(o.b)("inlineCode",{parentName:"a"},"Monoid")),",\nbefore ",Object(o.b)("inlineCode",{parentName:"p"},"concat")," is applied. The difference between the two is\nthat ",Object(o.b)("inlineCode",{parentName:"p"},"mconcatMap")," returns the result inside the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/"}),Object(o.b)("inlineCode",{parentName:"a"},"Monoid"))," used\nto combine them. Where ",Object(o.b)("inlineCode",{parentName:"p"},"mreduceMap")," returns the bare value itself."),Object(o.b)("h3",{id:"nary"},"nAry"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/nAry")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"nAry :: Number -> ((*) -> a) -> (*) -> a\n")),Object(o.b)("p",null,"When using functions like ",Object(o.b)("inlineCode",{parentName:"p"},"Math.max")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Object.assign")," that take as many\narguments as you can throw at them, it makes it hard to ",Object(o.b)("inlineCode",{parentName:"p"},"curry")," them in a\nreasonable manner. ",Object(o.b)("inlineCode",{parentName:"p"},"nAry")," can make things a little nicer for functions like\nthat. It can also be put to good use to limit a given function to a desired\nnumber of arguments to avoid accidentally supplying default arguments when you\ndo not what them applied. First pass ",Object(o.b)("inlineCode",{parentName:"p"},"nAry")," the number of arguments you wish to\nlimit the function to and then the function you wish to limit. ",Object(o.b)("inlineCode",{parentName:"p"},"nAry")," will give\nyou back a curried function that will only apply the specified number of\narguments to the inner function. Unary and binary functions are so common\nthat ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," provides specific functions for those\ncases: ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#unary"}),Object(o.b)("inlineCode",{parentName:"a"},"unary"))," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#binary"}),Object(o.b)("inlineCode",{parentName:"a"},"binary")),"."),Object(o.b)("h3",{id:"objof"},"objOf"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/objOf")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"objOf :: String -> a -> Object\n")),Object(o.b)("p",null,"If you ever find yourself in a situation where you have a key and a value and\njust want to combine the two into an ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),", then it sounds like ",Object(o.b)("inlineCode",{parentName:"p"},"objOf")," is\nthe function for you. Just pass it a ",Object(o.b)("inlineCode",{parentName:"p"},"String")," for the key and any type of value,\nand you'll get back an ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," that is composed of those two. If you find\nyourself constantly concatenating the result of this function into\nanother ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),", you may want to use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#assoc"}),Object(o.b)("inlineCode",{parentName:"a"},"assoc"))," instead."),Object(o.b)("h3",{id:"omit"},"omit"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/omit")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"omit :: [ String ] -> Object -> Object\n")),Object(o.b)("p",null,"Sometimes you just want to strip ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s of unwanted properties by key.\nUsing ",Object(o.b)("inlineCode",{parentName:"p"},"omit")," will help you get that done. Just pass it a ",Object(o.b)("inlineCode",{parentName:"p"},"Foldable")," structure\nwith a series of ",Object(o.b)("inlineCode",{parentName:"p"},"String"),"s as keys and then pass it an ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," and you will\nget back not only a shallow copy, but also an ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," free of any of those\npesky ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," values. You can think of ",Object(o.b)("inlineCode",{parentName:"p"},"omit")," as a way to black-list or\nreject ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," properties based on key names. This function ignores inherited\nproperties and should only be used with POJOs. If you want to filter or\nwhite-list properties rather than reject them, take a look at ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#pick"}),Object(o.b)("inlineCode",{parentName:"a"},"pick")),"."),Object(o.b)("h3",{id:"once"},"once"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/once")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"once :: ((*) -> a) -> ((*) -> a)\n")),Object(o.b)("p",null,"There are times in JavaScript development where you only want to call a function\nonce and memo-ize the first result for every subsequent call to that function.\nJust pass the function you want guarded to ",Object(o.b)("inlineCode",{parentName:"p"},"once")," and you will get back a\nfunction with the expected guarantees."),Object(o.b)("h3",{id:"partial"},"partial"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/partial")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"partial :: (((*) -> c), *) -> (*) -> c\n")),Object(o.b)("p",null,"There are many times when using functions from non-functional libraries or from\nbuilt-in JS functions, where it does not make sense to wrap it in\na ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#curry"}),Object(o.b)("inlineCode",{parentName:"a"},"curry")),". You just want to partially apply some arguments to it and\nget back a function ready to take the rest. That is a perfect opportunity to\nuse ",Object(o.b)("inlineCode",{parentName:"p"},"partial"),". Just pass a function as the first argument and then apply any\nother arguments to it. You will get back a curried function that is ready to\naccept the rest of the arguments."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import partial from 'crocks/helpers/partial'\n\nimport map from 'crocks/pointfree/map'\n\n// max10 :: Number -> Number\nconst max10 =\n  partial(Math.min, 10)\n\n// data :: [ Number ]\nconst data =\n  [ 13, 5, 13 ]\n\nmap(max10, data)\n//=> [ 10, 5, 10]\n")),Object(o.b)("h3",{id:"pick"},"pick"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/pick")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"pick :: Foldable f => f String -> Object -> Object\n")),Object(o.b)("p",null,"When dealing with ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s, sometimes it is necessary to only let some of the\nkey-value pairs on an object through. Think of ",Object(o.b)("inlineCode",{parentName:"p"},"pick")," as a sort of white-list or\nfilter for ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," properties. Pass it a ",Object(o.b)("inlineCode",{parentName:"p"},"Foldable")," structure of ",Object(o.b)("inlineCode",{parentName:"p"},"String"),"s that\nare the keys you would like to pick off of your ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),". This will give you\nback a shallow copy of the key-value pairs you specified. This function will\nignore inherited properties and should only be used with POJOs.\nAny ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," values will not be copied over, although ",Object(o.b)("inlineCode",{parentName:"p"},"null")," values are\nallowed. For black-listing properties, have a look at ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#omit"}),Object(o.b)("inlineCode",{parentName:"a"},"omit")),"."),Object(o.b)("h3",{id:"pipe"},"pipe"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/pipe")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"pipe :: ((a -> b), ..., (y -> z)) -> a -> z\n")),Object(o.b)("p",null,"Similar to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#compose"}),Object(o.b)("inlineCode",{parentName:"a"},"compose")),", ",Object(o.b)("inlineCode",{parentName:"p"},"pipe")," allows for the composition of\nfunctions, but takes its functions in a left-to-right fashion, which is the\nopposite of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#compose"}),Object(o.b)("inlineCode",{parentName:"a"},"compose")),". Just like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#compose"}),Object(o.b)("inlineCode",{parentName:"a"},"compose")),", ",Object(o.b)("inlineCode",{parentName:"p"},"pipe"),"\nwill return a new function that represents the composed flow."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import pipe from 'crocks/helpers/pipe'\n\nimport objOf from 'crocks/helpers/objOf'\n\n// double :: Number -> Number\nconst double = x =>\n  x + x\n\n// doubleAndWrap :: Number -> Object\nconst doubleAndWrap = pipe(\n  double,\n  objOf('result')\n)\n\ndoubleAndWrap(25)\n//=> { result: 50 }\n\ndoubleAndWrap(0)\n//=> { result: 0 }\n")),Object(o.b)("h3",{id:"pipek"},"pipeK"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/pipeK")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"pipeK :: Chain m => ((a -> m b), ..., (y -> m z)) -> a -> m z\n")),Object(o.b)("p",null,"Like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#composek"}),Object(o.b)("inlineCode",{parentName:"a"},"composeK")),", you can remove much of the boilerplate when\nchaining together a series of functions with the signature:\n",Object(o.b)("inlineCode",{parentName:"p"},"Chain m => a -> m b"),". The difference between the two functions is, while\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#composek"}),Object(o.b)("inlineCode",{parentName:"a"},"composeK"))," is right-to-left, ",Object(o.b)("inlineCode",{parentName:"p"},"pipeK")," is the opposite, taking its\nfunctions left-to-right."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import pipeK from 'crocks/helpers/pipeK'\n\nimport curry from 'crocks/core/curry'\nimport List from 'crocks/List'\nimport Writer from 'crocks/Writer'\n\n// OpWriter :: Writer List\nconst OpWriter =\n  Writer(List)\n\n// addLog :: Number -> Number -> OpWriter Number\nconst addLog = curry(\n  (x, y) =>\n    OpWriter(`adding ${x} to ${y}`, x + y)\n)\n\n// addLog :: Number -> Number -> OpWriter Number\nconst scaleLog = curry(\n  (x, y) =>\n    OpWriter(`scaling ${y} by ${x}`, x * y)\n)\n\nconst fluent = x =>\n  OpWriter.of(x)\n    .chain(addLog(4))\n    .chain(scaleLog(3))\n\nfluent(0).log()\n//=> List [ \"adding 4 to 0\", \"scaling 4 by 3\" ]\n\nconst chainPipe = pipeK(\n  addLog(4),\n  scaleLog(3)\n)\n\nchainPipe(0).log()\n//=> List [ \"adding 4 to 0\", \"scaling 4 by 3\" ]\n")),Object(o.b)("h3",{id:"pipep"},"pipeP"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/pipeP")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"pipeP :: Promise p => ((a -> p b d), ..., (y -> p z d)) -> a -> p z d\n")),Object(o.b)("p",null,"Like the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#composep"}),Object(o.b)("inlineCode",{parentName:"a"},"composeP"))," function, ",Object(o.b)("inlineCode",{parentName:"p"},"pipeP")," will let you remove the\nstandard boilerplate that comes with working with ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," chains. The only\ndifference between ",Object(o.b)("inlineCode",{parentName:"p"},"pipeP")," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#composep"}),Object(o.b)("inlineCode",{parentName:"a"},"composeP"))," is that it takes its\nfunctions in a left-to-right order:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import pipeP from 'crocks/helpers/pipeP'\n\nimport Async from 'crocks/Async'\nimport asyncToPromise from 'crocks/Async/asyncToPromise'\nimport composeB from 'crocks/combinators/composeB'\n\nconst { resolveAfter } = Async\n\n// prod :: Number -> Number -> Number\nconst prod = a => b =>\n  b * a\n\n// resolveQuick :: a -> Async e a\nconst resolveQuick = value =>\n  resolveAfter(300, value)\n\n// promise :: a -> Promise a e\nconst promise = composeB(\n  asyncToPromise, resolveQuick\n)\n\n// double :: Number -> Number\nconst double =\n  prod(2)\n\n// triple :: Number -> Number\nconst triple =\n  prod(3)\n\n// promFunc :: Number -> Promise Number e\nconst promFunc = x =>\n  promise(x)\n    .then(double)\n    .then(triple)\n\n// promPipe :: Number -> Promise Number e\nconst promPipe =\n  pipeP(promise, double, triple)\n\npromFunc(5)\n  .then(v => console.log(v))\n//=> 30\n\npromPipe(5)\n  .then(v => console.log(v))\n//=> 30\n")),Object(o.b)("h3",{id:"pipes"},"pipeS"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/pipeS")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"pipeS :: Semigroupoid s => (s a b, ..., s y z) -> s a z\n")),Object(o.b)("p",null,"While ",Object(o.b)("inlineCode",{parentName:"p"},"Star"),"s and ",Object(o.b)("inlineCode",{parentName:"p"},"Arrow"),"s come in very handy at times, the only thing that\ncould make them better is to compose them. With ",Object(o.b)("inlineCode",{parentName:"p"},"pipeS")," you can do just that\nwith any ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroupoid"),". Just like with ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#composes"}),Object(o.b)("inlineCode",{parentName:"a"},"composeS")),", you just pass\nit ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroupoid"),"s of the same type and you will get back\nanother ",Object(o.b)("inlineCode",{parentName:"p"},"Semigroupoid")," with them all composed together. The only difference\nbetween the two, is that ",Object(o.b)("inlineCode",{parentName:"p"},"pipeS")," composes in a left-to-right fashion,\nwhile ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#composes"}),Object(o.b)("inlineCode",{parentName:"a"},"composeS"))," does the opposite."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import pipeS from 'crocks/helpers/pipeS'\n\nimport Maybe from 'crocks/Maybe'\n\nimport curry from 'crocks/core/curry'\nimport getProp from 'crocks/Maybe/getProp'\nimport isNumber from 'crocks/predicates/isNumber'\nimport safeLift from 'crocks/Maybe/safeLift'\nimport Star from 'crocks/Star'\n\n// MaybeStar :: Star a (Maybe b)\nconst MaybeStar =\n  Star(Maybe)\n\n// add :: Number -> Number -> Number\nconst add = curry(\n  (x, y) => x + y\n)\n\n// pull :: String -> MaybeStar Object Number\nconst pull = x =>\n  MaybeStar(getProp(x))\n\n// safeAdd :: Number -> MaybeStar Number Number\nconst safeAdd = x =>\n  MaybeStar(safeLift(isNumber, add(x)))\n\n// data :: { num: Number, string: String }\nconst data = {\n  num: 56,\n  string: '56'\n}\n\n// flow :: (String, Number) -> MaybeStar Object Number\nconst flow = (key, num) => pipeS(\n  pull(key),\n  safeAdd(num)\n)\n\nflow('num', 10)\n  .runWith(data)\n//=> Just 66\n\nflow('string', 100)\n  .runWith(data)\n//=> Nothing\n")),Object(o.b)("h3",{id:"setpath"},"setPath"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/setPath")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"setPath :: [ (String | Integer) ] -> a -> (Object | Array) -> (Object | Array)\n")),Object(o.b)("p",null,"Used to set a value on a deeply nested ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),", ",Object(o.b)("inlineCode",{parentName:"p"},"setPath")," will traverse down\na path and set the a the final property to the provided value. ",Object(o.b)("inlineCode",{parentName:"p"},"setPath")," returns\nthe an ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"/",Object(o.b)("inlineCode",{parentName:"p"},"Array")," with the modification and does not alter the\noriginal ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"/",Object(o.b)("inlineCode",{parentName:"p"},"Array")," along the path."),Object(o.b)("p",null,"The provided path can be a mixture of either ",Object(o.b)("inlineCode",{parentName:"p"},"Integer"),"s or ",Object(o.b)("inlineCode",{parentName:"p"},"String"),"s to allow\nfor traversing through both ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),"s and ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s. When an ",Object(o.b)("inlineCode",{parentName:"p"},"Integer")," zero or\ngreater is provided it will treat that portion as an ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," while ",Object(o.b)("inlineCode",{parentName:"p"},"String"),"s are\nused to reference through ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s. If at any point in the provided\na ",Object(o.b)("inlineCode",{parentName:"p"},"NaN"),", ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," or ",Object(o.b)("inlineCode",{parentName:"p"},"null")," values is encountered, a\nnew ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"/",Object(o.b)("inlineCode",{parentName:"p"},"Array")," will be created."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import setPath from 'crocks/helpers/setPath'\n\nsetPath([ 'account', 'name' ], 'Awesome Place', {\n  account: {\n    name: 'Great Place',\n    rating: 5\n  }\n})\n//=> { account: { name: 'Awesome Place', rating: 5 } }\n\nsetPath([ 'people', 2, 'age' ], 26, {\n  people: [\n    { name: 'George', age: 22 },\n    { name: 'Greta', age: 21 },\n    { name: 'Ali', age: 25 }\n  ]\n})\n//=> { people: [\n//   { name: 'George', age: 22 },\n//   { name: 'Greta', age: 21 },\n//   { name: 'Ali', age: 26 },\n// ] }\n\nsetPath([ 'a', 'c' ], false, { a: { b: true } })\n//=> { a: { b: true, c: false } }\n\nsetPath([ 'list', 'a' ], 'ohhh, I see.', { list: [ 'string', 'another' ] })\n//=> { list: { 0: 'string', 1: 'another', a: 'ohhh, I see.' } }\n")),Object(o.b)("h3",{id:"setprop"},"setProp"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/setProp")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"setProp ::  (String | Integer) -> a -> (Object | Array) -> (Object | Array)\n")),Object(o.b)("p",null,"Used to set a given value for a specific key or index of\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),". ",Object(o.b)("inlineCode",{parentName:"p"},"setProp"),", previously called ",Object(o.b)("inlineCode",{parentName:"p"},"assoc"),", takes either\na ",Object(o.b)("inlineCode",{parentName:"p"},"String")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Integer")," value as its first argument and a value of any type as\nits second. The third parameter is dependent of the type of the first argument.\nWhen a ",Object(o.b)("inlineCode",{parentName:"p"},"String")," is provided, the third argument must be an ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),". Otherwise\nif the first argument is an ",Object(o.b)("inlineCode",{parentName:"p"},"Integer")," zero or greater, then the third must be\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"setProp")," will return a new instance of either ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," with the\naddition applied. When the value exists on the provided object, then the value\nwill overwritten. If the value does not exist then it will be added to the\nresulting structure. In the case of ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),", the value will be added to the\nprovided index, leaving ",Object(o.b)("inlineCode",{parentName:"p"},"undefined")," values, resulting in a sparse ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import setProp from 'crocks/helpers/setProp'\n\nsetProp('a', false, { a: true })\n//=> { a: false }\n\nsetProp('b', 43, { a: true })\n//=> { a: true, b: 43 }\n\nsetProp(0, 'string', [ 'a' ])\n//=> [ \"string\" ]\n\nsetProp(1, 'b', [ 'a' ])\n//=> [ \"a\", \"b\" ]\n\nsetProp(2, 'c', [ 'a' ])\n//=> [ \"a\", undefined, \"c\" ]\n")),Object(o.b)("h3",{id:"tap"},"tap"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/tap")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"tap :: (a -> b) -> a -> a\n")),Object(o.b)("p",null,"It is hard knowing what is going on inside of some of these ADTs or your\nwonderful function compositions. Debugging can get messy when you need to insert\na side-effect into your flow for introspection purposes. With ",Object(o.b)("inlineCode",{parentName:"p"},"tap"),", you can\nintervene in your otherwise pristine flow and make sure that the original value\nis passed along to the next step of your flow. This function does not guarantee\nimmutability for reference types (",Object(o.b)("inlineCode",{parentName:"p"},"Objects"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Arrays"),", etc), you will need to\nexercise some discipline here to not mutate."),Object(o.b)("h3",{id:"trycatch"},"tryCatch"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Result/tryCatch")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"tryCatch :: ((*) -> b) -> (*) -> Result e b\n")),Object(o.b)("p",null,"Typical try-catch blocks are very imperative in their usage. This ",Object(o.b)("inlineCode",{parentName:"p"},"tryCatch")," function\nprovides a means of capturing that imperative nature in a simple declarative\nstyle. Pass it a function that could fail and it will return you another function\nwrapping the first function. When called, the new function will either return the\nresult in a ",Object(o.b)("inlineCode",{parentName:"p"},"Result.Ok")," if everything was good, or an error wrapped in\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Result.Err")," if it fails."),Object(o.b)("h3",{id:"unary"},"unary"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/unary")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"unary :: ((*) -> b) -> a -> b\n")),Object(o.b)("p",null,"If you every need to lock down a given function to just one argument, then look\nno further than ",Object(o.b)("inlineCode",{parentName:"p"},"unary"),". Just pass it a function of any arity, and you will get\nback another function that will only apply (1) argument to given function, no\nmatter what is passed to it. ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," is just syntactic sugar around\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#nary"}),Object(o.b)("inlineCode",{parentName:"a"},"nAry"))," in the form of ",Object(o.b)("inlineCode",{parentName:"p"},"nAry(1, fn)")," as it is such a common case.\nAnother common case is ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#binary"}),Object(o.b)("inlineCode",{parentName:"a"},"binary"))," which, as the name implies, only\napplies (2) arguments to a given function."),Object(o.b)("h3",{id:"unit"},"unit"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/unit")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"unit :: () -> undefined\n")),Object(o.b)("p",null,"While it seems like just a simple function, ",Object(o.b)("inlineCode",{parentName:"p"},"unit")," can be used for a number of\nthings. A common use for it is as a default ",Object(o.b)("inlineCode",{parentName:"p"},"noop")," as it is a function that does\nnothing and returns ",Object(o.b)("inlineCode",{parentName:"p"},"undefined"),". You can also use it in a pointed fashion to\nrepresent some special value for a given type. This pointed use is the heart and\nsoul of the infamous ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../crocks/Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," type."),Object(o.b)("h3",{id:"unsetpath"},"unsetPath"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/unsetPath")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"unsetPath :: [ (String | Integer) ] -> a -> a\n")),Object(o.b)("p",null,"Used to remove a property or index on a deeply nested ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"/",Object(o.b)("inlineCode",{parentName:"p"},"Array"),".\n",Object(o.b)("inlineCode",{parentName:"p"},"unsetPath"),", previously called ",Object(o.b)("inlineCode",{parentName:"p"},"dissoc"),", will return a new instance with the\nproperty or index removed."),Object(o.b)("p",null,"The provided path can be a mixture of either Positive ",Object(o.b)("inlineCode",{parentName:"p"},"Integer"),"s or ",Object(o.b)("inlineCode",{parentName:"p"},"String"),"s to\nallow for traversing through both ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),"s and ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s. When an ",Object(o.b)("inlineCode",{parentName:"p"},"Integer")," is\nprovided it will treat that portion as an ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," while ",Object(o.b)("inlineCode",{parentName:"p"},"String"),"s are used to\nreference through ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"s."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import unsetPath from 'crocks/helpers/unsetPath'\n\nunsetPath([ 'people', 0, 'remove' ], {\n  people: [\n    { name: 'Tonya', remove: true },\n    { name: 'Bobby' }\n  ]\n})\n//=> { people: [ { name: 'Tonya' }, { name: 'Bobby' } ] }\n\nunsetPath([ 'a', 'c', 'd' ], { a: null })\n//=> { a: null }\n\nunsetPath([ 'a', 'b' ], { a: { b: false } })\n//=> { a: {} }\n\nunsetPath([ 'a', 'b' ], { a: { c: false } })\n//=> { a: { c: false } }\n")),Object(o.b)("h3",{id:"unsetprop"},"unsetProp"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/helpers/unsetProp")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"unsetProp :: (String | Integer) -> a -> a\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"unsetProp"),' is a binary function that takes either a property name or an index\nas its first argument. Which specifies what should be removed, or "unset", from\nthe ',Object(o.b)("inlineCode",{parentName:"p"},"Object")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," provided as the second argument. If the value provided\nfor the second argument is not an ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),", then the value provided\nis echoed back as the result."),Object(o.b)("p",null,"The first argument must be either a non-empty ",Object(o.b)("inlineCode",{parentName:"p"},"String")," or\npositive ",Object(o.b)("inlineCode",{parentName:"p"},"Integer"),". A ",Object(o.b)("inlineCode",{parentName:"p"},"String")," should be provided when working with\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),", while ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),"s require an ",Object(o.b)("inlineCode",{parentName:"p"},"Integer"),". ",Object(o.b)("inlineCode",{parentName:"p"},"unsetProp")," will return a new\ninstance of either the ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Array"),", sans the key or index."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import unsetProp from '/crocks/helpers/unsetProp'\n\nunsetProp('temp', { name: 'Joey', temp: 33 })\n//=> { name: 'Joey' }\n\nunsetProp(1, [ 33, 22, 99 ])\n//=> [ 33, 99 ]\n\nunsetProp('d', { a: 'A', b: 'B' })\n//=> { a: 'A', b: 'B' }\n\nunsetProp(10, [ 'a', 'b', 'c' ])\n//=> [ 'a', 'b', 'c' ]\n\nunsetProp('silly', null)\n//=> null\n")))}b.isMDXComponent=!0}}]);