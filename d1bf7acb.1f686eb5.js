(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{100:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return j}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),b=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=b(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=b(t),m=a,j=p["".concat(c,".").concat(m)]||p[m]||d[m]||o;return t?r.a.createElement(j,i(i({ref:n},l),{},{components:t})):r.a.createElement(j,i({ref:n},l))}));function j(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,c=new Array(o);c[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,c[1]=i;for(var l=2;l<o;l++)c[l]=t[l];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},93:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return i})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return b}));var a=t(2),r=t(6),o=(t(0),t(100)),c={title:"Async",description:"Async Crock"},i={unversionedId:"crocks/Async",id:"crocks/Async",isDocsHomePage:!1,title:"Async",description:"Async Crock",source:"@site/docs/crocks/Async.md",slug:"/crocks/Async",permalink:"/docs/crocks/Async",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/crocks/Async.md",version:"current",sidebar:"sidebar",previous:{title:"Arrow",permalink:"/docs/crocks/Arrow"},next:{title:"Const",permalink:"/docs/crocks/Const"}},s=[{value:"Implements",id:"implements",children:[]},{value:"Construction",id:"construction",children:[]},{value:"Constructor Methods",id:"constructor-methods",children:[{value:"Rejected",id:"rejected",children:[]},{value:"Resolved",id:"resolved",children:[]},{value:"fromPromise",id:"frompromise",children:[]},{value:"fromNode",id:"fromnode",children:[]},{value:"all",id:"all",children:[]},{value:"resolveAfter",id:"resolveafter",children:[]},{value:"rejectAfter",id:"rejectafter",children:[]},{value:"of",id:"of",children:[]}]},{value:"Instance Methods",id:"instance-methods",children:[{value:"map",id:"map",children:[]},{value:"alt",id:"alt",children:[]},{value:"bimap",id:"bimap",children:[]},{value:"ap",id:"ap",children:[]},{value:"chain",id:"chain",children:[]},{value:"coalesce",id:"coalesce",children:[]},{value:"bichain",id:"bichain",children:[]},{value:"swap",id:"swap",children:[]},{value:"race",id:"race",children:[]},{value:"fork",id:"fork",children:[]},{value:"toPromise",id:"topromise",children:[]}]},{value:"Pointfree Functions",id:"pointfree-functions",children:[{value:"race (pointfree)",id:"race-pointfree",children:[]}]},{value:"Transformation Functions",id:"transformation-functions",children:[{value:"asyncToPromise",id:"asynctopromise",children:[]},{value:"eitherToAsync",id:"eithertoasync",children:[]},{value:"firstToAsync",id:"firsttoasync",children:[]},{value:"lastToAsync",id:"lasttoasync",children:[]},{value:"maybeToAsync",id:"maybetoasync",children:[]},{value:"resultToAsync",id:"resulttoasync",children:[]}]}],l={rightToc:s};function b(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a = Rejected e | Resolved a\n")),Object(o.b)("p",null,'Defined as a "lazy" Sum Type that implements an asynchronous control structure,\n',Object(o.b)("inlineCode",{parentName:"p"},"Async"),' represents either the success or failure of a given asynchronous\noperation. The "laziness" of ',Object(o.b)("inlineCode",{parentName:"p"},"Async"),' allows the ability to build complex\nasynchronous operations by defining each portion of that flow as smaller "steps"\nthat can be composed together.'),Object(o.b)("p",null,"Depending on your needs, an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," can be constructed in a variety of ways. The\ntypical closely resembles how a ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," is constructed with one major\ndifference, the arguments used in the function that is passed to\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," constructor are reversed in an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," to match the order in\nwhich ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is parameterized."),Object(o.b)("p",null,"There are many ways to represent asynchronous operations in JavaScript, and as\nsuch, the libraries available to us in our ecosystem provide different means\nto take advantage of these operations. The two most common use\neither ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," returning functions or allow for the Continuation Passing Style\nprevalent in the asynchronous functions that ship with NodeJS. ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," provides\ntwo construction helpers that wrap functions using these styles of asynchronous\nprocessing and will give you back a function that takes the same arguments as\nthe original and will return an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instead. These functions are\ncalled ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#frompromise"}),Object(o.b)("inlineCode",{parentName:"a"},"fromPromise"))," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#fromnode"}),Object(o.b)("inlineCode",{parentName:"a"},"fromNode")),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Async")," instances wrap asynchronous functions and are considered lazy, in that\nthey will not run or execute until needed. This typically happens at an edge in\na program and is done by executing the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#fork"}),Object(o.b)("inlineCode",{parentName:"a"},"fork"))," method available on the\ninstance, which takes three functions as its arguments."),Object(o.b)("p",null,"The first function passed to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#fork"}),Object(o.b)("inlineCode",{parentName:"a"},"fork"))," will be called on\na ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance and passed the value the ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," was\nrejected with. The second function is called when ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#fork"}),Object(o.b)("inlineCode",{parentName:"a"},"fork"))," is invoked on\na ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance receiving the value the ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," was resolved\nwith. The final function is optional and does not need to be provided unless\nsome clean up is required to happen in response to the cancellation of a\nforked ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," flow. This third function takes no parameters and will ignore\nany value that is returned from it. This last function will only be called when\nthe given flow is canceled by calling the function returned from crocks."),Object(o.b)("p",null,"At times, in a given environment, it may not be feasible to run an asynchronous\nflow to completion. To address when these use cases pop up,\nthe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#fork"}),Object(o.b)("inlineCode",{parentName:"a"},"fork"))," function will return a function that ignores its arguments\nand returns ",Object(o.b)("inlineCode",{parentName:"p"},"undefined"),". When this function is called, ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),' will finish\nrunning the current "in flight" computation to completion, but will cease all\nremaining execution. Wrapped functions can return a function that will be called\nwhen an ',Object(o.b)("inlineCode",{parentName:"p"},"Async"),' computation is canceled, this can be used to clear timeouts or\n"in flight" XHR requests. Cancellation with ',Object(o.b)("inlineCode",{parentName:"p"},"Async")," is total and will cancel\nsilently, without notification."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport maybeToAsync from 'crocks/Async/maybeToAsync'\n\nimport First from 'crocks/First'\nimport equals from 'crocks/pointfree/equals'\nimport map from 'crocks/pointfree/map'\nimport mreduceMap from 'crocks/helpers/mreduceMap'\nimport pick from 'crocks/helpers/pick'\nimport safe from 'crocks/Maybe/safe'\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// propEq :: (String, a) -> Object -> Boolean\nconst propEq = (key, value) =>\n  x => equals(x[key], value)\n\n// findById :: Foldable f => (a -> Boolean) -> f a -> Maybe a\nconst findById = id =>\n  mreduceMap(First, safe(propEq('id', id)))\n\n// getById :: Number -> Async String Object\nfunction getById(id) {\n  const data = [\n    { id: 1, name: 'Jimmothy Schmidt', age: 24 },\n    { id: 2, name: 'Tori Blackwood', age: 21 },\n    { id: 3, name: 'Joey Mc Carthy', age: 27 }\n  ]\n\n  return Async(\n    (rej, res) => setTimeout(() => res(data), 1000)\n  ).chain(maybeToAsync(`id: ${id} -- Not Found`, findById(id)))\n}\n\ngetById(3)\n  .map(pick([ 'id', 'name' ]))\n  .fork(log('rej'), log('res'))\n//=> res: { id: 3, name: 'Joey Mc Carthy' }\n\ngetById(5)\n  .map(pick([ 'id', 'name' ]))\n  .fork(log('rej'), log('res'))\n//=> rej: \"id: 5 -- Not Found\"\n\n// cancel :: () -> ()\nconst cancel = getById(1).fork(\n  log('rej'),\n  log('res'),\n  () => console.log('canceled')\n)\n\nsetTimeout(cancel, 500)\n//=> \"canceled\"\n\nAsync\n  .all(map(getById, [ 1, 2 ]))\n  .map(map(pick([ 'id', 'name' ])))\n  .fork(log('rej'), log('res'))\n//=> res: [\n//=>   { id: 1, name: 'Jimmothy Schmidt' },\n//=>   { id: 2, name: 'Tori Blackwood' },\n//=> ]\n\nAsync\n  .all(map(getById, [ 3, 14 ]))\n  .map(map(pick([ 'id', 'name' ])))\n  .fork(log('rej'), log('res'))\n//=> rej:  \"id: 14 -- Not Found\"\n\n// resolveAfter :: (Integer, a) -> Async e a\nconst resolveAfter = (delay, value) =>\n  Async((rej, res) => {\n    const id = setTimeout(() => res(value), delay)\n    return () => clearTimeout(id)\n  })\n\n// afterCancel :: () -> ()\nconst afterCancel = resolveAfter(10000, 'Delay Value')\n  .fork(log('rej'), log('res'))\n\nafterCancel() // this clears the timeout\n")),Object(o.b)("h2",{id:"implements"},"Implements"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Functor"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Alt"),",  ",Object(o.b)("inlineCode",{parentName:"p"},"Bifunctor"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Apply"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Chain"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Monad")),Object(o.b)("h2",{id:"construction"},"Construction"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async :: ((e -> (), a -> ()) -> ()) -> Async e a\nAsync :: ((e -> (), a -> ()) -> (() -> ()) -> Async e a\n")),Object(o.b)("p",null,"There are two possible ways to construct an ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),", depending on the need\nor ability to cancel a given ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," in flight. Both methods of construction\nrequire a binary function that takes two unary functions."),Object(o.b)("p",null,"The first function is used to signal the rejection of a given ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," and will\nsettle on a ",Object(o.b)("inlineCode",{parentName:"p"},"Rejected")," instance wrapping whatever was passed to the function.\nThe second function is used to settle the ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," to a ",Object(o.b)("inlineCode",{parentName:"p"},"Resolved")," instance, also\nwrapping the value passed to the functions. These functions are provided by\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," and will return ",Object(o.b)("inlineCode",{parentName:"p"},"undefined"),"."),Object(o.b)("p",null,"The two ways to construct an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," are characterized by the return of the\nfunction you are using to construct it. If anything other than a function is\nreturned, then the value is ignored."),Object(o.b)("p",null,"If however a function is returned, then the function will be run when\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),' is canceled while it is "in-flight". This function should be used to\nperform any cleanup required in the event of a cancellation. This cleanup\nfunction receives no input and ignores anything that may be returned.'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\n// Async e String\nAsync((reject, resolve) => {\n  const token =\n    setTimeout(() => resolve('fired'), 1000)\n\n  // stop timer on cancel\n  return () => { clearTimeout(token) }\n})\n//=> Resolved \"fired\"\n")),Object(o.b)("h2",{id:"constructor-methods"},"Constructor Methods"),Object(o.b)("h3",{id:"rejected"},"Rejected"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async.Rejected :: e -> Async e a\n")),Object(o.b)("p",null,"Used to construct a ",Object(o.b)("inlineCode",{parentName:"p"},"Rejected")," instance of ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),' that represents the failure\nor "false" case of the disjunction. Calling ',Object(o.b)("inlineCode",{parentName:"p"},"Rejected")," with a given\nvalue, will return a new ",Object(o.b)("inlineCode",{parentName:"p"},"Rejected")," instance, wrapping the provided value."),Object(o.b)("p",null,"When an instance is ",Object(o.b)("inlineCode",{parentName:"p"},"Rejected"),", most ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," returning methods on the instance\nwill return another ",Object(o.b)("inlineCode",{parentName:"p"},"Rejected")," instance. This is in contrast to a\nJavaScript ",Object(o.b)("inlineCode",{parentName:"p"},"Promise"),", that will continue on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," path after\na ",Object(o.b)("inlineCode",{parentName:"p"},"catch"),". This behavior of ",Object(o.b)("inlineCode",{parentName:"p"},"Promise"),"s provide challenges when constructing\ncomplicated (or even some simple) ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," chains that may fail at various\nsteps along the chain."),Object(o.b)("p",null,"Even though ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is a ",Object(o.b)("inlineCode",{parentName:"p"},"Bifunctor"),", in most cases it is desired to keep the\ntype of a ",Object(o.b)("inlineCode",{parentName:"p"},"Rejected")," fixed to a type for a given flow. Given that ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is\na ",Object(o.b)("inlineCode",{parentName:"p"},"Bifunctor"),", it is easy to make sure you get the type you need at the edge\nby leaning on ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#bimap"}),Object(o.b)("inlineCode",{parentName:"a"},"bimap")),' to "square things up".'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nconst { Rejected } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// m :: Async String a\nconst m = Async(\n  rej => { rej('Some Error') }\n)\n\n// n :: Async String a\nconst n =\n  Rejected('Some Error')\n\nm.fork(log('rej'), log('res'))\n//=> rej: \"Some Error\"\n\nn.fork(log('rej'), log('res'))\n//=> rej: \"Some Error\"\n")),Object(o.b)("h3",{id:"resolved"},"Resolved"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async.Resolved :: a -> Async e a\n")),Object(o.b)("p",null,"Used to construct a ",Object(o.b)("inlineCode",{parentName:"p"},"Resolved"),' instance that represents the success or "true"\nportion of the disjunction. ',Object(o.b)("inlineCode",{parentName:"p"},"Resolved")," will wrap any given value passed to this\nconstructor in the ",Object(o.b)("inlineCode",{parentName:"p"},"Resolved")," instance it returns, signaling the validity of the\nwrapped value."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nconst { Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// m :: Async e Number\nconst m = Async(\n  (rej, res) => { res(97) }\n)\n\n// n :: Async e Number\nconst n =\n  Resolved(97)\n\nm.fork(log('rej'), log('res'))\n//=> res: 97\n\nn.fork(log('rej'), log('res'))\n//=> res: 97\n")),Object(o.b)("h3",{id:"frompromise"},"fromPromise"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async.fromPromise :: (* -> Promise a e) -> (* -> Async e a)\n")),Object(o.b)("p",null,'Used to turn an "eager" ',Object(o.b)("inlineCode",{parentName:"p"},"Promise"),' returning function into a function that takes\nthe same arguments, but returns a "lazy" ',Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance instead."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," returning function given to ",Object(o.b)("inlineCode",{parentName:"p"},"fromPromise")," is automatically curried,\nallowing you to partially apply the resulting function to its parameters until\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," type is returned."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\n\nconst { fromPromise } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// safeProm :: ((a -> Boolean), a) -> Promise a a\nconst safeProm = (pred, x) => new Promise(\n  (res, rej) => ifElse(pred, res, rej, x)\n)\n\nsafeProm(isNumber, 34)\n  .then(log('resProm'))\n//=> resProm: 34\n\nsafeProm(isNumber, '34')\n  .catch(log('rejProm'))\n//=> rejProm: \"34\"\n\n// safeAsync :: (a -> Boolean) -> a -> Async a a\nconst safeAsync =\n  fromPromise(safeProm)\n\n// numAsync :: a -> Async a Number\nconst numAsync =\n  safeAsync(isNumber)\n\nnumAsync(34)\n  .fork(log('rej'), log('res'))\n//=> res: 34\n\nnumAsync('34')\n  .fork(log('rej'), log('res'))\n//=> rej: \"34\"\n")),Object(o.b)("h3",{id:"fromnode"},"fromNode"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"NodeCallback :: (e, a) -> ()\nAsync.fromNode :: ((*, NodeCallback) -> ()) -> (* -> Async e a)\nAsync.fromNode :: (((*, NodeCallback) -> ()), ctx) -> (* -> Async e a)\n")),Object(o.b)("p",null,"Many of the asynchronous functions that ship with Node JS provide a Continuation\nPassing Style, that requires the use of a callback function to be passed as the\nlast argument. The provided callback functions are binary functions that take\nan ",Object(o.b)("inlineCode",{parentName:"p"},"err")," as the first argument, which is ",Object(o.b)("inlineCode",{parentName:"p"},"null")," when there is no error to be\nreported. The second argument is the ",Object(o.b)("inlineCode",{parentName:"p"},"data")," representing the result of the\nfunction in the case that there is no error present."),Object(o.b)("p",null,"This interface can create the fabled pyramid of callback doom when trying to\ncombine multiple asynchronous calls. ",Object(o.b)("inlineCode",{parentName:"p"},"fromNode")," can be used to wrap functions\nof this style. Just pass the desired function to wrap and ",Object(o.b)("inlineCode",{parentName:"p"},"fromNode")," will give\nback a new function, that takes the same number of arguments, minus the callback\nfunction."),Object(o.b)("p",null,'When the provided function is called, it returns a "lazy" ',Object(o.b)("inlineCode",{parentName:"p"},"Async"),". When the\nresulting instance is forked, if the ",Object(o.b)("inlineCode",{parentName:"p"},"err")," is a non-null value then the\ninstance will be ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," with the ",Object(o.b)("inlineCode",{parentName:"p"},"err")," value. When the ",Object(o.b)("inlineCode",{parentName:"p"},"err")," is\nnull, then the instance will be ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," with the ",Object(o.b)("inlineCode",{parentName:"p"},"data")," value."),Object(o.b)("p",null,"There are some libraries whose functions are methods on some stateful object.\nAs such, the need for binding may arise. ",Object(o.b)("inlineCode",{parentName:"p"},"fromNode")," provides a second, optional\nargument that takes the context that will be used to bind the function being\nwrapped."),Object(o.b)("p",null,"Any curried interface will not be respected and if a curried interface is needed\nthen ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/helpers#nary"}),Object(o.b)("inlineCode",{parentName:"a"},"nAry"))," can be used."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport curry from 'crocks/helpers/curry'\nimport isNumber from 'crocks/predicates/isNumber'\nimport nAry from 'crocks/helpers/nAry'\nimport partial from 'crocks/helpers/partial'\n\nconst { fromNode } = Async\n\n// log :: String -> a -> a\nconst log = curry(label => x =>\n  (console.log(`${label}:`, x), x)\n)\n\n// NodeCallback :: (e, a) -> ()\n// delay :: (Number, a, NodeCallback (String, Number)) -> ()\nfunction delay(delay, val, cb) {\n  setTimeout(\n    () => isNumber(val) ? cb(null, val) : cb('No Number'),\n    delay\n  )\n}\n\n// callback :: (e, a) -> ()\nconst callback = (err, data) => {\n  err ? log('err', err) : log('data', data)\n}\n\n// wait500 :: a -> NodeCallback (String, Number) -> ()\nconst wait500 =\n  partial(delay, 500)\n\nwait500(32, callback)\n//=> data: 32\n\nwait500('32', callback)\n//=> err: \"No Number\"\n\n// delayAsync :: Number -> a -> Async String Number\nconst delayAsync =\n  nAry(2, fromNode(delay))\n\n// waitAsync :: a -> Async String Number\nconst waitAsync =\n  delayAsync(1000)\n\nwaitAsync(32)\n  .fork(log('rej'), log('res'))\n//=> res: 32\n\nwaitAsync('32')\n  .fork(log('rej'), log('res'))\n//=> rej: \"No Number\"\n")),Object(o.b)("h3",{id:"all"},"all"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async.all :: [ Async e a ] -> Async e [ a ]\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Async")," provides an ",Object(o.b)("inlineCode",{parentName:"p"},"all")," method that can be used when multiple, independent\nasynchronous operations need to be run in parallel. ",Object(o.b)("inlineCode",{parentName:"p"},"all")," takes\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," of ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instances that, when forked, will execute each instance\nin the provided ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," in parallel."),Object(o.b)("p",null,"If any of the instances result in a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," state, the entire flow will\nbe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," with value of the first ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance. If all\ninstances resolve, then the entire instance is ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," with\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Array")," containing all ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," values in their provided order."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nconst { all, Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\nall([ Resolved(1), Resolved(2), Resolved(3) ])\n  .fork(log('rej'), log('res'))\n//=> res: [ 1, 2, 3 ]\n\nall([ Resolved(1), Rejected(2), Rejected(3) ])\n  .fork(log('rej'), log('res'))\n//=> rej: 2\n")),Object(o.b)("h3",{id:"resolveafter"},"resolveAfter"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async.resolveAfter :: (Integer, a) -> Async e a\n")),Object(o.b)("p",null,"Used to resolve a value after a specified number of milliseconds. This function\ntakes a positive Integer as its first argument and a value to resolve with as\nits second. ",Object(o.b)("inlineCode",{parentName:"p"},"resolveAfter")," returns a new ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," that will resolve a value\nafter the specified interval has elapsed."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\nimport curry from 'crocks/helpers/curry'\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// delay :: Integer -> a -> Async e a\nconst delay = curry(\n  Async.resolveAfter\n)\n\nAsync.of('late, but here')\n  .chain(delay(1000))\n  .fork(log('rejected'), log('resolved'))\n//=> resolved: \"late, but here\"\n")),Object(o.b)("h3",{id:"rejectafter"},"rejectAfter"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async.rejectAfter :: (Integer, e) -> Async e a\n")),Object(o.b)("p",null,"Used to reject a value after a specified number of milliseconds. This function\ntakes a positive Integer as its first argument and a value to reject with as\nits second. This can be used to reject and ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," after a specified period\nof time. When used with ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#race"}),Object(o.b)("inlineCode",{parentName:"a"},"race")),", the ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," provided can be used\nto provide a time limit for a given ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," task."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// resovle :: a -> Async e a\nconst resolve = x => Async((rej, res) => {\n  setTimeout(() => res(x), 1000)\n})\n\nresolve('okay')\n  .race(Async.rejectAfter(500, 'not okay'))\n  .fork(log('reject'), log('resolve'))\n//=> reject: \"not okay\"\n")),Object(o.b)("h3",{id:"of"},"of"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async.of :: a -> Async e a\n")),Object(o.b)("p",null,"Used to wrap any value into an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," as a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance, ",Object(o.b)("inlineCode",{parentName:"p"},"of"),' is\nused mostly by helper functions that work "generically" with instances of\neither ',Object(o.b)("inlineCode",{parentName:"p"},"Applicative")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),". When working specifically with\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," type, the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," constructor should be\nused. Reach for ",Object(o.b)("inlineCode",{parentName:"p"},"of")," when working with functions that will work with\nANY ",Object(o.b)("inlineCode",{parentName:"p"},"Applicative"),"/",Object(o.b)("inlineCode",{parentName:"p"},"Monad"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nconst { Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\nAsync.of('U Wut M8')\n  .fork(log('rej'), log('res'))\n//=> res: \"U Wut M8\"\n\nResolved('U Wut M8')\n  .fork(log('rej'), log('res'))\n//=> res: \"U Wut M8\"\n\nAsync((rej, res) => res('U Wut M8'))\n  .fork(log('rej'), log('res'))\n//=> res: \"U Wut M8\"\n")),Object(o.b)("h2",{id:"instance-methods"},"Instance Methods"),Object(o.b)("h3",{id:"map"},"map"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> (a -> b) -> Async e b\n")),Object(o.b)("p",null,"Used to apply transformations to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," values of an ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),", ",Object(o.b)("inlineCode",{parentName:"p"},"map")," takes\na function that it will lift into the context of the ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," and apply to it\nthe wrapped value. When ran on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance, ",Object(o.b)("inlineCode",{parentName:"p"},"map")," will apply the\nwrapped value to the provided function and return the result in a\nnew ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport and from 'crocks/logic/and'\nimport compose from 'crocks/helpers/compose'\nimport constant from 'crocks/combinators/constant'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\nimport map from 'crocks/pointfree/map'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// double :: Number -> Number\nconst double =\n  x => x * 2\n\n// gt10 :: Number -> Boolean\nconst gt10 =\n  x => x > 10\n\n// isValid :: a -> Async String Number\nconst isValid = ifElse(\n  and(isNumber, gt10),\n  Resolved,\n  constant(Rejected('Not Valid'))\n)\n\n// doubleValid :: a -> Async String Number\nconst doubleValid =\n  compose(map(double), isValid)\n\nResolved(34)\n  .map(double)\n  .fork(log('rej'), log('res'))\n//=> res: 68\n\nRejected('34')\n  .map(double)\n  .fork(log('rej'), log('res'))\n//=> rej: \"34\"\n\ndoubleValid(76)\n  .fork(log('rej'), log('res'))\n//=> res: 152\n\ndoubleValid('Too Silly')\n  .fork(log('rej'), log('res'))\n//=> rej: \"Not Valid\"\n")),Object(o.b)("h3",{id:"alt"},"alt"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> Async e a -> Async e a\n")),Object(o.b)("p",null,"Providing a means for a fallback or alternative value, ",Object(o.b)("inlineCode",{parentName:"p"},"alt")," combines\ntwo ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instances and will return the first ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance\nit encounters or the last ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance if it does not\nencounter a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\nResolved(true)\n  .alt(Rejected('Bad News'))\n  .fork(log('rej'), log('res'))\n//=> res: true\n\nRejected('First Reject')\n  .alt(Rejected('Second Reject'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Second Reject\"\n\nRejected('First Reject')\n  .alt(Resolved('First Resolve'))\n  .alt(Rejected('Second Reject'))\n  .alt(Resolved('Second Resolve'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"First Resolve\"\n")),Object(o.b)("h3",{id:"bimap"},"bimap"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> ((e -> b), (a -> c)) -> Async b c\n")),Object(o.b)("p",null,"Both ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," values can vary in\ntheir type, although most of the time, focus on mapping values is placed on\nthe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," portion. When the requirement or need to map\nthe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," portion arises, ",Object(o.b)("inlineCode",{parentName:"p"},"bimap")," can be used."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"bimap")," takes two functions as its arguments. The first function is used\nto map a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance, while the second maps\na ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance. While ",Object(o.b)("inlineCode",{parentName:"p"},"bimap")," requires that both possible\ninstances are to be mapped, if the desire to map only\nthe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," portion, an ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(o.b)("inlineCode",{parentName:"a"},"identity"))," function can be\nprovided to the second argument. This will leave\nall ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance values untouched."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport setProp from 'crocks/helpers/setProp'\nimport bimap from 'crocks/pointfree/bimap'\nimport compose from 'crocks/helpers/compose'\nimport objOf from 'crocks/helpers/objOf'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// hasError :: Boolean -> Object -> Object\nconst hasError =\n  setProp('hasError')\n\n// buildError :: a -> String\nconst buildError =\n  x => `${x}: is not valid`\n\n// buildResult :: (String, Boolean) -> a -> Object\nconst buildResult = (key, isError) =>\n  compose(hasError(isError), objOf(key))\n\n// finalize :: Bifunctor m => m a b -> m Object Object\nconst finalize = bimap(\n  compose(buildResult('error', true), buildError),\n  buildResult('result', false)\n)\n\nfinalize(Resolved('Good To Go'))\n  .fork(log('rej'), log('res'))\n//=> res: { result: \"Good To Go\", hasError: false }\n\nfinalize(Rejected(null))\n  .fork(log('rej'), log('res'))\n//=> rej: { error: \"null is not valid\", hasError: true }\n")),Object(o.b)("h3",{id:"ap"},"ap"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e (a -> b) ~> Async e a -> Async e b\n")),Object(o.b)("p",null,"Short for apply, ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," is used to apply an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance containing a value\nto another ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance that contains a function, resulting in\nnew ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance with the result. ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," requires that it is called on\nan instance that is either ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," or ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," that wraps a curried\npolyadic function."),Object(o.b)("p",null,"When either ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected")),", ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," will return a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance, that\nwraps the value of the original ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance. This can be used to safely\ncombine multiple values under a given combination function. If any of the inputs\nresult in a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," than they will never be applied to the function and will\nnot result in undesired exceptions or results."),Object(o.b)("p",null,"When ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#fork"}),Object(o.b)("inlineCode",{parentName:"a"},"fork")),"ed, all ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),"s chained with multiple ",Object(o.b)("inlineCode",{parentName:"p"},"ap")," invocations\nwill be executed concurrently."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport liftA2 from 'crocks/helpers/liftA2'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// resolveAfter :: (Integer, a) -> Async e a\nconst resolveAfter = (delay, x) => Async(\n  (rej, res) => setTimeout(() => res(x), delay)\n)\n\n// join :: String -> String -> String\nconst join =\n  a => b => `${a} ${b}`\n\nAsync.of(join)\n  .ap(Resolved('blip'))\n  .ap(Resolved('blop'))\n  .fork(log('rej'), log('res'))\n//=> res: \"blip blop\"\n\nAsync.of(join)\n  .ap(Resolved('blip'))\n  .ap(Rejected('Not Good'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Not Good\"\n\nResolved('splish')\n  .map(join)\n  .ap(Resolved('splash'))\n  .fork(log('rej'), log('res'))\n//=> res: \"splish splash\"\n\n// first :: Async e String\nconst first =\n  resolveAfter(5000, 'first')\n\n// second :: Async e String\nconst second =\n  resolveAfter(5000, 'second')\n\n// `ap` runs all Asyncs at the same time in parallel.\n// This will finish running in about 5 seconds and\n// not 10 seconds\n\nliftA2(join, first, second)\n  .fork(log('rej'), log('res'))\n//=> res: \"first second\"\n")),Object(o.b)("h3",{id:"chain"},"chain"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> (a -> Async e b) -> Async e b\n")),Object(o.b)("p",null,"Combining a sequential series of transformations that capture disjunction can be\naccomplished with ",Object(o.b)("inlineCode",{parentName:"p"},"chain"),". ",Object(o.b)("inlineCode",{parentName:"p"},"chain")," expects a unary, ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," returning function\nas its argument. When invoked on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance, ",Object(o.b)("inlineCode",{parentName:"p"},"chain")," will not run\nthe function, but will instead return another ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance wrapping the\noriginal ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," value. When called on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance however, the\ninner value will be passed to provided function, returning the result as the\nnew instance."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport chain from 'crocks/pointfree/chain'\nimport compose from 'crocks/helpers/compose'\nimport composeK from 'crocks/helpers/composeK'\nimport constant from 'crocks/combinators/constant'\nimport flip from 'crocks/combinators/flip'\nimport getProp from 'crocks/Maybe/getProp'\nimport ifElse from 'crocks/logic/ifElse'\nimport isString from 'crocks/predicates/isString'\nimport maybeToAsync from 'crocks/Async/maybeToAsync'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// safe :: (b -> Boolean) -> b -> Async String a\nconst safe = pred =>\n  ifElse(pred, Resolved, constant(Rejected('Not Safe')))\n\n// test :: RegExp -> String -> Boolean\nconst test = regex => str =>\n  regex.test(str)\n\n// lookup :: String -> Async String String\nconst lookup = compose(\n  maybeToAsync('Not Found'),\n  flip(getProp, { 'file-a': 'file-b', 'file-b': 'file-c' })\n)\n\n// fake :: String -> Async String Object\nconst fake = compose(\n  chain(lookup),\n  chain(safe(test(/^file-(a|b|c)/))),\n  safe(isString)\n)\n\nfake('file-a')\n  .fork(log('rej'), log('res'))\n//=> file-b\n\n// getTwo :: a -> Async String String\nconst getTwo =\n  composeK(fake, fake)\n\ngetTwo('file-a')\n  .fork(log('rej'), log('res'))\n//=> res: file-c\n\ngetTwo('file-b')\n  .fork(log('rej'), log('res'))\n//=> rej: \"Not Found\"\n\ngetTwo(76)\n  .fork(log('rej'), log('res'))\n//=> rej: \"Not Safe\"\n")),Object(o.b)("h3",{id:"coalesce"},"coalesce"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> ((e -> b), (a -> b))) -> Async e b\n")),Object(o.b)("p",null,"Used as a means to apply a computation to a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance and then map\nany ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," value while transforming it to a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," to continue\ncomputation. ",Object(o.b)("inlineCode",{parentName:"p"},"coalesce")," on an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," can be used to model the all too\nfamiliar, and more imperative ",Object(o.b)("inlineCode",{parentName:"p"},"if/else")," flow in a more declarative manner."),Object(o.b)("p",null,"The first function is used when invoked on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance and will\nreturn a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance wrapping the result of the function. The second\nfunction is used when ",Object(o.b)("inlineCode",{parentName:"p"},"coalesce")," is invoked on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance and is used\nto map the original value, returning a new ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance wrapping the\nresult of the second function."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport coalesce from 'crocks/pointfree/coalesce'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// label :: String -> String -> String\nconst label =\n  lbl => x => `${lbl} ${x}`\n\n// resolve :: Async e String -> Async e String\nconst resolve =\n  coalesce(label('Was'), label('Still'))\n\nresolve(Resolved('Resolved'))\n  .fork(log('rej'), log('res'))\n//=> res: \"Still Resolved\"\n\nresolve(Rejected('Rejected'))\n  .fork(log('rej'), log('res'))\n//=> res: \"Was Rejected\"\n")),Object(o.b)("h3",{id:"bichain"},"bichain"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> ((e -> Async b c), (a -> Async b c)) -> Async b c\n")),Object(o.b)("p",null,"Combining a sequential series of transformations that capture disjunction can be\naccomplished with ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#chain"}),Object(o.b)("inlineCode",{parentName:"a"},"chain")),". Along the same lines, ",Object(o.b)("inlineCode",{parentName:"p"},"bichain")," allows you\nto do this from both ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved")),". ",Object(o.b)("inlineCode",{parentName:"p"},"bichain")," expects\ntwo unary, ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," returning functions as its arguments. When invoked on\na ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance, ",Object(o.b)("inlineCode",{parentName:"p"},"bichain")," will use the left, or first, function\nthat can return either a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," or ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance.\nWhen called on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance, it will behave exactly\nas ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#chain"}),Object(o.b)("inlineCode",{parentName:"a"},"chain"))," would with the right, or second function."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import bichain from 'crocks/pointfree/bichain'\n\nimport Async from 'crocks/Async'\n\nimport equals from 'crocks/pointfree/equals'\nimport maybeToAsync from 'crocks/Async/maybeToAsync'\nimport propSatisfies from 'crocks/predicates/propSatisfies'\nimport safe from 'crocks/Maybe/safe'\nimport substitution from 'crocks/combinators/substitution'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\nconst fork = m =>\n  m.fork(log('rej'), log('res'))\n\nfork(\n  bichain(Resolved, Rejected, Resolved(42))\n)\n//=> rej: 42\n\nfork(\n  bichain(Resolved, Rejected, Rejected(42))\n)\n//=> res: 42\n\n// fake401 :: Async Response a\nconst fake401 = Rejected({\n  status: 'Unauthorized',\n  statusCode: 401\n})\n\n// fake500 :: Async Response a\nconst fake500 = Rejected({\n  status: 'Internal Server Error',\n  statusCode: 500\n})\n\n// fake200 :: Async e Response\nconst fake200 = Resolved({\n  status: 'OK',\n  statusCode: 200\n})\n\n// allow401 :: Response -> Async e a\nconst allow401 = substitution(\n  maybeToAsync,\n  safe(propSatisfies('statusCode', equals(401)))\n)\n\nfork(bichain(allow401, Resolved, fake500))\n//=> rej: { status: 'Internal Server Error', statusCode: 500 }\n\nfork(bichain(allow401, Resolved, fake401))\n//=> res: { status: 'Unauthorized', statusCode: 401 }\n\nfork(bichain(allow401, Resolved, fake200))\n//=> res: { status: 'OK', statusCode: 200 }\n")),Object(o.b)("h3",{id:"swap"},"swap"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> ((e -> b), (a -> c)) -> Async c b\n")),Object(o.b)("p",null,"Used to map the value of a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," into a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," or a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," to\na ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected")),", ",Object(o.b)("inlineCode",{parentName:"p"},"swap")," takes two functions as its arguments. The first function\nis used to map the expected ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," value into a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved")),", while the\nsecond goes from ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected")),". If no mapping is required on either,\nthen ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../functions/combinators#identity"}),Object(o.b)("inlineCode",{parentName:"a"},"identity"))," functions can be used in one or both arguments."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport compose from 'crocks/helpers/compose'\nimport identity from 'crocks/combinators/identity'\nimport swap from 'crocks/pointfree/swap'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// length :: String -> Integer\nconst length =\n  x => x.length\n\n// repeat :: String -> Number -> String\nconst repeat =\n  char => n => char.repeat(n)\n\n// values :: Async String Number -> Async String Number\nconst values =\n  swap(length, repeat('a'))\n\n// valueIso :: Async String Number -> Async String Number\nconst valueIso =\n  compose(values, values)\n\n// types :: Async a b -> b a\nconst types =\n  swap(identity, identity)\n\n// typeIso :: Async a b -> b a\nconst typeIso =\n  compose(types, types)\n\nvalues(Resolved(5))\n  .fork(log('rej'), log('res'))\n//=> rej: \"aaaaa\"\n\nvalues(Rejected('aaaaa'))\n  .fork(log('rej'), log('res'))\n//=> res: 5\n\nvalueIso(Resolved(5))\n  .fork(log('rej'), log('res'))\n//=> res: 5\n\nvalueIso(Rejected('aaaaa'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"aaaaa\"\n\ntypes(Resolved(5))\n  .fork(log('rej'), log('res'))\n//=> rej: 5\n\ntypes(Rejected('aaaaa'))\n  .fork(log('rej'), log('res'))\n//=> res: \"aaaaa\"\n\ntypeIso(Resolved(5))\n  .fork(log('rej'), log('res'))\n//=> res: 5\n\ntypeIso(Rejected('aaaaa'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"aaaaa\"\n")),Object(o.b)("h3",{id:"race"},"race"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> Async e a -> Async e a\n")),Object(o.b)("p",null,"Used to provide the first settled result between two ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),"s. Just\npass ",Object(o.b)("inlineCode",{parentName:"p"},"race")," another ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," and it will return new ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),", that when forked,\nwill run both ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),"s in parallel, returning the first of the two to settle.\nThe result can either be rejected or resolved, based on the instance of the\nfirst settled result."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from '../crocks/src/Async'\n\nconst { resolveAfter, rejectAfter } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\nresolveAfter(300, 'I win')\n  .race(resolveAfter(400, 'I lose'))\n  .fork(log('rejected'), log('resolved'))\n//=> resolved: \"I win\"\n\nrejectAfter(500, 'I lose')\n  .race(rejectAfter(300, 'I win'))\n  .fork(log('rejected'), log('resolved'))\n//=> rejected: \"I win\"\n\nresolveAfter(500, 'I lose')\n  .race(rejectAfter(300, 'I win'))\n  .fork(log('rejected'), log('resolved'))\n//=> rejected: \"I win\"\n")),Object(o.b)("h3",{id:"fork"},"fork"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> ((e -> ()), (a -> ())) -> (() -> ())\nAsync e a ~> ((e -> ()), (a -> ()), (() -> ())) -> (() -> ())\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," type is lazy and will not be executed until told to do so\nand ",Object(o.b)("inlineCode",{parentName:"p"},"fork")," is the primary method used for execution. ",Object(o.b)("inlineCode",{parentName:"p"},"fork")," implements two\nsignatures depending on the need for clean up in the event of cancellation, but\nboth return a function that can be used for cancellation of a given instance."),Object(o.b)("p",null,"The first and more common signature takes two functions that will have their\nreturn values ignored. The first function will be run in the event of\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance settling on ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected")),' and will receive as its\nsingle argument the value or "cause" of rejection. The second function provided\nwill be executed in the case of the instance settling on ',Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," and\nwill receive as its single argument the value the ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," was resolved with."),Object(o.b)("p",null,"The second signature is used when any cleanup needs to be performed after a\ngiven ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is canceled by having the function returned from ",Object(o.b)("inlineCode",{parentName:"p"},"fork"),' called.\nThe first two arguments to the signature are the same as the more common\nsignature described above, but takes an addition function that can be used\nfor "clean up" after cancellation. When all in-flight computations settle, the\nfunction provided will be silently executed.'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport compose from 'crocks/helpers/compose'\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// inc :: Number -> Number\nconst inc =\n  n => n + 1\n\n// delay :: a -> Async e a\nconst delay = x => Async(\n  (rej, res) => { setTimeout(() => res(x), 1000) }\n).map(compose(inc, log('value')))\n\ndelay(0)\n  .chain(delay)\n  .chain(delay)\n  .fork(log('rej'), log('res'))\n//=> value: 0\n//=> value: 1\n//=> value: 2\n//=> res: 3\n\nconst cancel =\n  delay(0)\n    .chain(delay)\n    .chain(delay)\n    .fork(log('rej'), log('res'))\n//=> value: 0\n//=> value: 1\n\nsetTimeout(cancel, 2200)\n")),Object(o.b)("h3",{id:"topromise"},"toPromise"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"Async e a ~> () -> Promise a e\n")),Object(o.b)("p",null,"While ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#fork"}),Object(o.b)("inlineCode",{parentName:"a"},"fork"))," is the more common method for running an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance,\nthere may come time where a ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," is needed at the edge of a given program\nor flow. When the need to integrate into an existing ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," chain\narises, ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," provides the ",Object(o.b)("inlineCode",{parentName:"p"},"toPromise")," method."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"toPromise")," takes no arguments and when invoked will fork the instance\ninternally and return a ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," that will be in-flight. This comes in handy\nfor integration with other ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," based libraries that are utilized in a\ngiven application, program or flow."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nconst { Rejected, Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\nResolved('resolved')\n  .toPromise()\n  .then(log('res'))\n  .catch(log('rej'))\n//=> res: resolved\n\nRejected('rejected')\n  .toPromise()\n  .then(log('res'))\n  .catch(log('rej'))\n//=> rej: rejected\n")),Object(o.b)("h2",{id:"pointfree-functions"},"Pointfree Functions"),Object(o.b)("h3",{id:"race-pointfree"},"race (pointfree)"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Async/race")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"race :: Async e a -> Async e a -> Async e a\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"race")," pointfree function accepts two ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instances and will return\na new ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance that is the result of applying the first argument to\nthe ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#race"}),Object(o.b)("inlineCode",{parentName:"a"},"race"))," method on the second passed instance."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import race from 'crocks/Async/race'\nimport Async from 'crocks/Async'\n\nconst { resolveAfter, rejectAfter } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// timeout :: Async Error a -> Async Error a\nconst timeout =\n  race(rejectAfter(300, new Error('Request has timed out')))\n\n// fast :: Async e String\nconst fast =\n  resolveAfter(150, 'All good')\n\n// slow :: Async e Boolean\nconst slow =\n  resolveAfter(900, true)\n\ntimeout(fast)\n  .fork(log('rejected'), log('resolved'))\n//=> resolved: \"All good\"\n\ntimeout(slow)\n  .fork(log('rejected'), log('resolved'))\n//=> rejected: \"Error: Request has timed out\"\n")),Object(o.b)("h2",{id:"transformation-functions"},"Transformation Functions"),Object(o.b)("h3",{id:"asynctopromise"},"asyncToPromise"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Async/asyncToPromise")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"asyncToPromise :: Async e a -> Promise a e\nasyncToPromise :: (a -> Async e b) -> a -> Promise b e\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"asyncToPromise")," function takes an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," and when invoked will fork\nthe instance internally and return a ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," that will be in-flight. This\ncomes in handy for integration with other ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," based libraries that are\nutilized in a given application, program or flow through composition."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\nimport race from 'crocks/Async/race'\nimport asyncToPromise from 'crocks/Async/asyncToPromise'\n\nimport ifElse from 'crocks/logic/ifElse'\nimport compose from 'crocks/helpers/compose'\nimport isPromise from 'crocks/pointfree/isPromise'\n\nconst { resolveAfter, rejectAfter } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// logIt :: Promise a e -> Promise a e\nconst logIt = p =>\n  p.then(log('resolved'), log('rejected'))\n\nconst logResult =\n  compose(logIt, ifElse(isPromise, x => x, asyncToPromise))\n\nconst failingPromise =\n  new Promise((resolve, reject) => setTimeout(() => reject('Promise rejected!'), 300))\n\n// timeout :: Async Error a -> Async Error a\nconst timeout =\n  race(rejectAfter(300, new Error('Request has timed out')))\n\n// fast :: Async e String\nconst fast =\n  resolveAfter(150, 'All good')\n\n// slow :: Async e Boolean\nconst slow =\n  resolveAfter(900, true)\n\nlogResult(timeout(fast))\n//=> resolved: \"All good\"\n\nlogResult(timeout(slow))\n//=> rejected: \"Error: Request has timed out\"\n\nlogResult(failingPromise)\n//=> rejected: \"Promise rejected!\"\n")),Object(o.b)("h3",{id:"eithertoasync"},"eitherToAsync"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Async/eitherToAsync")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"eitherToAsync :: Either b a -> Async b a\neitherToAsync :: (a -> Either c b) -> a -> Async c b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either"))," instance to an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance or\nflatten an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," of ",Object(o.b)("inlineCode",{parentName:"p"},"Either")," into an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," when chained, ",Object(o.b)("inlineCode",{parentName:"p"},"eitherToAsync")," will\nturn a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Either#right"}),Object(o.b)("inlineCode",{parentName:"a"},"Right"))," instance into a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance\nwrapping the original value contained in the original ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Either#right"}),Object(o.b)("inlineCode",{parentName:"a"},"Right")),". If a\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Either#left"}),Object(o.b)("inlineCode",{parentName:"a"},"Left"))," is provided, then ",Object(o.b)("inlineCode",{parentName:"p"},"eitherToAsync")," will return a\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance, wrapping the original ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Either#left"}),Object(o.b)("inlineCode",{parentName:"a"},"Left"))," value."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"eitherToAsync")," has two possible\nsignatures and will behave differently when passed\nan ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either"))," instance or a function that returns an instance\nof ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either")),". When passed the instance, a transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is\nreturned. When passed an ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Either"}),Object(o.b)("inlineCode",{parentName:"a"},"Either"))," returning function, a function will\nbe returned that takes a given value and returns an ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\nimport Either from 'crocks/Either'\n\nimport eitherToAsync from 'crocks/Async/eitherToAsync'\n\nimport and from 'crocks/logic/and'\nimport ifElse from 'crocks/logic/ifElse'\nimport isNumber from 'crocks/predicates/isNumber'\n\nconst { Resolved } = Async\nconst { Left, Right } = Either\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// gte :: Number -> Number -> Boolean\nconst gte =\n  x => y => y >= x\n\n// isLarge :: a -> Boolean\nconst isLarge =\n  and(isNumber, gte(10))\n\n// isValid :: a -> Either String a\nconst isValid = ifElse(\n  isLarge,\n  Right,\n  x => Left(`${x} is not valid`)\n)\n\neitherToAsync(Right('Correct'))\n  .fork(log('rej'), log('res'))\n//=> res: \"Correct\"\n\neitherToAsync(Left('Not Good'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Not Good\"\n\nResolved(54)\n  .chain(eitherToAsync(isValid))\n  .fork(log('rej'), log('res'))\n//=> res: 54\n\nResolved(4)\n  .chain(eitherToAsync(isValid))\n  .fork(log('rej'), log('res'))\n//=> rej: \"4 is not valid\"\n\nResolved('Bubble')\n  .chain(eitherToAsync(isValid))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Bubble is not valid\"\n\nResolved(Left('Alone'))\n  .chain(eitherToAsync)\n  .fork(log('rej'), log('res'))\n//=> rej: \"Alone\"\n\nResolved(Right('Away'))\n  .chain(eitherToAsync)\n  .fork(log('rej'), log('res'))\n//=> res: \"Away\"\n")),Object(o.b)("h3",{id:"firsttoasync"},"firstToAsync"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Async/firstToAsync")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"firstToAsync :: e -> First a -> Async e a\nfirstToAsync :: e -> (a -> First b) -> a -> Async e b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," instance to an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance or\nflatten an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," of ",Object(o.b)("inlineCode",{parentName:"p"},"First")," into an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," when chained, ",Object(o.b)("inlineCode",{parentName:"p"},"firstToAsync")," will\nturn a non-empty ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," instance into a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved")),"\ninstance wrapping the original value contained in the original non-empty."),Object(o.b)("p",null,"The ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," datatype is based on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," and as such its left or empty value\nis fixed to a ",Object(o.b)("inlineCode",{parentName:"p"},"()")," type. As a means to allow for convenient\ntransformation, ",Object(o.b)("inlineCode",{parentName:"p"},"firstToAsync")," takes a default ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," value as the first\nargument. This value will be wrapped in a resulting ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance in the\ncase of empty."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"firstToAsync")," has two possible\nsignatures and will behave differently when passed either a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," instance\nor a function that returns an instance of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First")),". When passed the instance,\na transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is returned. When passed a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/First"}),Object(o.b)("inlineCode",{parentName:"a"},"First"))," returning function,\na function will be returned that takes a given value and returns an ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\nimport First from 'crocks/First'\n\nimport firstToAsync from 'crocks/Async/firstToAsync'\n\nimport Pred from 'crocks/Pred'\nimport isString from 'crocks/predicates/isString'\nimport mconcatMap from 'crocks/helpers/mconcatMap'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// length :: String -> Number\nconst length =\n  x => x.length\n\n// gte :: Number -> Number -> Boolean\nconst gte =\n  x => y => y >= x\n\n// isValid :: Pred String\nconst isValid =\n  Pred(isString)\n    .concat(Pred(gte(4)).contramap(length))\n\n// firstValid :: [ String ] -> First String\nconst firstValid =\n  mconcatMap(First, safe(isValid))\n\n// findFirstValid :: [ String ] -> Async String String\nconst findFirstValid =\n  firstToAsync('Nothing Found', firstValid)\n\nfirstToAsync('Error', First(true))\n  .fork(log('rej'), log('res'))\n//=> res: true\n\nfirstToAsync('Error', First.empty())\n  .fork(log('rej'), log('res'))\n//=> rej: \"Error\"\n\nResolved([ 'cat', 'rhino', 'unicorn' ])\n  .chain(findFirstValid)\n  .fork(log('rej'), log('res'))\n//=> res: \"rhino\"\n\nResolved([ 1, 2, 3 ])\n  .chain(findFirstValid)\n  .fork(log('rej'), log('res'))\n//=> rej: \"Nothing Found\"\n\nResolved([ 'cat', 'bat', 'imp' ])\n  .chain(findFirstValid)\n  .fork(log('rej'), log('res'))\n//=> rej: \"Nothing Found\"\n\nResolved(First.empty())\n  .chain(firstToAsync('Left'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Left\"\n\nResolved(First(42))\n  .chain(firstToAsync('Left'))\n  .fork(log('rej'), log('res'))\n//=> res: 42\n")),Object(o.b)("h3",{id:"lasttoasync"},"lastToAsync"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Async/lastToAsync")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"lastToAsync :: e -> Last a -> Async e a\nlastToAsync :: e -> (a -> Last b) -> a -> Async e b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," instance to an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance or\nflatten an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," of ",Object(o.b)("inlineCode",{parentName:"p"},"Last")," into an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," when chained, ",Object(o.b)("inlineCode",{parentName:"p"},"lastToAsync")," will\nturn a non-empty ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," instance into a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved")),"\ninstance wrapping the original value contained in the original non-empty."),Object(o.b)("p",null,"The ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," datatype is based on a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," and as such its left or empty value\nis fixed to a ",Object(o.b)("inlineCode",{parentName:"p"},"()")," type. As a means to allow for convenient\ntransformation, ",Object(o.b)("inlineCode",{parentName:"p"},"lastToAsync")," takes a default ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," value as the first\nargument. This value will be wrapped in a resulting ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance, in the\ncase of empty."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"lastToAsync")," has two possible\nsignatures and will behave differently when passed either a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," instance\nor a function that returns an instance of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last")),". When passed the instance,\na transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is returned. When passed a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../monoids/Last"}),Object(o.b)("inlineCode",{parentName:"a"},"Last"))," returning function,\na function will be returned that takes a given value and returns an ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\nimport Last from 'crocks/Last'\n\nimport lastToAsync from 'crocks/Async/lastToAsync'\n\nimport Pred from 'crocks/Pred'\nimport isString from 'crocks/predicates/isString'\nimport mconcatMap from 'crocks/helpers/mconcatMap'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Resolved } = Async\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// length :: String -> Number\nconst length =\n  x => x.length\n\n// gte :: Number -> Number -> Boolean\nconst gte =\n  x => y => y >= x\n\n// isValid :: Pred String\nconst isValid =\n  Pred(isString)\n    .concat(Pred(gte(4)).contramap(length))\n\n// lastValid :: [ String ] -> Last String\nconst lastValid =\n  mconcatMap(Last, safe(isValid))\n\n// findLastValid :: [ String ] -> Async String String\nconst findLastValid =\n  lastToAsync('Nothing Found', lastValid)\n\nlastToAsync('Error', Last(true))\n  .fork(log('rej'), log('res'))\n//=> res: true\n\nlastToAsync('Error', Last.empty())\n  .fork(log('rej'), log('res'))\n//=> rej: \"Error\"\n\nResolved([ 'unicorn', 'rhino', 'cat' ])\n  .chain(findLastValid)\n  .fork(log('rej'), log('res'))\n//=> res: \"rhino\"\n\nResolved([ 1, 2, 3 ])\n  .chain(findLastValid)\n  .fork(log('rej'), log('res'))\n//=> rej: \"Nothing Found\"\n\nResolved([ 'cat', 'bat', 'imp' ])\n  .chain(findLastValid)\n  .fork(log('rej'), log('res'))\n//=> rej: \"Nothing Found\"\n\nResolved(Last.empty())\n  .chain(lastToAsync('Left'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Left\"\n\nResolved(Last('too know!'))\n  .chain(lastToAsync('Left'))\n  .fork(log('rej'), log('res'))\n//=> res: \"too know!\"\n")),Object(o.b)("h3",{id:"maybetoasync"},"maybeToAsync"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Async/maybeToAsync")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"maybeToAsync :: e -> Maybe a -> Async e a\nmaybeToAsync :: e -> (a -> Maybe b) -> a -> Async e b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," instance to an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance or\nflatten an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," of ",Object(o.b)("inlineCode",{parentName:"p"},"Maybe")," into an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," when chained, ",Object(o.b)("inlineCode",{parentName:"p"},"maybeToAsync")," will\nturn a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#just"}),Object(o.b)("inlineCode",{parentName:"a"},"Just"))," instance into a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance wrapping\nthe original value contained in the original ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#just"}),Object(o.b)("inlineCode",{parentName:"a"},"Just")),"."),Object(o.b)("p",null,"A ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#nothing"}),Object(o.b)("inlineCode",{parentName:"a"},"Nothing"))," instance is fixed to a ",Object(o.b)("inlineCode",{parentName:"p"},"()")," type and as such can only ever contain\na value of ",Object(o.b)("inlineCode",{parentName:"p"},"undefined"),". As a means to allow for convenient\ntransformation, ",Object(o.b)("inlineCode",{parentName:"p"},"maybeToAsync")," takes a default ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," value as the first\nargument. This value will be wrapped in a resulting ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance, in the\ncase of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe#nothing"}),Object(o.b)("inlineCode",{parentName:"a"},"Nothing")),"."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"maybeToAsync")," has two possible\nsignatures and will behave differently when passed either a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," instance\nor a function that returns an instance of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe")),". When passed the instance,\na transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is returned. When passed a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Maybe"}),Object(o.b)("inlineCode",{parentName:"a"},"Maybe"))," returning function,\na function will be returned that takes a given value and returns an ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\nimport Maybe from 'crocks/Maybe'\n\nimport maybeToAsync from 'crocks/Async/maybeToAsync'\n\nimport and from 'crocks/logic/and'\nimport isEmpty from 'crocks/predicates/isEmpty'\nimport isArray from 'crocks/predicates/isArray'\nimport not from 'crocks/logic/not'\nimport safe from 'crocks/Maybe/safe'\n\nconst { Resolved } = Async\nconst { Nothing, Just } = Maybe\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// isValid :: a -> Maybe [ b ]\nconst isValid = safe(\n  and(isArray, not(isEmpty))\n)\n\nmaybeToAsync(false, Just(true))\n  .fork(log('rej'), log('res'))\n//=> res: true\n\nmaybeToAsync('Bad', Nothing())\n  .fork(log('rej'), log('res'))\n//=> rej: \"Bad\"\n\nResolved([ 'a', 'b', 'c' ])\n  .chain(maybeToAsync('Invalid', isValid))\n  .fork(log('rej'), log('res'))\n//=> res: [ 'a', 'b', 'c' ]\n\nResolved([])\n  .chain(maybeToAsync('Invalid', isValid))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Invalid\"\n\nResolved('')\n  .chain(maybeToAsync('Invalid', isValid))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Invalid\"\n\nResolved(Nothing())\n  .chain(maybeToAsync('Left'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Left\"\n\nResolved(Just('the 2 of us'))\n  .chain(maybeToAsync('Left'))\n  .fork(log('rej'), log('res'))\n//=> res: \"the 2 of us\"\n")),Object(o.b)("h3",{id:"resulttoasync"},"resultToAsync"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/Async/resultToAsync")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"resultToAsync :: Result b a -> Async b a\nresultToAsync :: (a -> Result c b) -> a -> Async c b\n")),Object(o.b)("p",null,"Used to transform a given ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(o.b)("inlineCode",{parentName:"a"},"Result"))," instance to an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," instance or flatten\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(o.b)("inlineCode",{parentName:"a"},"Result"))," into an ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," when chained, ",Object(o.b)("inlineCode",{parentName:"p"},"resultToAsync")," will turn\nan ",Object(o.b)("inlineCode",{parentName:"p"},"Ok")," instance into a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#resolved"}),Object(o.b)("inlineCode",{parentName:"a"},"Resolved"))," instance wrapping the original\nvalue contained in the original ",Object(o.b)("inlineCode",{parentName:"p"},"Ok"),". If an ",Object(o.b)("inlineCode",{parentName:"p"},"Err")," is provided, then ",Object(o.b)("inlineCode",{parentName:"p"},"resultToAsync")," will\nreturn a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#rejected"}),Object(o.b)("inlineCode",{parentName:"a"},"Rejected"))," instance, wrapping the original ",Object(o.b)("inlineCode",{parentName:"p"},"Err")," value."),Object(o.b)("p",null,"Like all ",Object(o.b)("inlineCode",{parentName:"p"},"crocks")," transformation functions, ",Object(o.b)("inlineCode",{parentName:"p"},"resultToAsync")," has two possible\nsignatures and will behave differently when passed either a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(o.b)("inlineCode",{parentName:"a"},"Result"))," instance\nor a function that returns an instance of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(o.b)("inlineCode",{parentName:"a"},"Result")),". When passed the instance,\na transformed ",Object(o.b)("inlineCode",{parentName:"p"},"Async")," is returned. When passed a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./Result"}),Object(o.b)("inlineCode",{parentName:"a"},"Result"))," returning function,\na function will be returned that takes a given value and returns an ",Object(o.b)("inlineCode",{parentName:"p"},"Async"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import Async from 'crocks/Async'\n\nimport Result from 'crocks/Result'\n\nimport resultToAsync from 'crocks/Async/resultToAsync'\n\nimport identity from 'crocks/combinators/identity'\nimport isNumber from 'crocks/predicates/isNumber'\nimport tryCatch from 'crocks/Result/tryCatch'\n\nconst { Resolved } = Async\n\nconst { Err, Ok }  = Result\n\n// log :: String -> a -> a\nconst log = label => x =>\n  (console.log(`${label}:`, x), x)\n\n// notNumber :: a -> Number\nfunction notNumber(x) {\n  if (!isNumber(x)) {\n    throw new TypeError('Must be a Number')\n  }\n  return x\n}\n\n// safeFail :: a -> Result TypeError Number\nconst safeFail =\n  tryCatch(notNumber)\n\nresultToAsync(Ok(99))\n  .fork(log('rej'), log('res'))\n//=> res: 99\n\nresultToAsync(Err('Not Good'))\n  .fork(log('rej'), log('res'))\n//=> rej: \"Not Good\"\n\nResolved(103)\n  .chain(resultToAsync(safeFail))\n  .bimap(x => x.message, identity)\n  .fork(log('rej'), log('res'))\n//=> res: 103\n\nResolved('103')\n  .chain(resultToAsync(safeFail))\n  .bimap(x => x.message, identity)\n  .fork(log('rej'), log('res'))\n//=> rej: \"Must be a Number\"\n\nResolved(Err('Invalid entry'))\n  .chain(resultToAsync)\n  .fork(log('rej'), log('res'))\n//=> rej: \"Invalid entry\"\n\nResolved(Ok('Success!'))\n  .chain(resultToAsync)\n  .fork(log('rej'), log('res'))\n//=> res: \"Success!\"\n\n")))}b.isMDXComponent=!0}}]);