(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{100:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return d}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=r.a.createContext({}),l=function(e){var n=r.a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},m=function(e){var n=l(e.components);return r.a.createElement(p.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=l(t),u=a,d=m["".concat(i,".").concat(u)]||m[u]||b[u]||o;return t?r.a.createElement(d,s(s({ref:n},p),{},{components:t})):r.a.createElement(d,s({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},73:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return l}));var a=t(2),r=t(6),o=(t(0),t(100)),i={description:"Combinators API",layout:"notopic",title:"Combinators",functions:["applyto","composeb","constant","converge","flip","identity","psi","substitution"],weight:10},s={unversionedId:"functions/combinators",id:"functions/combinators",isDocsHomePage:!1,title:"Combinators",description:"Combinators API",source:"@site/docs/functions/combinators.md",slug:"/functions/combinators",permalink:"/docs/functions/combinators",editUrl:"https://github.com/evilsoft/crocks/edit/master/docs/docs/functions/combinators.md",version:"current",sidebar:"sidebar",previous:{title:"Functions",permalink:"/docs/functions/"},next:{title:"Helpers",permalink:"/docs/functions/helpers"}},c=[{value:"applyTo",id:"applyto",children:[]},{value:"compose2",id:"compose2",children:[]},{value:"composeB",id:"composeb",children:[]},{value:"constant",id:"constant",children:[]},{value:"converge",id:"converge",children:[]},{value:"flip",id:"flip",children:[]},{value:"identity",id:"identity",children:[]},{value:"psi",id:"psi",children:[]},{value:"substitution",id:"substitution",children:[]}],p={rightToc:c};function l(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h3",{id:"applyto"},"applyTo"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/applyTo")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"applyTo :: a -> (a -> b) -> b\n")),Object(o.b)("p",null,"Ever run into a situation where you have a value but do not have a function to\napply it to? Well this little bird, named Thrush, is there to help out. Just\ngive it a value and it will give you back a function ready to take a function.\nOnce that function is provided, it will return the result of applying your value\nto that function."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import applyTo from 'crocks/combinators/applyTo'\n\nimport First from 'crocks/First'\nimport Pair from 'crocks/Pair'\n\nimport compose from 'crocks/helpers/compose'\nimport flip from 'crocks/combinators/flip'\nimport isArray from 'crocks/predicates/isArray'\nimport isNumber from 'crocks/predicates/isNumber'\nimport isString from 'crocks/predicates/isString'\nimport map from 'crocks/pointfree/map'\nimport merge from 'crocks/pointfree/merge'\nimport mreduceMap from 'crocks/helpers/mreduceMap'\nimport safeLift from 'crocks/Maybe/safeLift'\n\n// prices :: [ Number ]\nconst prices = [ 4.99, 29.99, 15.99 ]\n\n// getPrices :: (a -> b) -> [ Number ]\nconst getPrices = compose(\n  applyTo(prices),\n  map\n)\n\n// discount :: Number -> Number -> Number\nconst discount = percent => price =>\n  Number((price - percent / 100 * price).toFixed(2))\n\ngetPrices(discount(10))\n//=> [ 4.49, 26.99, 14.39 ]\n\ngetPrices(discount(80))\n//=> [ 1, 6, 3.2 ]\n\n// add :: Number -> Number -> Number\nconst add = x => y =>\n  x + y\n\n// runAll :: [ (a -> b) ] -> a -> [ b ]\nconst runAll =\n  flip(compose(map, applyTo))\n\nrunAll([ add(10), add(20) ], 3)\n//=> [ 13, 23 ]\n\n// length :: [ a ] -> Number\nconst length = x =>\n  x.length\n\n// yell :: String -> String\nconst yell = x =>\n  x.toUpperCase()\n\n// Strategy :: Pair (a -> Boolean) (* -> *)\n// strategies :: [ Strategy ]\nconst strategies = [\n  Pair(isNumber, add(10)),\n  Pair(isArray, length),\n  Pair(isString, yell)\n]\n\n// options :: [ Strategy ] -> a -> b\nconst options = flip(\n  x => mreduceMap(\n    First,\n    compose(applyTo(x), merge(safeLift))\n  )\n)\n\noptions(strategies, 'hello')\n//=> Just \"HELLO\"\n\noptions(strategies, [ 1, 9, 39 ])\n//=> Just 3\n\noptions(strategies, 13)\n//=> Just 23\n\noptions(strategies, null)\n//=> Nothing\n")),Object(o.b)("h3",{id:"compose2"},"compose2"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/compose2")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"compose2 :: (c -> d -> e) -> (a -> c) -> (b -> d) -> a -> b -> e\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"compose2")," allows for composition between a ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," function and\ntwo ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," functions. ",Object(o.b)("inlineCode",{parentName:"p"},"compose2")," takes a ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," function followed by\ntwo ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," functions and returns a ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," function that maps the first\nargument with the first ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," and the second with the second, passing\nthe results to the given ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," and returning the result."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import compose2 from 'crocks/combinators/compose2'\n\nimport and from 'crocks/logic/and'\nimport applyTo from 'crocks/combinators/applyTo'\nimport flip from 'crocks/combinators/flip'\nimport hasProp from 'crocks/predicates/hasProp'\nimport isNumber from 'crocks/predicates/isNumber'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport map from 'crocks/pointfree/map'\nimport prop from 'crocks/Maybe/prop'\nimport safe from 'crocks/Maybe/safe'\nimport safeLift from 'crocks/Maybe/safeLift'\n\n// isNonZero :: Number -> Boolean\nconst isNonZero = x =>\n  x !== 0\n\n// isValidDivisor :: Number -> Boolean\nconst isValidDivisor =\n  and(isNumber, isNonZero)\n\n// divideBy :: Number -> Number -> Number\nconst divideBy = x => y =>\n  y / x\n\n// safeDivide :: Number -> Number -> Maybe Number\nconst safeDivide = compose2(\n  liftA2(divideBy),\n  safe(isValidDivisor),\n  safe(isNumber)\n)\n\nsafeDivide(0.5, 21)\n//=> Just 42\n\nsafeDivide('0.5', 21)\n//=> Nothing\n\nsafeDivide(0.5, '21')\n//=> Nothing\n\nsafeDivide(29, 0)\n//=> Just 0\n\nsafeDivide(0, 29)\n//=> Nothing\n\n// Item :: { id: Integer }\n// Items :: Array Item\nconst items =\n  [ { id: 2 }, { id: 1 } ]\n\n// pluck :: String -> Array Object -> Maybe a\nconst pluck =\n  compose2(applyTo, prop, flip(map))\n\npluck('id', items)\n//=> [ Just 2, Just 1 ]\n\n// summarize :: String -> String -> String\nconst summarize = name => count =>\n  `${name} purchased ${count} items`\n\n// getLength :: a -> Maybe Number\nconst getLength = safeLift(\n  hasProp('length'),\n  x => x.length\n)\n\n// createSummary :: Person -> Array Item -> String\nconst createSummary = compose2(\n  liftA2(summarize),\n  prop('name'),\n  getLength\n)\n\ncreateSummary({\n  name: 'Sam Smith'\n}, items)\n//=> Just \"Sam Smith purchased 2 items\"\n\n// capitalize :: String -> String\nconst capitalize = str =>\n  `${str.charAt(0).toUpperCase()}${str.slice(1)}`\n\n// join :: String -> String -> String -> String\nconst join = delim => right => left =>\n  `${left}${delim}${right}`\n\n// toUpper :: String -> String\nconst toUpper = x =>\n  x.toUpperCase()\n\n// createName :: String -> String -> String\nconst createName =\n  compose2(join(', '), capitalize, toUpper)\n\ncreateName('Jon', 'doe')\n//=> DOE, Jon\n\ncreateName('sara', 'smith')\n//=> SMITH, Sara\n")),Object(o.b)("h3",{id:"composeb"},"composeB"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/composeB")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"composeB :: (b -> c) -> (a -> b) -> a -> c\n")),Object(o.b)("p",null,"Provides a means to describe a composition between two functions. it takes two\nfunctions and a value. Given ",Object(o.b)("inlineCode",{parentName:"p"},"composeB(f, g)"),", which is read ",Object(o.b)("inlineCode",{parentName:"p"},"f")," after ",Object(o.b)("inlineCode",{parentName:"p"},"g"),", it\nwill return a function that will take value ",Object(o.b)("inlineCode",{parentName:"p"},"a")," and apply it to ",Object(o.b)("inlineCode",{parentName:"p"},"g"),", passing the\nresult as an argument to ",Object(o.b)("inlineCode",{parentName:"p"},"f"),", and will finally return the result of ",Object(o.b)("inlineCode",{parentName:"p"},"f"),". This\nallows only two functions, if you want to avoid things like:\n",Object(o.b)("inlineCode",{parentName:"p"},"composeB(composeB(f, g), composeB(h, i))")," then check\nout ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./helpers#compose"}),Object(o.b)("inlineCode",{parentName:"a"},"compose")),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import composeB from 'crocks/combinators/composeB'\n\nimport Either from 'crocks/Either'\n\nimport ifElse from 'crocks/logic/ifElse'\nimport isString from 'crocks/predicates/isString'\n\nconst { Left, Right } = Either\n\n// yell :: String -> String\nconst yell = x =>\n  `${x.toUpperCase()}!`\n\n// safeYell :: a -> Either a String\nconst safeYell =  ifElse(\n  isString,\n  composeB(Right, yell),\n  Left\n)\n\nsafeYell('quite')\n//=> Right \"QUITE!\"\n\nsafeYell(42)\n//=> Left 42\n")),Object(o.b)("h3",{id:"constant"},"constant"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/constant")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"constant :: a -> () -> a\n")),Object(o.b)("p",null,"This is a very handy dandy function, used a lot. Pass it any value and it will\ngive you back a function that will return that same value no matter what you\npass it.\n",Object(o.b)("inlineCode",{parentName:"p"},"constant")," is perfect for those moments where you need to pass a function but\ndo not care about the input. ",Object(o.b)("inlineCode",{parentName:"p"},"constant")," will swallow any value given to it and\nalways return the initial value it was given.\nIt is important to note that any function that is passed into ",Object(o.b)("inlineCode",{parentName:"p"},"constant")," will\nget the added benefit of having ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./helpers#curry"}),Object(o.b)("inlineCode",{parentName:"a"},"curry"))," applied to it."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import constant from 'crocks/combinators/constant'\n\nimport Result from 'crocks/Result'\n\nimport bimap from 'crocks/pointfree/bimap'\nimport composeB from 'crocks/combinators/composeB'\nimport ifElse from 'crocks/logic/ifElse'\nimport isString from 'crocks/predicates/isString'\nimport getPropOr from 'crocks/helpers/getPropOr'\n\nconst { Ok, Err } = Result\n\n// whatsTheAnswer :: () -> Number\nconst whatsTheAnswer =\n  constant(42)\n\nwhatsTheAnswer('to life?')\n//=> 42\n\nwhatsTheAnswer('to the universe?')\n//=> 42\n\nwhatsTheAnswer('to everything?')\n//=> 42\n\n// ensure :: (a -> Boolean) -> a -> Result a\nconst ensure = pred =>\n  ifElse(pred, Ok, Err)\n\n// getLength :: Result a String -> Result Number\nconst getLength = bimap(\n  constant(0), getPropOr(0, 'length')\n)\n\n// getLengthOfString :: a -> Result a String\nconst getLengthOfString = composeB(\n  getLength,\n  ensure(isString)\n)\n\ngetLengthOfString('testing')\n//=> Ok 7\n\ngetLengthOfString(42)\n//=> Err 0\n\ngetLengthOfString([ 1, 2, 3, 4 ])\n//=> Err 0\n")),Object(o.b)("h3",{id:"converge"},"converge"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/converge")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"converge :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\n")),Object(o.b)("p",null,"Provides a means of passing an acculumating function and two branching functions.\nA value can be applied to the resulting function which will then be applied to\neach branching function, the results of which will be applied to the accumulating\nfunction."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import converge from 'crocks/combinators/converge'\n\nimport alt from 'crocks/pointfree/alt'\nimport getProp from 'crocks/Maybe/getProp'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport getPropOr from 'crocks/helpers/getPropOr'\n\n// data :: [ Number ]\nconst data = [ 1, 2, 3, 4, 5 ]\n\n// divide :: Number -> Number -> Number\nconst divide = x => y =>\n  y / x\n\n// add :: (Number, Number) -> Number\nconst add = (a, b) =>\n  b + a\n\n// sum :: [ Number ] -> Number\nconst sum = xs =>\n  xs.reduce(add, 0)\n\n// length :: [ a ] -> Number\nconst length =\n  getPropOr(0, 'length')\n\n// average :: [ Number ] -> Number\nconst average =\n  converge(divide, length, sum)\n\naverage(data)\n//=> 3\n\n// maybeGetDisplay :: a -> Maybe b\nconst maybeGetDisplay =\n  getProp('display')\n\n// maybeGetFirst :: a -> Maybe b\nconst maybeGetFirst =\n  getProp('first')\n\n// maybeGetLast :: a -> Maybe b\nconst maybeGetLast =\n  getProp('last')\n\n// buildFullName :: String -> String -> String\nconst buildFullName = surname => firstname =>\n  `${firstname} ${surname}`\n\n// maybeConcatStrings :: Maybe String -> Maybe String -> Maybe String\nconst maybeBuildFullName = a => b =>\n  liftA2(buildFullName, a, b)\n    .alt(a)\n    .alt(b)\n\n// maybeMakeDisplay :: a -> Maybe String\nconst maybeMakeDisplay = converge(\n  maybeBuildFullName,\n  maybeGetLast,\n  maybeGetFirst\n)\n\n// maybeGetName :: a -> Maybe b\nconst maybeGetName =\n  converge(alt, maybeMakeDisplay, maybeGetDisplay)\n\nmaybeGetName({ display: 'Jack Sparrow' })\n//=> Just \"Jack Sparrow\"\n\nmaybeGetName({ first: 'J', last: 'S' })\n//=> Just \"J S\"\n\nmaybeGetName({ display: 'Jack Sparrow', first: 'J', last: 'S' })\n//=> Just \"Jack Sparrow\"\n\nmaybeGetName({ first: 'J' })\n//=> Just \"J\"\n\nmaybeGetName({ first: 'S' })\n//=> Just \"S\"\n")),Object(o.b)("h3",{id:"flip"},"flip"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/flip")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"flip :: (a -> b -> c) -> b -> a -> c\n")),Object(o.b)("p",null,"This little function just takes a function and returns a function that takes\nthe first two parameters in reverse. ",Object(o.b)("inlineCode",{parentName:"p"},"flip")," is perfectly suited for those\nmoments where you have the context of your function but not the data.\nApplying ",Object(o.b)("inlineCode",{parentName:"p"},"flip")," to the function will allow you to pass in your context and will\nreturn a function waiting for the data. This will happen often when you're\nusing composition."),Object(o.b)("p",null,"When required, one can compose flip calls down the line to flip all, or some of\nthe other parameters if there are more than two. Mix and match to your heart's\ndesire."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import flip from 'crocks/combinators/flip'\n\nimport Pred from 'crocks/Pred'\n\nimport composeB from 'crocks/combinators/composeB'\nimport concat from 'crocks/pointfree/concat'\nimport isNumber from 'crocks/predicates/isNumber'\nimport mconcat from 'crocks/helpers/mconcat'\nimport runWith from 'crocks/pointfree/runWith'\n\nconcat('first param. ', 'second param. ')\n//=> \"second param. first param. \"\"\n\nflip(concat, 'first param. ', 'second param. ')\n//=> \"first param. second param. \"\"\n\n// checkAll :: [ a -> Boolean ] -> a -> Boolean\nconst checkAll =\n  composeB(flip(runWith), mconcat(Pred))\n\n// lte :: Number -> Number -> Boolean\nconst lte = a => b =>\n  b <= a\n\n// gte :: Number -> Number -> Boolean\nconst gte = a => b =>\n  b >= a\n\n// between2and10 :: a -> Boolean\nconst between2and10 = checkAll([\n  isNumber,\n  gte(2),\n  lte(10)\n])\n\nbetween2and10(8)\n//=> true\n\nbetween2and10(11)\n//=> false\n\nbetween2and10(1)\n//=> false\n\nbetween2and10('not a number')\n//=> false\n")),Object(o.b)("h3",{id:"identity"},"identity"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/identity")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"identity ::  a -> a\n")),Object(o.b)("p",null,"This function and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#constant"}),Object(o.b)("inlineCode",{parentName:"a"},"constant"))," are the workhorses of writing code\nwith this library. It quite simply is just a function that when you pass it\nsomething, it returns that thing right back to you. So simple, I will leave it\nas an exercise to reason about why this is so powerful and important."),Object(o.b)("h3",{id:"psi"},"psi"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/psi")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"psi ::  (b -> b -> c) -> (a -> b) -> a -> a -> c\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"psi")," is a function that can be considered the sister of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#converge"}),Object(o.b)("inlineCode",{parentName:"a"},"converge")),".\nWhere ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#converge"}),Object(o.b)("inlineCode",{parentName:"a"},"converge"))," takes one argument and maps it through\ntwo ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," functions, merging the resulting values with a binary\nfunction, ",Object(o.b)("inlineCode",{parentName:"p"},"psi")," takes two arguments and runs them each through the\nsame ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," function before merging them with the given binary function."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"psi")," is often used to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"./helpers#compose"}),Object(o.b)("inlineCode",{parentName:"a"},"compose"))," equality checking functions\nor when needing to validate two arguments of the same type."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import psi from 'crocks/combinators/psi'\n\nimport and from 'crocks/logic/and'\nimport equals from 'crocks/pointfree/equals'\nimport isNumber from 'crocks/predicates/isNumber'\nimport liftA2 from 'crocks/helpers/liftA2'\nimport safe from 'crocks/Maybe/safe'\n\n// isNonZero :: Number -> Boolean\nconst isNonZero = x =>\n  x !== 0\n\n// isValidDivisor :: Number -> Boolean\nconst isValidDivisor =\n  and(isNumber, isNonZero)\n\n// divideBy :: Number -> Number -> Number\nconst divideBy = x => y =>\n  y / x\n\n// safeDivide :: Number -> Number -> Maybe Number\nconst safeDivide =\n  psi(liftA2(divideBy), safe(isValidDivisor))\n\nsafeDivide(0.5, 21)\n//=> Just 42\n\nsafeDivide('0.5', 21)\n//=> Nothing\n\nsafeDivide(0.5, '21')\n//=> Nothing\n\nsafeDivide(29, 0)\n//=> Nothing\n\n// capitalize :: String -> String\nconst capitalize = str =>\n  `${str.charAt(0).toUpperCase()}${str.slice(1)}`\n\n// join :: String -> String -> String -> String\nconst join = delim => right => left =>\n  `${left}${delim}${right}`\n\n// createName :: String -> String -> String\nconst createName =\n  psi(join(', '), capitalize)\n\ncreateName('Jon', 'doe')\n//=> Doe, Jon\n\ncreateName('sara', 'smith')\n//=> Smith, Sara\n\n// toLowerCase :: String -> String\nconst toLowerCase = str =>\n  str.toLowerCase()\n\n// equalsIgnoreCase :: String -> String -> Boolean\nconst equalsIgnoreCase =\n  psi(equals, toLowerCase)\n\nequalsIgnoreCase('test', 'TEst')\n//=> true\n\nequalsIgnoreCase('test', 'not-test')\n//=> false\n")),Object(o.b)("h3",{id:"substitution"},"substitution"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"crocks/combinators/substitution")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-haskell"}),"substitution :: (a -> b -> c) -> (a -> b) -> a -> c\n")),Object(o.b)("p",null,"While it may seem like a complicated little bugger, ",Object(o.b)("inlineCode",{parentName:"p"},"substitution")," can come in\nvery handy from time to time. ",Object(o.b)("inlineCode",{parentName:"p"},"substitution")," is used when you have a ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," function\nand you can supply the first argument and can use that value to create the\nsecond argument. It first takes a ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," function followed by a ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," function\nfor it's first two arguments. This will return a function that is ready to take\nsome context, ",Object(o.b)("inlineCode",{parentName:"p"},"a"),". Once supplied the fun starts, it will pass the given ",Object(o.b)("inlineCode",{parentName:"p"},"a")," to\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," and ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," functions, and will then apply the result of\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"unary")," function as the second parameter of the ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," function. Finally\nafter all that juggling, it will return the result of that ",Object(o.b)("inlineCode",{parentName:"p"},"binary")," function."),Object(o.b)("p",null,"When used with partial application on that first parameter, a whole new world\nof combinatory madness is presented!"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:"runkit",runkit:!0}),"import substitution from 'crocks/combinators/substitution'\n\nimport composeB from 'crocks/combinators/composeB'\nimport curry from 'crocks/core/curry'\n\n// getDetails :: String -> Number -> String\nconst getDetails = curry((text, length) =>\n  `The given text \"${text}\" has a length of ${length}`\n)\n\n// getLength :: a -> Number\nconst getLength = s =>\n  s.length\n\nsubstitution(getDetails, getLength, 'testing')\n//=> \"The given text \\\"testing\\\" has a length of 7\"\n\n// getLastIndex :: a -> Number\nconst getLastIndex = composeB(\n  x => x - 1,\n  getLength\n)\n\n// slice :: Array -> Number -> Array\nconst slice = curry((arr, index) =>\n  arr.slice(index))\n\nsubstitution(slice, getLastIndex, [ 1, 2, 3, 4, 5 ])\n//=> [ 5 ]\n")))}l.isMDXComponent=!0}}]);